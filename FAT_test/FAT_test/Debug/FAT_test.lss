
FAT_test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003940  00000000  00000000  00010000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00003940  00003940  00013940  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000444  20000000  00003948  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .hramc1       00000000  21000000  21000000  00020444  2**0
                  CONTENTS
  4 .bss          00000d44  20000444  00003d8c  00020444  2**2
                  ALLOC
  5 .stack        00004000  20001188  00004ad0  00020444  2**0
                  ALLOC
  6 .ARM.attributes 0000002a  00000000  00000000  00020444  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  0002046e  2**0
                  CONTENTS, READONLY
  8 .debug_info   0003be4c  00000000  00000000  000204c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00002499  00000000  00000000  0005c313  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000072c9  00000000  00000000  0005e7ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000518  00000000  00000000  00065a75  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000678  00000000  00000000  00065f8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0002df13  00000000  00000000  00066605  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000060d2  00000000  00000000  00094518  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000ffc8e  00000000  00000000  0009a5ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  000012d8  00000000  00000000  0019a278  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	88 51 00 20 b9 09 00 00 b5 09 00 00 b5 09 00 00     .Q. ............
      10:	b5 09 00 00 b5 09 00 00 b5 09 00 00 00 00 00 00     ................
	...
      2c:	b5 09 00 00 b5 09 00 00 00 00 00 00 b5 09 00 00     ................
      3c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      4c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      5c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      6c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      7c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      8c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      9c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      ac:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      bc:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      cc:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      dc:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      ec:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
      fc:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
     10c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
     11c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
     12c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
     13c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
     14c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
     15c:	b5 09 00 00 b5 09 00 00 b5 09 00 00 b5 09 00 00     ................
     16c:	b5 09 00 00 00 00 00 00 b5 09 00 00 b5 09 00 00     ................
     17c:	b5 09 00 00                                         ....

00000180 <__do_global_dtors_aux>:
     180:	b510      	push	{r4, lr}
     182:	4c05      	ldr	r4, [pc, #20]	; (198 <__do_global_dtors_aux+0x18>)
     184:	7823      	ldrb	r3, [r4, #0]
     186:	b933      	cbnz	r3, 196 <__do_global_dtors_aux+0x16>
     188:	4b04      	ldr	r3, [pc, #16]	; (19c <__do_global_dtors_aux+0x1c>)
     18a:	b113      	cbz	r3, 192 <__do_global_dtors_aux+0x12>
     18c:	4804      	ldr	r0, [pc, #16]	; (1a0 <__do_global_dtors_aux+0x20>)
     18e:	f3af 8000 	nop.w
     192:	2301      	movs	r3, #1
     194:	7023      	strb	r3, [r4, #0]
     196:	bd10      	pop	{r4, pc}
     198:	20000444 	.word	0x20000444
     19c:	00000000 	.word	0x00000000
     1a0:	00003948 	.word	0x00003948

000001a4 <frame_dummy>:
     1a4:	4b0c      	ldr	r3, [pc, #48]	; (1d8 <frame_dummy+0x34>)
     1a6:	b143      	cbz	r3, 1ba <frame_dummy+0x16>
     1a8:	480c      	ldr	r0, [pc, #48]	; (1dc <frame_dummy+0x38>)
     1aa:	490d      	ldr	r1, [pc, #52]	; (1e0 <frame_dummy+0x3c>)
     1ac:	b510      	push	{r4, lr}
     1ae:	f3af 8000 	nop.w
     1b2:	480c      	ldr	r0, [pc, #48]	; (1e4 <frame_dummy+0x40>)
     1b4:	6803      	ldr	r3, [r0, #0]
     1b6:	b923      	cbnz	r3, 1c2 <frame_dummy+0x1e>
     1b8:	bd10      	pop	{r4, pc}
     1ba:	480a      	ldr	r0, [pc, #40]	; (1e4 <frame_dummy+0x40>)
     1bc:	6803      	ldr	r3, [r0, #0]
     1be:	b933      	cbnz	r3, 1ce <frame_dummy+0x2a>
     1c0:	4770      	bx	lr
     1c2:	4b09      	ldr	r3, [pc, #36]	; (1e8 <frame_dummy+0x44>)
     1c4:	2b00      	cmp	r3, #0
     1c6:	d0f7      	beq.n	1b8 <frame_dummy+0x14>
     1c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     1cc:	4718      	bx	r3
     1ce:	4b06      	ldr	r3, [pc, #24]	; (1e8 <frame_dummy+0x44>)
     1d0:	2b00      	cmp	r3, #0
     1d2:	d0f5      	beq.n	1c0 <frame_dummy+0x1c>
     1d4:	4718      	bx	r3
     1d6:	bf00      	nop
     1d8:	00000000 	.word	0x00000000
     1dc:	00003948 	.word	0x00003948
     1e0:	20000448 	.word	0x20000448
     1e4:	00003948 	.word	0x00003948
     1e8:	00000000 	.word	0x00000000

000001ec <SPI_init>:
#include "AK_SD.h"

void SPI_init()
{
	//Disable GPIO on pins used for SPI
	GPIO->bf.Port[0].bf.GPERC.reg = (uint32_t)(1) << 21;
     1ec:	4b31      	ldr	r3, [pc, #196]	; (2b4 <SPI_init+0xc8>)
     1ee:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
     1f2:	609a      	str	r2, [r3, #8]
	GPIO->bf.Port[0].bf.GPERC.reg = (uint32_t)(1) << 22;
     1f4:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
     1f8:	609a      	str	r2, [r3, #8]
	GPIO->bf.Port[1].bf.GPERC.reg = (uint32_t)(1) << 11;
     1fa:	f44f 6100 	mov.w	r1, #2048	; 0x800
     1fe:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
	GPIO->bf.Port[2].bf.GPERC.reg = (uint32_t)(1) << 30;
     202:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     206:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
	//GPIO->bf.Port[0].bf.GPERC.reg = 0x00200000;
	//GPIO->bf.Port[0].bf.GPERC.reg = GPIO_PA21;
	//GPIO->bf.Port[0].bf.GPERC.bit.P21 = 1; //has a slight performance hit
	
    //Configure peripheral Muxing registers (PMR 0-2) to specify that the peripheral function of these GPIO pins is SPI (peripheral function B)
	GPIO->bf.Port[0].bf.PMR0C.reg = GPIO_PA21 | GPIO_PA22;
     20a:	f44f 00c0 	mov.w	r0, #6291456	; 0x600000
     20e:	6198      	str	r0, [r3, #24]
	GPIO->bf.Port[0].bf.PMR1C.reg = GPIO_PA21 | GPIO_PA22;
     210:	6298      	str	r0, [r3, #40]	; 0x28
	GPIO->bf.Port[0].bf.PMR2C.reg = GPIO_PA21 | GPIO_PA22;
     212:	6398      	str	r0, [r3, #56]	; 0x38
	
	GPIO->bf.Port[1].bf.PMR0S.reg = GPIO_PB11B_SPI_NPCS2;
     214:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
	GPIO->bf.Port[1].bf.PMR1C.reg = GPIO_PB11;
     218:	f8c3 1228 	str.w	r1, [r3, #552]	; 0x228
	GPIO->bf.Port[1].bf.PMR2C.reg = GPIO_PB11;
     21c:	f8c3 1238 	str.w	r1, [r3, #568]	; 0x238
	
	GPIO->bf.Port[2].bf.PMR0S.reg = GPIO_PC30;
     220:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
	GPIO->bf.Port[2].bf.PMR1C.reg = GPIO_PC30;
     224:	f8c3 2428 	str.w	r2, [r3, #1064]	; 0x428
	GPIO->bf.Port[2].bf.PMR2C.reg = GPIO_PC30;
     228:	f8c3 2438 	str.w	r2, [r3, #1080]	; 0x438
	
	//enable system clock to be used for SPI peripheral
	PM->bf.UNLOCK.reg =  0xAA000000 | PM_PBAMASK_OFFSET;
     22c:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     230:	4a21      	ldr	r2, [pc, #132]	; (2b8 <SPI_init+0xcc>)
     232:	659a      	str	r2, [r3, #88]	; 0x58
	PM->bf.PBAMASK.reg |= PM_PBAMASK_SPI;
     234:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     236:	f042 0202 	orr.w	r2, r2, #2
     23a:	629a      	str	r2, [r3, #40]	; 0x28
	
	//configure SPI
	SPI->bf.MR.bit.MSTR = 1; //set mode to master (in mode register);
     23c:	f5a3 2358 	sub.w	r3, r3, #884736	; 0xd8000
     240:	685a      	ldr	r2, [r3, #4]
     242:	f042 0201 	orr.w	r2, r2, #1
     246:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.MODFDIS = 1;//set mode fault detection to off
     248:	685a      	ldr	r2, [r3, #4]
     24a:	f042 0210 	orr.w	r2, r2, #16
     24e:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.PS = 0;  //set as fixed peripheral (will need to change this if talking to more than one device)
     250:	685a      	ldr	r2, [r3, #4]
     252:	f36f 0241 	bfc	r2, #1, #1
     256:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.PCSDEC = 0;//use CS lines directly not in decode mode)
     258:	685a      	ldr	r2, [r3, #4]
     25a:	f36f 0282 	bfc	r2, #2, #1
     25e:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.PCS = 0b1011; //peripheral chip select.
     260:	685a      	ldr	r2, [r3, #4]
     262:	210b      	movs	r1, #11
     264:	f361 4213 	bfi	r2, r1, #16, #4
     268:	605a      	str	r2, [r3, #4]
    
	SPI->bf.CSR[2].bit.CPOL = 0; //set clock polarity (see reference table)
     26a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     26c:	f36f 0200 	bfc	r2, #0, #1
     270:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.NCPHA = 1; //set clock phase (see reference table)
     272:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     274:	f042 0202 	orr.w	r2, r2, #2
     278:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.CSAAT=1; //something with timing
     27a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     27c:	f042 0208 	orr.w	r2, r2, #8
     280:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.CSNAAT=0;
     282:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     284:	f36f 0282 	bfc	r2, #2, #1
     288:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.BITS = 0; //Configure 8 bit package size
     28a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     28c:	f36f 1207 	bfc	r2, #4, #4
     290:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.SCBR =32; //set clock division to 32 (~375 khz)
     292:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     294:	2120      	movs	r1, #32
     296:	f361 220f 	bfi	r2, r1, #8, #8
     29a:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.DLYBS = 0; //other timing stuff
     29c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     29e:	f36f 4217 	bfc	r2, #16, #8
     2a2:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.DLYBCT = 0;
     2a4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     2a6:	f36f 621f 	bfc	r2, #24, #8
     2aa:	639a      	str	r2, [r3, #56]	; 0x38
	//or...
	//SPI->bf.CSR[2].reg = SPI_CSR_CPOL_0|SPI_CSR_NCPHA_1|SPI_CSR_CSAAT_1|SPI_CSR_BITS(0)|SPI_CSR_SCBR(1)|SPI_CSR_DLYBS(0)|SPI_CSR_DLYBCT(0);
	
	SPI->bf.CR.reg = SPI_CR_SPIEN; //open the gates for communication (enable SPI)
     2ac:	2201      	movs	r2, #1
     2ae:	601a      	str	r2, [r3, #0]
     2b0:	4770      	bx	lr
     2b2:	bf00      	nop
     2b4:	400e1000 	.word	0x400e1000
     2b8:	aa000028 	.word	0xaa000028

000002bc <SD_send_byte>:
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
	delay_us_2((uint64_t)10);
	return return_data;
}

uint8_t SD_send_byte(uint8_t byte_to_send){
     2bc:	b510      	push	{r4, lr}
     2be:	4604      	mov	r4, r0
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     2c0:	f44f 6200 	mov.w	r2, #2048	; 0x800
     2c4:	4b0f      	ldr	r3, [pc, #60]	; (304 <SD_send_byte+0x48>)
     2c6:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us_2((uint64_t)5);
     2ca:	2005      	movs	r0, #5
     2cc:	2100      	movs	r1, #0
     2ce:	4b0e      	ldr	r3, [pc, #56]	; (308 <SD_send_byte+0x4c>)
     2d0:	4798      	blx	r3
	//send first byte
	while(SPI->bf.SR.bit.TDRE == 0); //is transmit register empty? //while((SPI->reg.SPI_SR & SPI_SR_TDRE) == 0);
     2d2:	4a0e      	ldr	r2, [pc, #56]	; (30c <SD_send_byte+0x50>)
     2d4:	6913      	ldr	r3, [r2, #16]
     2d6:	f013 0f02 	tst.w	r3, #2
     2da:	d0fb      	beq.n	2d4 <SD_send_byte+0x18>
	SPI->bf.TDR.reg = byte_to_send; //load Transmit Data Register
     2dc:	4b0b      	ldr	r3, [pc, #44]	; (30c <SD_send_byte+0x50>)
     2de:	60dc      	str	r4, [r3, #12]
	//read data returned
	while (SPI->bf.SR.bit.RDRF == 0); //If byte is present in RDR, will read high
     2e0:	461a      	mov	r2, r3
     2e2:	6913      	ldr	r3, [r2, #16]
     2e4:	f013 0f01 	tst.w	r3, #1
     2e8:	d0fb      	beq.n	2e2 <SD_send_byte+0x26>
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     2ea:	f44f 6200 	mov.w	r2, #2048	; 0x800
     2ee:	4b05      	ldr	r3, [pc, #20]	; (304 <SD_send_byte+0x48>)
     2f0:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us_2((uint64_t)5);
     2f4:	2005      	movs	r0, #5
     2f6:	2100      	movs	r1, #0
     2f8:	4b03      	ldr	r3, [pc, #12]	; (308 <SD_send_byte+0x4c>)
     2fa:	4798      	blx	r3
	return (uint8_t)SPI->bf.RDR.reg; //to receive data (Receive Data reg)
     2fc:	4b03      	ldr	r3, [pc, #12]	; (30c <SD_send_byte+0x50>)
     2fe:	6898      	ldr	r0, [r3, #8]
}
     300:	b2c0      	uxtb	r0, r0
     302:	bd10      	pop	{r4, pc}
     304:	400e1000 	.word	0x400e1000
     308:	00000939 	.word	0x00000939
     30c:	40008000 	.word	0x40008000

00000310 <SD_transmit_32>:

uint32_t SD_transmit_32(uint32_t data_out)
{
     310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     314:	4606      	mov	r6, r0
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     316:	f44f 6200 	mov.w	r2, #2048	; 0x800
     31a:	4b0e      	ldr	r3, [pc, #56]	; (354 <SD_transmit_32+0x44>)
     31c:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us_2((uint64_t)10);
     320:	200a      	movs	r0, #10
     322:	2100      	movs	r1, #0
     324:	4b0c      	ldr	r3, [pc, #48]	; (358 <SD_transmit_32+0x48>)
     326:	4798      	blx	r3
		//uint32_t d_out_temp = data_out;
		//return_data |= (uint32_t)SD_send_byte((uint8_t)(d_out_temp >> (24-(8*i)))) << (24-(8*i));
	//}
	//return return_data;
	
	uint8_t byte0 = SD_send_byte(data_out >> (24-(8*0)));
     328:	0e30      	lsrs	r0, r6, #24
     32a:	4d0c      	ldr	r5, [pc, #48]	; (35c <SD_transmit_32+0x4c>)
     32c:	47a8      	blx	r5
     32e:	4680      	mov	r8, r0
	uint8_t byte1 = SD_send_byte(data_out >> (24-(8*1)));
     330:	f3c6 4007 	ubfx	r0, r6, #16, #8
     334:	47a8      	blx	r5
     336:	4604      	mov	r4, r0
	uint8_t byte2 = SD_send_byte(data_out >> (24-(8*2)));
     338:	f3c6 2007 	ubfx	r0, r6, #8, #8
     33c:	47a8      	blx	r5
     33e:	4607      	mov	r7, r0
	uint8_t byte3 = SD_send_byte(data_out >> (24-(8*3)));
     340:	b2f0      	uxtb	r0, r6
     342:	47a8      	blx	r5
	return byte0<<(24-(8*0))|byte1<<(24-(8*1))|byte2<<(24-(8*2))|byte3<<(24-(8*3));
     344:	0424      	lsls	r4, r4, #16
     346:	ea44 6408 	orr.w	r4, r4, r8, lsl #24
     34a:	4320      	orrs	r0, r4
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
	delay_us_2((uint64_t)10);
}
     34c:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
     350:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     354:	400e1000 	.word	0x400e1000
     358:	00000939 	.word	0x00000939
     35c:	000002bd 	.word	0x000002bd

00000360 <SD_send_command_cmd_0>:
uint8_t SD_send_command_cmd_0(void){
     360:	b570      	push	{r4, r5, r6, lr}
     362:	240a      	movs	r4, #10
	for (uint8_t i=0; i<10; i++){SD_send_byte(0xFF);} //send some dummy codes
     364:	26ff      	movs	r6, #255	; 0xff
     366:	4d15      	ldr	r5, [pc, #84]	; (3bc <SD_send_command_cmd_0+0x5c>)
     368:	4630      	mov	r0, r6
     36a:	47a8      	blx	r5
     36c:	1e63      	subs	r3, r4, #1
     36e:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
     372:	d1f9      	bne.n	368 <SD_send_command_cmd_0+0x8>
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     374:	f44f 6200 	mov.w	r2, #2048	; 0x800
     378:	4b11      	ldr	r3, [pc, #68]	; (3c0 <SD_send_command_cmd_0+0x60>)
     37a:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us_2((uint64_t)10);
     37e:	200a      	movs	r0, #10
     380:	2100      	movs	r1, #0
     382:	4b10      	ldr	r3, [pc, #64]	; (3c4 <SD_send_command_cmd_0+0x64>)
     384:	4798      	blx	r3
	return_byte = SD_send_byte(0b01000000);
     386:	2040      	movs	r0, #64	; 0x40
     388:	4c0c      	ldr	r4, [pc, #48]	; (3bc <SD_send_command_cmd_0+0x5c>)
     38a:	47a0      	blx	r4
	SD_transmit_32(0ul);
     38c:	2000      	movs	r0, #0
     38e:	4b0e      	ldr	r3, [pc, #56]	; (3c8 <SD_send_command_cmd_0+0x68>)
     390:	4798      	blx	r3
	return_byte = SD_send_byte(0x95); //CRC field
     392:	2095      	movs	r0, #149	; 0x95
     394:	47a0      	blx	r4
	while (return_byte == 0xFF) return_byte = SD_send_byte(0xFF); //send 0xFF while reading in data from SD.
     396:	26ff      	movs	r6, #255	; 0xff
     398:	4625      	mov	r5, r4
     39a:	4630      	mov	r0, r6
     39c:	47a8      	blx	r5
     39e:	4604      	mov	r4, r0
     3a0:	28ff      	cmp	r0, #255	; 0xff
     3a2:	d0fa      	beq.n	39a <SD_send_command_cmd_0+0x3a>
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     3a4:	f44f 6200 	mov.w	r2, #2048	; 0x800
     3a8:	4b05      	ldr	r3, [pc, #20]	; (3c0 <SD_send_command_cmd_0+0x60>)
     3aa:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us_2((uint64_t)10);
     3ae:	200a      	movs	r0, #10
     3b0:	2100      	movs	r1, #0
     3b2:	4b04      	ldr	r3, [pc, #16]	; (3c4 <SD_send_command_cmd_0+0x64>)
     3b4:	4798      	blx	r3
}
     3b6:	4620      	mov	r0, r4
     3b8:	bd70      	pop	{r4, r5, r6, pc}
     3ba:	bf00      	nop
     3bc:	000002bd 	.word	0x000002bd
     3c0:	400e1000 	.word	0x400e1000
     3c4:	00000939 	.word	0x00000939
     3c8:	00000311 	.word	0x00000311

000003cc <SD_send_command_R1>:
uint8_t SD_send_command_R1(uint8_t cmd, uint32_t argument, uint8_t crc){
     3cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     3d0:	b082      	sub	sp, #8
     3d2:	4680      	mov	r8, r0
     3d4:	460f      	mov	r7, r1
     3d6:	4616      	mov	r6, r2
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     3d8:	f44f 6200 	mov.w	r2, #2048	; 0x800
     3dc:	4b1a      	ldr	r3, [pc, #104]	; (448 <SD_send_command_R1+0x7c>)
     3de:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us_2((uint64_t)10);
     3e2:	200a      	movs	r0, #10
     3e4:	2100      	movs	r1, #0
     3e6:	4b19      	ldr	r3, [pc, #100]	; (44c <SD_send_command_R1+0x80>)
     3e8:	4798      	blx	r3
	while (SD_send_byte(0xFF) != 0xFF); //wait till DO goes high, indicating SD ready to receive command
     3ea:	25ff      	movs	r5, #255	; 0xff
     3ec:	4c18      	ldr	r4, [pc, #96]	; (450 <SD_send_command_R1+0x84>)
     3ee:	4628      	mov	r0, r5
     3f0:	47a0      	blx	r4
     3f2:	28ff      	cmp	r0, #255	; 0xff
     3f4:	d1fb      	bne.n	3ee <SD_send_command_R1+0x22>
	SD_send_byte(cmd | 0b01000000);
     3f6:	f048 0040 	orr.w	r0, r8, #64	; 0x40
     3fa:	4c15      	ldr	r4, [pc, #84]	; (450 <SD_send_command_R1+0x84>)
     3fc:	47a0      	blx	r4
	SD_transmit_32(argument);
     3fe:	4638      	mov	r0, r7
     400:	4b14      	ldr	r3, [pc, #80]	; (454 <SD_send_command_R1+0x88>)
     402:	4798      	blx	r3
	SD_send_byte(crc); //CRC field
     404:	4630      	mov	r0, r6
     406:	47a0      	blx	r4
	volatile uint8_t return_byte = 0xFF;
     408:	23ff      	movs	r3, #255	; 0xff
     40a:	f88d 3007 	strb.w	r3, [sp, #7]
	while (return_byte == 0xFF) return_byte = SD_send_byte(0xFF); //send 0xFF while reading in data from SD.
     40e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     412:	b2db      	uxtb	r3, r3
     414:	2bff      	cmp	r3, #255	; 0xff
     416:	d109      	bne.n	42c <SD_send_command_R1+0x60>
     418:	25ff      	movs	r5, #255	; 0xff
     41a:	4628      	mov	r0, r5
     41c:	47a0      	blx	r4
     41e:	f88d 0007 	strb.w	r0, [sp, #7]
     422:	f89d 3007 	ldrb.w	r3, [sp, #7]
     426:	b2db      	uxtb	r3, r3
     428:	2bff      	cmp	r3, #255	; 0xff
     42a:	d0f6      	beq.n	41a <SD_send_command_R1+0x4e>
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     42c:	f44f 6200 	mov.w	r2, #2048	; 0x800
     430:	4b05      	ldr	r3, [pc, #20]	; (448 <SD_send_command_R1+0x7c>)
     432:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us_2((uint64_t)10);
     436:	200a      	movs	r0, #10
     438:	2100      	movs	r1, #0
     43a:	4b04      	ldr	r3, [pc, #16]	; (44c <SD_send_command_R1+0x80>)
     43c:	4798      	blx	r3
	return return_byte;
     43e:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
     442:	b002      	add	sp, #8
     444:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     448:	400e1000 	.word	0x400e1000
     44c:	00000939 	.word	0x00000939
     450:	000002bd 	.word	0x000002bd
     454:	00000311 	.word	0x00000311

00000458 <SD_write_single_block>:
void SD_write_single_block(uint32_t address, uint8_t *data){
     458:	b570      	push	{r4, r5, r6, lr}
     45a:	460c      	mov	r4, r1
	uint8_t r1_response = SD_send_command_R1(24, address, 0xFF); //send cmd 24 with argument specifying address
     45c:	22ff      	movs	r2, #255	; 0xff
     45e:	4601      	mov	r1, r0
     460:	2018      	movs	r0, #24
     462:	4b13      	ldr	r3, [pc, #76]	; (4b0 <SD_write_single_block+0x58>)
     464:	4798      	blx	r3
	if (r1_response != 0){throw_error();};
     466:	b9f8      	cbnz	r0, 4a8 <SD_write_single_block+0x50>
	SD_send_byte(0xFF); //send dummy variable to give the card some time
     468:	20ff      	movs	r0, #255	; 0xff
     46a:	4d12      	ldr	r5, [pc, #72]	; (4b4 <SD_write_single_block+0x5c>)
     46c:	47a8      	blx	r5
	SD_send_byte(0b11111110); //send data token
     46e:	20fe      	movs	r0, #254	; 0xfe
     470:	47a8      	blx	r5
     472:	f504 7600 	add.w	r6, r4, #512	; 0x200
		SD_send_byte(*data); //send value at address
     476:	f814 0b01 	ldrb.w	r0, [r4], #1
     47a:	47a8      	blx	r5
	for (uint16_t i = 0; i < 512; i++) { //data
     47c:	42a6      	cmp	r6, r4
     47e:	d1fa      	bne.n	476 <SD_write_single_block+0x1e>
	SD_send_byte(0);// send  two byte CRC
     480:	2000      	movs	r0, #0
     482:	4c0c      	ldr	r4, [pc, #48]	; (4b4 <SD_write_single_block+0x5c>)
     484:	47a0      	blx	r4
	SD_send_byte(0xFF); // send CRC
     486:	20ff      	movs	r0, #255	; 0xff
     488:	47a0      	blx	r4
	uint8_t response = SD_send_byte(0xFF); //send dummy variable to get response
     48a:	20ff      	movs	r0, #255	; 0xff
     48c:	47a0      	blx	r4
     48e:	4606      	mov	r6, r0
	while(SD_send_byte(0xFF) != 0xFF); //wait for card to not be busy
     490:	25ff      	movs	r5, #255	; 0xff
     492:	4628      	mov	r0, r5
     494:	47a0      	blx	r4
     496:	28ff      	cmp	r0, #255	; 0xff
     498:	d1fb      	bne.n	492 <SD_write_single_block+0x3a>
	if ((response & 0b00001111) != 0b00000101){throw_error();};
     49a:	f006 060f 	and.w	r6, r6, #15
     49e:	2e05      	cmp	r6, #5
     4a0:	d001      	beq.n	4a6 <SD_write_single_block+0x4e>
     4a2:	4b05      	ldr	r3, [pc, #20]	; (4b8 <SD_write_single_block+0x60>)
     4a4:	4798      	blx	r3
     4a6:	bd70      	pop	{r4, r5, r6, pc}
	if (r1_response != 0){throw_error();};
     4a8:	4b03      	ldr	r3, [pc, #12]	; (4b8 <SD_write_single_block+0x60>)
     4aa:	4798      	blx	r3
     4ac:	e7dc      	b.n	468 <SD_write_single_block+0x10>
     4ae:	bf00      	nop
     4b0:	000003cd 	.word	0x000003cd
     4b4:	000002bd 	.word	0x000002bd
     4b8:	00000841 	.word	0x00000841

000004bc <SD_read_single_block>:
void SD_read_single_block(uint32_t address, uint8_t *data){	
     4bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     4be:	460c      	mov	r4, r1
	uint8_t r1_response = SD_send_command_R1(17, address, 0xFF); //read from address 
     4c0:	22ff      	movs	r2, #255	; 0xff
     4c2:	4601      	mov	r1, r0
     4c4:	2011      	movs	r0, #17
     4c6:	4b0e      	ldr	r3, [pc, #56]	; (500 <SD_read_single_block+0x44>)
     4c8:	4798      	blx	r3
	if (r1_response != 0){throw_error();};
     4ca:	b9a8      	cbnz	r0, 4f8 <SD_read_single_block+0x3c>
	while (SD_send_byte(0xFF)!=0b11111110){}; //wait for data token
     4cc:	26ff      	movs	r6, #255	; 0xff
     4ce:	4d0d      	ldr	r5, [pc, #52]	; (504 <SD_read_single_block+0x48>)
     4d0:	4630      	mov	r0, r6
     4d2:	47a8      	blx	r5
     4d4:	28fe      	cmp	r0, #254	; 0xfe
     4d6:	d1fb      	bne.n	4d0 <SD_read_single_block+0x14>
     4d8:	f504 7700 	add.w	r7, r4, #512	; 0x200
		*data = SD_send_byte(0xFF); //store value at variable address
     4dc:	26ff      	movs	r6, #255	; 0xff
     4de:	4d09      	ldr	r5, [pc, #36]	; (504 <SD_read_single_block+0x48>)
     4e0:	4630      	mov	r0, r6
     4e2:	47a8      	blx	r5
     4e4:	f804 0b01 	strb.w	r0, [r4], #1
	for(uint16_t i=0; i < 512; i++){
     4e8:	42a7      	cmp	r7, r4
     4ea:	d1f9      	bne.n	4e0 <SD_read_single_block+0x24>
	SD_send_byte(0xFF);//receive CRC
     4ec:	20ff      	movs	r0, #255	; 0xff
     4ee:	4c05      	ldr	r4, [pc, #20]	; (504 <SD_read_single_block+0x48>)
     4f0:	47a0      	blx	r4
	SD_send_byte(0xFF);
     4f2:	20ff      	movs	r0, #255	; 0xff
     4f4:	47a0      	blx	r4
     4f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (r1_response != 0){throw_error();};
     4f8:	4b03      	ldr	r3, [pc, #12]	; (508 <SD_read_single_block+0x4c>)
     4fa:	4798      	blx	r3
     4fc:	e7e6      	b.n	4cc <SD_read_single_block+0x10>
     4fe:	bf00      	nop
     500:	000003cd 	.word	0x000003cd
     504:	000002bd 	.word	0x000002bd
     508:	00000841 	.word	0x00000841

0000050c <SD_send_command_R3>:
uint32_t SD_send_command_R3(uint8_t cmd, uint32_t argument, uint8_t crc){
     50c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     510:	b082      	sub	sp, #8
     512:	4680      	mov	r8, r0
     514:	460f      	mov	r7, r1
     516:	4616      	mov	r6, r2
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     518:	f44f 6200 	mov.w	r2, #2048	; 0x800
     51c:	4b1d      	ldr	r3, [pc, #116]	; (594 <SD_send_command_R3+0x88>)
     51e:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us_2((uint64_t)10);
     522:	200a      	movs	r0, #10
     524:	2100      	movs	r1, #0
     526:	4b1c      	ldr	r3, [pc, #112]	; (598 <SD_send_command_R3+0x8c>)
     528:	4798      	blx	r3
	while (SD_send_byte(0xFF) != 0xFF); //wait till DO goes high, indicating SD read to receive command
     52a:	25ff      	movs	r5, #255	; 0xff
     52c:	4c1b      	ldr	r4, [pc, #108]	; (59c <SD_send_command_R3+0x90>)
     52e:	4628      	mov	r0, r5
     530:	47a0      	blx	r4
     532:	28ff      	cmp	r0, #255	; 0xff
     534:	d1fb      	bne.n	52e <SD_send_command_R3+0x22>
	SD_send_byte(cmd | 0b01000000);
     536:	f048 0040 	orr.w	r0, r8, #64	; 0x40
     53a:	4c18      	ldr	r4, [pc, #96]	; (59c <SD_send_command_R3+0x90>)
     53c:	47a0      	blx	r4
	SD_transmit_32(argument);
     53e:	4638      	mov	r0, r7
     540:	4b17      	ldr	r3, [pc, #92]	; (5a0 <SD_send_command_R3+0x94>)
     542:	4798      	blx	r3
	SD_send_byte(crc); //CRC field
     544:	4630      	mov	r0, r6
     546:	47a0      	blx	r4
	volatile uint8_t return_byte = 0xFF;
     548:	23ff      	movs	r3, #255	; 0xff
     54a:	f88d 3007 	strb.w	r3, [sp, #7]
	volatile uint32_t return_data = 0;
     54e:	2300      	movs	r3, #0
     550:	9300      	str	r3, [sp, #0]
	while (return_byte == 0xFF) return_byte = SD_send_byte(0xFF); //send 0xFF while reading in data from SD.
     552:	f89d 3007 	ldrb.w	r3, [sp, #7]
     556:	b2db      	uxtb	r3, r3
     558:	2bff      	cmp	r3, #255	; 0xff
     55a:	d109      	bne.n	570 <SD_send_command_R3+0x64>
     55c:	25ff      	movs	r5, #255	; 0xff
     55e:	4628      	mov	r0, r5
     560:	47a0      	blx	r4
     562:	f88d 0007 	strb.w	r0, [sp, #7]
     566:	f89d 3007 	ldrb.w	r3, [sp, #7]
     56a:	b2db      	uxtb	r3, r3
     56c:	2bff      	cmp	r3, #255	; 0xff
     56e:	d0f6      	beq.n	55e <SD_send_command_R3+0x52>
	return_data = SD_transmit_32(0xFFFFFFFF);
     570:	f04f 30ff 	mov.w	r0, #4294967295
     574:	4b0a      	ldr	r3, [pc, #40]	; (5a0 <SD_send_command_R3+0x94>)
     576:	4798      	blx	r3
     578:	9000      	str	r0, [sp, #0]
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     57a:	f44f 6200 	mov.w	r2, #2048	; 0x800
     57e:	4b05      	ldr	r3, [pc, #20]	; (594 <SD_send_command_R3+0x88>)
     580:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us_2((uint64_t)10);
     584:	200a      	movs	r0, #10
     586:	2100      	movs	r1, #0
     588:	4b03      	ldr	r3, [pc, #12]	; (598 <SD_send_command_R3+0x8c>)
     58a:	4798      	blx	r3
	return return_data;
     58c:	9800      	ldr	r0, [sp, #0]
}
     58e:	b002      	add	sp, #8
     590:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     594:	400e1000 	.word	0x400e1000
     598:	00000939 	.word	0x00000939
     59c:	000002bd 	.word	0x000002bd
     5a0:	00000311 	.word	0x00000311

000005a4 <SD_init>:
void SD_init(){
     5a4:	b570      	push	{r4, r5, r6, lr}
     5a6:	b082      	sub	sp, #8
	SPI->bf.CR.bit.SPIDIS = 1;
     5a8:	4b29      	ldr	r3, [pc, #164]	; (650 <SD_init+0xac>)
     5aa:	681a      	ldr	r2, [r3, #0]
     5ac:	f042 0202 	orr.w	r2, r2, #2
     5b0:	601a      	str	r2, [r3, #0]
	SPI->bf.CSR[2].bit.SCBR = 32; //set clock division to 32 (~375 khz)
     5b2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     5b4:	2120      	movs	r1, #32
     5b6:	f361 220f 	bfi	r2, r1, #8, #8
     5ba:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CR.bit.SPIEN = 1;
     5bc:	681a      	ldr	r2, [r3, #0]
     5be:	f042 0201 	orr.w	r2, r2, #1
     5c2:	601a      	str	r2, [r3, #0]
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     5c4:	f503 2359 	add.w	r3, r3, #888832	; 0xd9000
     5c8:	f44f 6200 	mov.w	r2, #2048	; 0x800
     5cc:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	GPIO->bf.Port[1].bf.ODERS.reg = (uint32_t)(1) << 11; //set GPIO output to output
     5d0:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244
	GPIO->bf.Port[1].bf.GPERS.reg = (uint32_t)(1) << 11; // enable GPIO
     5d4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
     5d8:	2414      	movs	r4, #20
		SD_send_byte(0xFF); // cant use this because it drives CS pin low
     5da:	26ff      	movs	r6, #255	; 0xff
     5dc:	4d1d      	ldr	r5, [pc, #116]	; (654 <SD_init+0xb0>)
     5de:	4630      	mov	r0, r6
     5e0:	47a8      	blx	r5
     5e2:	1e63      	subs	r3, r4, #1
	for (uint8_t i=0; i<20; i++)
     5e4:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
     5e8:	d1f9      	bne.n	5de <SD_init+0x3a>
	while(SD_send_command_cmd_0() != 0x01);
     5ea:	4c1b      	ldr	r4, [pc, #108]	; (658 <SD_init+0xb4>)
     5ec:	47a0      	blx	r4
     5ee:	2801      	cmp	r0, #1
     5f0:	d1fc      	bne.n	5ec <SD_init+0x48>
	uint32_t response = SD_send_command_R3(8, 0x000001AA, 0x87);
     5f2:	2287      	movs	r2, #135	; 0x87
     5f4:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
     5f8:	2008      	movs	r0, #8
     5fa:	4b18      	ldr	r3, [pc, #96]	; (65c <SD_init+0xb8>)
     5fc:	4798      	blx	r3
	if(response != 0x000001AA){throw_error();};
     5fe:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
     602:	d001      	beq.n	608 <SD_init+0x64>
     604:	4b16      	ldr	r3, [pc, #88]	; (660 <SD_init+0xbc>)
     606:	4798      	blx	r3
	return_byte = 0x01;
     608:	2301      	movs	r3, #1
     60a:	f88d 3007 	strb.w	r3, [sp, #7]
	while(return_byte != 0){
     60e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     612:	b18b      	cbz	r3, 638 <SD_init+0x94>
		SD_send_command_R1(55,0,0x01);
     614:	2501      	movs	r5, #1
     616:	2600      	movs	r6, #0
     618:	4c12      	ldr	r4, [pc, #72]	; (664 <SD_init+0xc0>)
     61a:	462a      	mov	r2, r5
     61c:	4631      	mov	r1, r6
     61e:	2037      	movs	r0, #55	; 0x37
     620:	47a0      	blx	r4
		return_byte = SD_send_command_R1(41,1<<30,0x01);
     622:	462a      	mov	r2, r5
     624:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
     628:	2029      	movs	r0, #41	; 0x29
     62a:	47a0      	blx	r4
     62c:	f88d 0007 	strb.w	r0, [sp, #7]
	while(return_byte != 0){
     630:	f89d 3007 	ldrb.w	r3, [sp, #7]
     634:	2b00      	cmp	r3, #0
     636:	d1f0      	bne.n	61a <SD_init+0x76>
	return_data = SD_send_command_R3(58, 0, 1);
     638:	2201      	movs	r2, #1
     63a:	2100      	movs	r1, #0
     63c:	203a      	movs	r0, #58	; 0x3a
     63e:	4b07      	ldr	r3, [pc, #28]	; (65c <SD_init+0xb8>)
     640:	4798      	blx	r3
     642:	9000      	str	r0, [sp, #0]
	delay_us_2((uint64_t)10); //for breakpoint
     644:	200a      	movs	r0, #10
     646:	2100      	movs	r1, #0
     648:	4b07      	ldr	r3, [pc, #28]	; (668 <SD_init+0xc4>)
     64a:	4798      	blx	r3
}
     64c:	b002      	add	sp, #8
     64e:	bd70      	pop	{r4, r5, r6, pc}
     650:	40008000 	.word	0x40008000
     654:	000002bd 	.word	0x000002bd
     658:	00000361 	.word	0x00000361
     65c:	0000050d 	.word	0x0000050d
     660:	00000841 	.word	0x00000841
     664:	000003cd 	.word	0x000003cd
     668:	00000939 	.word	0x00000939

0000066c <USART_write_char>:
	//USART_write_char('n');
}

void USART_write_char(uint8_t data){
	//Check that CSR.TXRDY is one before writing to THR
	while (!USART1->bf.CSR.USART.TXRDY); //set when THR is empty.
     66c:	4a05      	ldr	r2, [pc, #20]	; (684 <USART_write_char+0x18>)
     66e:	6953      	ldr	r3, [r2, #20]
     670:	f013 0f02 	tst.w	r3, #2
     674:	d0fb      	beq.n	66e <USART_write_char+0x2>
	USART1->bf.THR.bit.TXCHR = data;
     676:	4b03      	ldr	r3, [pc, #12]	; (684 <USART_write_char+0x18>)
     678:	69da      	ldr	r2, [r3, #28]
     67a:	f360 0208 	bfi	r2, r0, #0, #9
     67e:	61da      	str	r2, [r3, #28]
     680:	4770      	bx	lr
     682:	bf00      	nop
     684:	40028000 	.word	0x40028000

00000688 <USART_print>:
	for (uint32_t i = 0; i < size; i++) { //data
     688:	b151      	cbz	r1, 6a0 <USART_print+0x18>
void USART_print(uint8_t *data, uint32_t size){
     68a:	b570      	push	{r4, r5, r6, lr}
     68c:	4604      	mov	r4, r0
     68e:	460d      	mov	r5, r1
     690:	4405      	add	r5, r0
			USART_write_char(*data);
     692:	4e04      	ldr	r6, [pc, #16]	; (6a4 <USART_print+0x1c>)
     694:	f814 0b01 	ldrb.w	r0, [r4], #1
     698:	47b0      	blx	r6
	for (uint32_t i = 0; i < size; i++) { //data
     69a:	42a5      	cmp	r5, r4
     69c:	d1fa      	bne.n	694 <USART_print+0xc>
     69e:	bd70      	pop	{r4, r5, r6, pc}
     6a0:	4770      	bx	lr
     6a2:	bf00      	nop
     6a4:	0000066d 	.word	0x0000066d

000006a8 <USART_newline>:
void USART_newline(){
     6a8:	b510      	push	{r4, lr}
	USART_write_char(10); //line feed
     6aa:	200a      	movs	r0, #10
     6ac:	4c02      	ldr	r4, [pc, #8]	; (6b8 <USART_newline+0x10>)
     6ae:	47a0      	blx	r4
	USART_write_char(13); //carriage return
     6b0:	200d      	movs	r0, #13
     6b2:	47a0      	blx	r4
     6b4:	bd10      	pop	{r4, pc}
     6b6:	bf00      	nop
     6b8:	0000066d 	.word	0x0000066d

000006bc <set_baudrate>:
}

void set_baudrate(uint32_t rate){
     6bc:	b538      	push	{r3, r4, r5, lr}
     6be:	4604      	mov	r4, r0
		//		-over = oversampling mode (8 or 16)
		//      -cd = clock divider
		//      -see page 587
		uint8_t oversamp;
		//calculate CD
		USART1->bf.MR.USART.OVER = 1;
     6c0:	4b0e      	ldr	r3, [pc, #56]	; (6fc <set_baudrate+0x40>)
     6c2:	685a      	ldr	r2, [r3, #4]
     6c4:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
     6c8:	605a      	str	r2, [r3, #4]
		if (!USART1->bf.MR.USART.OVER){oversamp = 16;}
     6ca:	685b      	ldr	r3, [r3, #4]
     6cc:	f3c3 43c0 	ubfx	r3, r3, #19, #1
		else{oversamp = 8;}
     6d0:	2b00      	cmp	r3, #0
     6d2:	bf0c      	ite	eq
     6d4:	2510      	moveq	r5, #16
     6d6:	2508      	movne	r5, #8
		
		uint32_t clk = clock_speed();
     6d8:	4b09      	ldr	r3, [pc, #36]	; (700 <set_baudrate+0x44>)
     6da:	4798      	blx	r3
		uint16_t cd = clk/(rate*oversamp);
     6dc:	fb04 f405 	mul.w	r4, r4, r5
     6e0:	fbb0 f4f4 	udiv	r4, r0, r4
     6e4:	b2a4      	uxth	r4, r4
		if (cd == 0){throw_error();}
     6e6:	b12c      	cbz	r4, 6f4 <set_baudrate+0x38>
		USART1->bf.BRGR.bit.CD = cd;
     6e8:	4b04      	ldr	r3, [pc, #16]	; (6fc <set_baudrate+0x40>)
     6ea:	6a1a      	ldr	r2, [r3, #32]
     6ec:	f364 020f 	bfi	r2, r4, #0, #16
     6f0:	621a      	str	r2, [r3, #32]
     6f2:	bd38      	pop	{r3, r4, r5, pc}
		if (cd == 0){throw_error();}
     6f4:	4b03      	ldr	r3, [pc, #12]	; (704 <set_baudrate+0x48>)
     6f6:	4798      	blx	r3
     6f8:	e7f6      	b.n	6e8 <set_baudrate+0x2c>
     6fa:	bf00      	nop
     6fc:	40028000 	.word	0x40028000
     700:	00000879 	.word	0x00000879
     704:	00000841 	.word	0x00000841

00000708 <USART_init>:
void USART_init(TX, RX){
     708:	b508      	push	{r3, lr}
	GPIO->bf.Port[2].bf.GPERC.reg = TX | RX;
     70a:	4301      	orrs	r1, r0
     70c:	4b13      	ldr	r3, [pc, #76]	; (75c <USART_init+0x54>)
     70e:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
	GPIO->bf.Port[2].bf.PMR0C.reg = TX | RX;
     712:	f8c3 1418 	str.w	r1, [r3, #1048]	; 0x418
	GPIO->bf.Port[2].bf.PMR1C.reg = TX | RX;
     716:	f8c3 1428 	str.w	r1, [r3, #1064]	; 0x428
	GPIO->bf.Port[2].bf.PMR2C.reg = TX | RX;
     71a:	f8c3 1438 	str.w	r1, [r3, #1080]	; 0x438
	PM->bf.UNLOCK.reg = ADDR_UNLOCK(PM_PBAMASK_OFFSET);	// Unlock PBA Register
     71e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     722:	4a0f      	ldr	r2, [pc, #60]	; (760 <USART_init+0x58>)
     724:	659a      	str	r2, [r3, #88]	; 0x58
	PM->bf.PBAMASK.reg |= (uint32_t)(0x1ul << PM_PBAMASK_USART1_Pos);	// Enable clock for USART
     726:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     728:	f442 7200 	orr.w	r2, r2, #512	; 0x200
     72c:	629a      	str	r2, [r3, #40]	; 0x28
	set_baudrate(115000);
     72e:	480d      	ldr	r0, [pc, #52]	; (764 <USART_init+0x5c>)
     730:	4b0d      	ldr	r3, [pc, #52]	; (768 <USART_init+0x60>)
     732:	4798      	blx	r3
	USART1->bf.MR.USART.CHRL = 0b11; //8bit
     734:	4b0d      	ldr	r3, [pc, #52]	; (76c <USART_init+0x64>)
     736:	685a      	ldr	r2, [r3, #4]
     738:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
     73c:	605a      	str	r2, [r3, #4]
	USART1->bf.CR.USART.RSTTX = 1; //reset transmitter
     73e:	681a      	ldr	r2, [r3, #0]
     740:	f042 0208 	orr.w	r2, r2, #8
     744:	601a      	str	r2, [r3, #0]
	USART1->bf.CR.USART.TXEN = 1;
     746:	681a      	ldr	r2, [r3, #0]
     748:	f042 0240 	orr.w	r2, r2, #64	; 0x40
     74c:	601a      	str	r2, [r3, #0]
	while (!USART1->bf.CSR.USART.TXRDY);
     74e:	461a      	mov	r2, r3
     750:	6953      	ldr	r3, [r2, #20]
     752:	f013 0f02 	tst.w	r3, #2
     756:	d0fb      	beq.n	750 <USART_init+0x48>
}
     758:	bd08      	pop	{r3, pc}
     75a:	bf00      	nop
     75c:	400e1000 	.word	0x400e1000
     760:	aa000028 	.word	0xaa000028
     764:	0001c138 	.word	0x0001c138
     768:	000006bd 	.word	0x000006bd
     76c:	40028000 	.word	0x40028000

00000770 <USART_printf>:
}


//adapted code to mimic printf function on serial terminal
void  USART_printf (char * str, ...){
     770:	b40f      	push	{r0, r1, r2, r3}
     772:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     776:	b0a1      	sub	sp, #132	; 0x84
     778:	ac28      	add	r4, sp, #160	; 0xa0
     77a:	f854 6b04 	ldr.w	r6, [r4], #4
	va_list arg_list;
	int i = 0, j=0;
	char buff[100]={0}, tmp[20];
     77e:	2264      	movs	r2, #100	; 0x64
     780:	2100      	movs	r1, #0
     782:	a806      	add	r0, sp, #24
     784:	4b29      	ldr	r3, [pc, #164]	; (82c <USART_printf+0xbc>)
     786:	4798      	blx	r3
	va_start( arg_list, str );
     788:	941f      	str	r4, [sp, #124]	; 0x7c

	while (str && str[i]){
     78a:	2e00      	cmp	r6, #0
     78c:	d044      	beq.n	818 <USART_printf+0xa8>
     78e:	7833      	ldrb	r3, [r6, #0]
     790:	2b00      	cmp	r3, #0
     792:	d041      	beq.n	818 <USART_printf+0xa8>
     794:	2500      	movs	r5, #0
     796:	462c      	mov	r4, r5
					buff[j] = (char)va_arg( arg_list, int );
					j++;
					break;
				}
				case 'd': {
					itoa(va_arg( arg_list, int ), tmp, 10);
     798:	f8df 909c 	ldr.w	r9, [pc, #156]	; 838 <USART_printf+0xc8>
					strcpy(&buff[j], tmp);
     79c:	f8df 809c 	ldr.w	r8, [pc, #156]	; 83c <USART_printf+0xcc>
					j += strlen(tmp);
     7a0:	4f23      	ldr	r7, [pc, #140]	; (830 <USART_printf+0xc0>)
     7a2:	e025      	b.n	7f0 <USART_printf+0x80>
					itoa(va_arg( arg_list, int ), tmp, 10);
     7a4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     7a6:	1d1a      	adds	r2, r3, #4
     7a8:	921f      	str	r2, [sp, #124]	; 0x7c
     7aa:	220a      	movs	r2, #10
     7ac:	a901      	add	r1, sp, #4
     7ae:	6818      	ldr	r0, [r3, #0]
     7b0:	47c8      	blx	r9
					strcpy(&buff[j], tmp);
     7b2:	a901      	add	r1, sp, #4
     7b4:	ab06      	add	r3, sp, #24
     7b6:	1958      	adds	r0, r3, r5
     7b8:	47c0      	blx	r8
					j += strlen(tmp);
     7ba:	a801      	add	r0, sp, #4
     7bc:	47b8      	blx	r7
     7be:	4405      	add	r5, r0
					break;
     7c0:	e013      	b.n	7ea <USART_printf+0x7a>
				}
				case 'x': {
					itoa(va_arg( arg_list, int ), tmp, 16);
     7c2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     7c4:	1d1a      	adds	r2, r3, #4
     7c6:	921f      	str	r2, [sp, #124]	; 0x7c
     7c8:	2210      	movs	r2, #16
     7ca:	a901      	add	r1, sp, #4
     7cc:	6818      	ldr	r0, [r3, #0]
     7ce:	47c8      	blx	r9
					strcpy(&buff[j], tmp);
     7d0:	a901      	add	r1, sp, #4
     7d2:	ab06      	add	r3, sp, #24
     7d4:	1958      	adds	r0, r3, r5
     7d6:	47c0      	blx	r8
					j += strlen(tmp);
     7d8:	a801      	add	r0, sp, #4
     7da:	47b8      	blx	r7
     7dc:	4405      	add	r5, r0
					break;
     7de:	e004      	b.n	7ea <USART_printf+0x7a>
				}
			}
			} else {
			buff[j] =str[i];
     7e0:	aa20      	add	r2, sp, #128	; 0x80
     7e2:	442a      	add	r2, r5
     7e4:	f802 3c68 	strb.w	r3, [r2, #-104]
			j++;
     7e8:	3501      	adds	r5, #1
		}
		i++;
     7ea:	3401      	adds	r4, #1
	while (str && str[i]){
     7ec:	5d33      	ldrb	r3, [r6, r4]
     7ee:	b19b      	cbz	r3, 818 <USART_printf+0xa8>
		if(str[i] == '%'){
     7f0:	2b25      	cmp	r3, #37	; 0x25
     7f2:	d1f5      	bne.n	7e0 <USART_printf+0x70>
			i++;
     7f4:	3401      	adds	r4, #1
			switch (str[i]) {
     7f6:	5d33      	ldrb	r3, [r6, r4]
     7f8:	2b64      	cmp	r3, #100	; 0x64
     7fa:	d0d3      	beq.n	7a4 <USART_printf+0x34>
     7fc:	2b78      	cmp	r3, #120	; 0x78
     7fe:	d0e0      	beq.n	7c2 <USART_printf+0x52>
     800:	2b63      	cmp	r3, #99	; 0x63
     802:	d1f2      	bne.n	7ea <USART_printf+0x7a>
					buff[j] = (char)va_arg( arg_list, int );
     804:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     806:	1d1a      	adds	r2, r3, #4
     808:	921f      	str	r2, [sp, #124]	; 0x7c
     80a:	aa20      	add	r2, sp, #128	; 0x80
     80c:	442a      	add	r2, r5
     80e:	681b      	ldr	r3, [r3, #0]
     810:	f802 3c68 	strb.w	r3, [r2, #-104]
					j++;
     814:	3501      	adds	r5, #1
					break;
     816:	e7e8      	b.n	7ea <USART_printf+0x7a>
	}
	//fwrite(buff, j, 1, stdout);
	USART_print(buff, sizeof(buff));
     818:	2164      	movs	r1, #100	; 0x64
     81a:	a806      	add	r0, sp, #24
     81c:	4b05      	ldr	r3, [pc, #20]	; (834 <USART_printf+0xc4>)
     81e:	4798      	blx	r3
	va_end(arg_list);
}
     820:	b021      	add	sp, #132	; 0x84
     822:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
     826:	b004      	add	sp, #16
     828:	4770      	bx	lr
     82a:	bf00      	nop
     82c:	00003305 	.word	0x00003305
     830:	00003481 	.word	0x00003481
     834:	00000689 	.word	0x00000689
     838:	000031cd 	.word	0x000031cd
     83c:	000033a1 	.word	0x000033a1

00000840 <throw_error>:

void Assert(bool expr){
		if (!(expr)) throw_error();
	}

void throw_error(){
     840:	b580      	push	{r7, lr}
	//blinks to indicate and issue
	//enable GPIO PC7
	GPIO->bf.Port[2].bf.GPERS.reg = 0x00000080;
     842:	4b0b      	ldr	r3, [pc, #44]	; (870 <throw_error+0x30>)
     844:	2280      	movs	r2, #128	; 0x80
     846:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
	//set PC7 as output
	GPIO->bf.Port[2].bf.ODERS.reg = GPIO_ODER_P7;
     84a:	f8c3 2444 	str.w	r2, [r3, #1092]	; 0x444
	while (1)
	{
		//turn on
		GPIO->bf.Port[2].bf.OVRC.reg = GPIO_OVRC_P7;
     84e:	461d      	mov	r5, r3
     850:	4616      	mov	r6, r2
     852:	4617      	mov	r7, r2
     854:	f8c5 7458 	str.w	r7, [r5, #1112]	; 0x458
		delay_ms_2(1000);
     858:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     85c:	2100      	movs	r1, #0
     85e:	4c05      	ldr	r4, [pc, #20]	; (874 <throw_error+0x34>)
     860:	47a0      	blx	r4
		//delay_2(5000);
		//turn off
		GPIO->bf.Port[2].bf.OVRS.reg = GPIO_OVRS_P7;
     862:	f8c5 6454 	str.w	r6, [r5, #1108]	; 0x454
		delay_ms_2(1000);
     866:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     86a:	2100      	movs	r1, #0
     86c:	47a0      	blx	r4
     86e:	e7f1      	b.n	854 <throw_error+0x14>
     870:	400e1000 	.word	0x400e1000
     874:	000008fd 	.word	0x000008fd

00000878 <clock_speed>:
uint32_t clock_speed(){
     878:	b508      	push	{r3, lr}
	switch((uint8_t)PM->bf.MCCTRL.bit.MCSEL) {
     87a:	4b17      	ldr	r3, [pc, #92]	; (8d8 <clock_speed+0x60>)
     87c:	681b      	ldr	r3, [r3, #0]
     87e:	f003 0307 	and.w	r3, r3, #7
     882:	2b06      	cmp	r3, #6
     884:	d81f      	bhi.n	8c6 <clock_speed+0x4e>
     886:	e8df f003 	tbb	[pc, r3]
     88a:	0620      	.short	0x0620
     88c:	08041e1e 	.word	0x08041e1e
     890:	22          	.byte	0x22
     891:	00          	.byte	0x00
			return(80000000);
     892:	4812      	ldr	r0, [pc, #72]	; (8dc <clock_speed+0x64>)
     894:	bd08      	pop	{r3, pc}
			throw_error();
     896:	4b12      	ldr	r3, [pc, #72]	; (8e0 <clock_speed+0x68>)
     898:	4798      	blx	r3
			if (SCIF->bf.RCFASTCFG.bit.EN == 1){
     89a:	4b12      	ldr	r3, [pc, #72]	; (8e4 <clock_speed+0x6c>)
     89c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     89e:	f013 0f01 	tst.w	r3, #1
     8a2:	d00e      	beq.n	8c2 <clock_speed+0x4a>
				switch((uint8_t)SCIF->bf.RCFASTCFG.bit.FRANGE){
     8a4:	4b0f      	ldr	r3, [pc, #60]	; (8e4 <clock_speed+0x6c>)
     8a6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     8a8:	f3c3 2301 	ubfx	r3, r3, #8, #2
     8ac:	2b01      	cmp	r3, #1
     8ae:	d006      	beq.n	8be <clock_speed+0x46>
     8b0:	b17b      	cbz	r3, 8d2 <clock_speed+0x5a>
			return(1000000);
     8b2:	4a0d      	ldr	r2, [pc, #52]	; (8e8 <clock_speed+0x70>)
     8b4:	480d      	ldr	r0, [pc, #52]	; (8ec <clock_speed+0x74>)
     8b6:	2b02      	cmp	r3, #2
     8b8:	bf18      	it	ne
     8ba:	4610      	movne	r0, r2
     8bc:	bd08      	pop	{r3, pc}
					case 1 : return(8000000);
     8be:	480c      	ldr	r0, [pc, #48]	; (8f0 <clock_speed+0x78>)
     8c0:	bd08      	pop	{r3, pc}
				throw_error();
     8c2:	4b07      	ldr	r3, [pc, #28]	; (8e0 <clock_speed+0x68>)
     8c4:	4798      	blx	r3
			throw_error();
     8c6:	4b06      	ldr	r3, [pc, #24]	; (8e0 <clock_speed+0x68>)
     8c8:	4798      	blx	r3
			return(115000);
     8ca:	480a      	ldr	r0, [pc, #40]	; (8f4 <clock_speed+0x7c>)
     8cc:	bd08      	pop	{r3, pc}
			return(1000000);
     8ce:	4806      	ldr	r0, [pc, #24]	; (8e8 <clock_speed+0x70>)
     8d0:	bd08      	pop	{r3, pc}
					case 0 : return(4000000);
     8d2:	4809      	ldr	r0, [pc, #36]	; (8f8 <clock_speed+0x80>)
}
     8d4:	bd08      	pop	{r3, pc}
     8d6:	bf00      	nop
     8d8:	400e0000 	.word	0x400e0000
     8dc:	04c4b400 	.word	0x04c4b400
     8e0:	00000841 	.word	0x00000841
     8e4:	400e0800 	.word	0x400e0800
     8e8:	000f4240 	.word	0x000f4240
     8ec:	00b71b00 	.word	0x00b71b00
     8f0:	007a1200 	.word	0x007a1200
     8f4:	0001c138 	.word	0x0001c138
     8f8:	003d0900 	.word	0x003d0900

000008fc <delay_ms_2>:
void delay_ms_2(uint64_t ms){
     8fc:	b570      	push	{r4, r5, r6, lr}
     8fe:	4604      	mov	r4, r0
     900:	460e      	mov	r6, r1
	delay_cycles(((uint64_t)(ms) * clock_speed() + (uint64_t)(14e3 - 1ul)) / (uint64_t)14e3);
     902:	4b09      	ldr	r3, [pc, #36]	; (928 <delay_ms_2+0x2c>)
     904:	4798      	blx	r3
     906:	fba0 4504 	umull	r4, r5, r0, r4
     90a:	fb00 5506 	mla	r5, r0, r6, r5
     90e:	f243 62b0 	movw	r2, #14000	; 0x36b0
     912:	2300      	movs	r3, #0
     914:	f243 60af 	movw	r0, #13999	; 0x36af
     918:	2100      	movs	r1, #0
     91a:	1900      	adds	r0, r0, r4
     91c:	4169      	adcs	r1, r5
     91e:	4c03      	ldr	r4, [pc, #12]	; (92c <delay_ms_2+0x30>)
     920:	47a0      	blx	r4
     922:	4b03      	ldr	r3, [pc, #12]	; (930 <delay_ms_2+0x34>)
     924:	4798      	blx	r3
     926:	bd70      	pop	{r4, r5, r6, pc}
     928:	00000879 	.word	0x00000879
     92c:	00002e3d 	.word	0x00002e3d
     930:	20000001 	.word	0x20000001
     934:	00000000 	.word	0x00000000

00000938 <delay_us_2>:
void delay_us_2(uint64_t us){
     938:	b570      	push	{r4, r5, r6, lr}
     93a:	4604      	mov	r4, r0
     93c:	460e      	mov	r6, r1
	delay_cycles(((uint64_t)(us) * clock_speed() + (uint64_t)(14e6 - 1ul)) / (uint64_t)14e6);
     93e:	4b0c      	ldr	r3, [pc, #48]	; (970 <delay_us_2+0x38>)
     940:	4798      	blx	r3
     942:	fba0 4504 	umull	r4, r5, r0, r4
     946:	fb00 5506 	mla	r5, r0, r6, r5
     94a:	4a0a      	ldr	r2, [pc, #40]	; (974 <delay_us_2+0x3c>)
     94c:	2300      	movs	r3, #0
     94e:	a106      	add	r1, pc, #24	; (adr r1, 968 <delay_us_2+0x30>)
     950:	e9d1 0100 	ldrd	r0, r1, [r1]
     954:	1900      	adds	r0, r0, r4
     956:	4169      	adcs	r1, r5
     958:	4c07      	ldr	r4, [pc, #28]	; (978 <delay_us_2+0x40>)
     95a:	47a0      	blx	r4
     95c:	4b07      	ldr	r3, [pc, #28]	; (97c <delay_us_2+0x44>)
     95e:	4798      	blx	r3
     960:	bd70      	pop	{r4, r5, r6, pc}
     962:	bf00      	nop
     964:	f3af 8000 	nop.w
     968:	00d59f7f 	.word	0x00d59f7f
     96c:	00000000 	.word	0x00000000
     970:	00000879 	.word	0x00000879
     974:	00d59f80 	.word	0x00d59f80
     978:	00002e3d 	.word	0x00002e3d
     97c:	20000001 	.word	0x20000001

00000980 <RCFAST_init>:
	}
}

void RCFAST_init(){
	//Enable SCIF, which controls oscillators/clocks.
	SCIF->bf.UNLOCK.reg = 0xAA000000 | SCIF_RCFASTCFG_OFFSET; //unlock RCFASTCFG
     980:	4b09      	ldr	r3, [pc, #36]	; (9a8 <RCFAST_init+0x28>)
     982:	4a0a      	ldr	r2, [pc, #40]	; (9ac <RCFAST_init+0x2c>)
     984:	619a      	str	r2, [r3, #24]
	SCIF->bf.RCFASTCFG.bit.EN = 1; // Enable RCFAST
     986:	6c9a      	ldr	r2, [r3, #72]	; 0x48
     988:	f042 0201 	orr.w	r2, r2, #1
     98c:	649a      	str	r2, [r3, #72]	; 0x48
	while (SCIF->bf.RCFASTCFG.bit.EN != 1); // wait for it to turn on
     98e:	461a      	mov	r2, r3
     990:	6c93      	ldr	r3, [r2, #72]	; 0x48
     992:	f013 0f01 	tst.w	r3, #1
     996:	d0fb      	beq.n	990 <RCFAST_init+0x10>
	//set RCFAST as system clock
	PM->bf.UNLOCK.reg =  0xAA000000 | PM_MCCTRL_OFFSET;
     998:	4b05      	ldr	r3, [pc, #20]	; (9b0 <RCFAST_init+0x30>)
     99a:	f04f 422a 	mov.w	r2, #2852126720	; 0xaa000000
     99e:	659a      	str	r2, [r3, #88]	; 0x58
	PM->bf.MCCTRL.reg = 0x00000005;
     9a0:	2205      	movs	r2, #5
     9a2:	601a      	str	r2, [r3, #0]
     9a4:	4770      	bx	lr
     9a6:	bf00      	nop
     9a8:	400e0800 	.word	0x400e0800
     9ac:	aa000048 	.word	0xaa000048
     9b0:	400e0000 	.word	0x400e0000

000009b4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     9b4:	e7fe      	b.n	9b4 <Dummy_Handler>
	...

000009b8 <Reset_Handler>:
{
     9b8:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
     9ba:	4b17      	ldr	r3, [pc, #92]	; (a18 <Reset_Handler+0x60>)
     9bc:	4a17      	ldr	r2, [pc, #92]	; (a1c <Reset_Handler+0x64>)
     9be:	429a      	cmp	r2, r3
     9c0:	d010      	beq.n	9e4 <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
     9c2:	4b17      	ldr	r3, [pc, #92]	; (a20 <Reset_Handler+0x68>)
     9c4:	4a14      	ldr	r2, [pc, #80]	; (a18 <Reset_Handler+0x60>)
     9c6:	429a      	cmp	r2, r3
     9c8:	d20c      	bcs.n	9e4 <Reset_Handler+0x2c>
     9ca:	3b01      	subs	r3, #1
     9cc:	1a9b      	subs	r3, r3, r2
     9ce:	f023 0303 	bic.w	r3, r3, #3
     9d2:	3304      	adds	r3, #4
     9d4:	4413      	add	r3, r2
     9d6:	4911      	ldr	r1, [pc, #68]	; (a1c <Reset_Handler+0x64>)
                        *pDest++ = *pSrc++;
     9d8:	f851 0b04 	ldr.w	r0, [r1], #4
     9dc:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
     9e0:	429a      	cmp	r2, r3
     9e2:	d1f9      	bne.n	9d8 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
     9e4:	4b0f      	ldr	r3, [pc, #60]	; (a24 <Reset_Handler+0x6c>)
     9e6:	4a10      	ldr	r2, [pc, #64]	; (a28 <Reset_Handler+0x70>)
     9e8:	429a      	cmp	r2, r3
     9ea:	d20a      	bcs.n	a02 <Reset_Handler+0x4a>
     9ec:	3b01      	subs	r3, #1
     9ee:	1a9b      	subs	r3, r3, r2
     9f0:	f023 0303 	bic.w	r3, r3, #3
     9f4:	3304      	adds	r3, #4
     9f6:	4413      	add	r3, r2
                *pDest++ = 0;
     9f8:	2100      	movs	r1, #0
     9fa:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
     9fe:	4293      	cmp	r3, r2
     a00:	d1fb      	bne.n	9fa <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     a02:	4a0a      	ldr	r2, [pc, #40]	; (a2c <Reset_Handler+0x74>)
     a04:	4b0a      	ldr	r3, [pc, #40]	; (a30 <Reset_Handler+0x78>)
     a06:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
     a0a:	6093      	str	r3, [r2, #8]
        __libc_init_array();
     a0c:	4b09      	ldr	r3, [pc, #36]	; (a34 <Reset_Handler+0x7c>)
     a0e:	4798      	blx	r3
        main();
     a10:	4b09      	ldr	r3, [pc, #36]	; (a38 <Reset_Handler+0x80>)
     a12:	4798      	blx	r3
     a14:	e7fe      	b.n	a14 <Reset_Handler+0x5c>
     a16:	bf00      	nop
     a18:	20000000 	.word	0x20000000
     a1c:	00003948 	.word	0x00003948
     a20:	20000444 	.word	0x20000444
     a24:	20001188 	.word	0x20001188
     a28:	20000444 	.word	0x20000444
     a2c:	e000ed00 	.word	0xe000ed00
     a30:	00000000 	.word	0x00000000
     a34:	0000314d 	.word	0x0000314d
     a38:	00002d29 	.word	0x00002d29

00000a3c <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
	// Keep the default device state after reset
	SystemCoreClock = __SYSTEM_CLOCK;
     a3c:	4a01      	ldr	r2, [pc, #4]	; (a44 <SystemInit+0x8>)
     a3e:	4b02      	ldr	r3, [pc, #8]	; (a48 <SystemInit+0xc>)
     a40:	601a      	str	r2, [r3, #0]
     a42:	4770      	bx	lr
     a44:	0001c138 	.word	0x0001c138
     a48:	2000000c 	.word	0x2000000c

00000a4c <fatfs_init>:

//-----------------------------------------------------------------------------
// fatfs_init: Load FAT Parameters
//-----------------------------------------------------------------------------
int fatfs_init(struct fatfs *fs)
{
     a4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     a50:	4604      	mov	r4, r0
    uint32 total_sectors;
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
     a52:	f04f 33ff 	mov.w	r3, #4294967295
     a56:	f8c0 3240 	str.w	r3, [r0, #576]	; 0x240
    fs->currentsector.dirty = 0;
     a5a:	2300      	movs	r3, #0
     a5c:	f8c0 3244 	str.w	r3, [r0, #580]	; 0x244

    fs->next_free_cluster = 0; // Invalid
     a60:	6243      	str	r3, [r0, #36]	; 0x24

    fatfs_fat_init(fs);
     a62:	4b98      	ldr	r3, [pc, #608]	; (cc4 <fatfs_init+0x278>)
     a64:	4798      	blx	r3

    // Make sure we have a read function (write function is optional)
    if (!fs->disk_io.read_media)
     a66:	6b23      	ldr	r3, [r4, #48]	; 0x30
     a68:	2b00      	cmp	r3, #0
     a6a:	f000 8107 	beq.w	c7c <fatfs_init+0x230>

    // MBR: Sector 0 on the disk
    // NOTE: Some removeable media does not have this.

    // Load MBR (LBA 0) into the 512 byte buffer
    if (!fs->disk_io.read_media(0, fs->currentsector.sector, 1))
     a6e:	f104 0540 	add.w	r5, r4, #64	; 0x40
     a72:	2201      	movs	r2, #1
     a74:	4629      	mov	r1, r5
     a76:	2000      	movs	r0, #0
     a78:	4798      	blx	r3
     a7a:	2800      	cmp	r0, #0
     a7c:	f000 8102 	beq.w	c84 <fatfs_init+0x238>
        return FAT_INIT_MEDIA_ACCESS_ERROR;

    // Make Sure 0x55 and 0xAA are at end of sector
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
     a80:	f8b4 223e 	ldrh.w	r2, [r4, #574]	; 0x23e
     a84:	f64a 2355 	movw	r3, #43605	; 0xaa55
     a88:	429a      	cmp	r2, r3
     a8a:	f040 80ff 	bne.w	c8c <fatfs_init+0x240>
        return FAT_INIT_INVALID_SIGNATURE;

    // Now check again using the access function to prove endian conversion function
    if (GET_16BIT_WORD(fs->currentsector.sector, SIGNATURE_POSITION) != SIGNATURE_VALUE)
     a8e:	f894 223f 	ldrb.w	r2, [r4, #575]	; 0x23f
     a92:	f894 323e 	ldrb.w	r3, [r4, #574]	; 0x23e
     a96:	eb03 2302 	add.w	r3, r3, r2, lsl #8
     a9a:	f64a 2255 	movw	r2, #43605	; 0xaa55
     a9e:	4293      	cmp	r3, r2
     aa0:	f040 80f8 	bne.w	c94 <fatfs_init+0x248>
    // Verify packed structures
    if (sizeof(struct fat_dir_entry) != FAT_DIR_ENTRY_SIZE)
        return FAT_INIT_STRUCT_PACKING;

    // Check the partition type code
    switch(fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION])
     aa4:	f894 3202 	ldrb.w	r3, [r4, #514]	; 0x202
     aa8:	2b0f      	cmp	r3, #15
     aaa:	d809      	bhi.n	ac0 <fatfs_init+0x74>
     aac:	e8df f003 	tbb	[pc, r3]
     ab0:	080808be 	.word	0x080808be
     ab4:	080d0d08 	.word	0x080d0d08
     ab8:	0d080808 	.word	0x0d080808
     abc:	0d0d080d 	.word	0x0d0d080d
        case 0x06:
        case 0x0C:
        case 0x0E:
        case 0x0F:
        case 0x05:
            valid_partition = 1;
     ac0:	2b06      	cmp	r3, #6
     ac2:	bf8c      	ite	hi
     ac4:	2300      	movhi	r3, #0
     ac6:	2301      	movls	r3, #1
     ac8:	e000      	b.n	acc <fatfs_init+0x80>
     aca:	2301      	movs	r3, #1
                valid_partition = 1;
        break;
    }

    // Read LBA Begin for the file system
    if (valid_partition)
     acc:	2b00      	cmp	r3, #0
     ace:	f000 80ad 	beq.w	c2c <fatfs_init+0x1e0>
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
     ad2:	f894 2209 	ldrb.w	r2, [r4, #521]	; 0x209
     ad6:	f894 3208 	ldrb.w	r3, [r4, #520]	; 0x208
     ada:	041b      	lsls	r3, r3, #16
     adc:	eb03 6302 	add.w	r3, r3, r2, lsl #24
     ae0:	f894 2206 	ldrb.w	r2, [r4, #518]	; 0x206
     ae4:	4413      	add	r3, r2
     ae6:	f894 2207 	ldrb.w	r2, [r4, #519]	; 0x207
     aea:	eb03 2302 	add.w	r3, r3, r2, lsl #8
     aee:	61e3      	str	r3, [r4, #28]
    else
        fs->lba_begin = 0;

    // Load Volume 1 table into sector buffer
    // (We may already have this in the buffer if MBR less drive!)
    if (!fs->disk_io.read_media(fs->lba_begin, fs->currentsector.sector, 1))
     af0:	6b23      	ldr	r3, [r4, #48]	; 0x30
     af2:	2201      	movs	r2, #1
     af4:	4629      	mov	r1, r5
     af6:	69e0      	ldr	r0, [r4, #28]
     af8:	4798      	blx	r3
     afa:	2800      	cmp	r0, #0
     afc:	f000 80ce 	beq.w	c9c <fatfs_init+0x250>
        return FAT_INIT_MEDIA_ACCESS_ERROR;

    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE)
     b00:	f894 204c 	ldrb.w	r2, [r4, #76]	; 0x4c
     b04:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
     b08:	eb03 2302 	add.w	r3, r3, r2, lsl #8
     b0c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     b10:	f040 80c8 	bne.w	ca4 <fatfs_init+0x258>
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
     b14:	f894 004d 	ldrb.w	r0, [r4, #77]	; 0x4d
     b18:	7020      	strb	r0, [r4, #0]
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
     b1a:	f894 604f 	ldrb.w	r6, [r4, #79]	; 0x4f
     b1e:	f894 104e 	ldrb.w	r1, [r4, #78]	; 0x4e
     b22:	eb01 2c06 	add.w	ip, r1, r6, lsl #8
     b26:	fa1f fc8c 	uxth.w	ip, ip
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
     b2a:	f894 5050 	ldrb.w	r5, [r4, #80]	; 0x50
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
     b2e:	f894 8052 	ldrb.w	r8, [r4, #82]	; 0x52
     b32:	f894 2051 	ldrb.w	r2, [r4, #81]	; 0x51
     b36:	eb02 2e08 	add.w	lr, r2, r8, lsl #8
     b3a:	fa1f fe8e 	uxth.w	lr, lr
     b3e:	f8a4 e028 	strh.w	lr, [r4, #40]	; 0x28

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
     b42:	f894 7057 	ldrb.w	r7, [r4, #87]	; 0x57
     b46:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
     b4a:	eb13 2307 	adds.w	r3, r3, r7, lsl #8
     b4e:	d070      	beq.n	c32 <fatfs_init+0x1e6>
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
     b50:	6223      	str	r3, [r4, #32]
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);

    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
     b52:	f894 906f 	ldrb.w	r9, [r4, #111]	; 0x6f
     b56:	f894 706e 	ldrb.w	r7, [r4, #110]	; 0x6e
     b5a:	043f      	lsls	r7, r7, #16
     b5c:	eb07 6709 	add.w	r7, r7, r9, lsl #24
     b60:	f894 906c 	ldrb.w	r9, [r4, #108]	; 0x6c
     b64:	444f      	add	r7, r9
     b66:	f894 906d 	ldrb.w	r9, [r4, #109]	; 0x6d
     b6a:	eb07 2709 	add.w	r7, r7, r9, lsl #8
     b6e:	60a7      	str	r7, [r4, #8]
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
     b70:	f894 9071 	ldrb.w	r9, [r4, #113]	; 0x71
     b74:	f894 7070 	ldrb.w	r7, [r4, #112]	; 0x70
     b78:	eb07 2709 	add.w	r7, r7, r9, lsl #8
     b7c:	8327      	strh	r7, [r4, #24]

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
     b7e:	6a27      	ldr	r7, [r4, #32]
     b80:	fb07 f905 	mul.w	r9, r7, r5
     b84:	eb0c 0709 	add.w	r7, ip, r9
     b88:	60e7      	str	r7, [r4, #12]
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
     b8a:	ea4f 1e4e 	mov.w	lr, lr, lsl #5
     b8e:	f20e 1eff 	addw	lr, lr, #511	; 0x1ff
     b92:	ea4f 276e 	mov.w	r7, lr, asr #9
     b96:	6127      	str	r7, [r4, #16]

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
     b98:	69e7      	ldr	r7, [r4, #28]
     b9a:	4467      	add	r7, ip
     b9c:	6167      	str	r7, [r4, #20]

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
     b9e:	444f      	add	r7, r9
     ba0:	6067      	str	r7, [r4, #4]

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
     ba2:	f894 e23f 	ldrb.w	lr, [r4, #575]	; 0x23f
     ba6:	f894 723e 	ldrb.w	r7, [r4, #574]	; 0x23e
     baa:	eb07 270e 	add.w	r7, r7, lr, lsl #8
     bae:	f64a 2e55 	movw	lr, #43605	; 0xaa55
     bb2:	4577      	cmp	r7, lr
     bb4:	d17a      	bne.n	cac <fatfs_init+0x260>
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
     bb6:	eb02 2208 	add.w	r2, r2, r8, lsl #8
     bba:	0152      	lsls	r2, r2, #5
     bbc:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
     bc0:	2a00      	cmp	r2, #0
     bc2:	bfb8      	it	lt
     bc4:	f202 12ff 	addwlt	r2, r2, #511	; 0x1ff
     bc8:	ea4f 2862 	mov.w	r8, r2, asr #9

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
     bcc:	2b00      	cmp	r3, #0
     bce:	d040      	beq.n	c52 <fatfs_init+0x206>
        FATSz = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
     bd0:	461f      	mov	r7, r3
    else
        FATSz = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16) != 0)
     bd2:	f894 2054 	ldrb.w	r2, [r4, #84]	; 0x54
     bd6:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
     bda:	eb13 2302 	adds.w	r3, r3, r2, lsl #8
     bde:	d10d      	bne.n	bfc <fatfs_init+0x1b0>
        total_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16);
    else
        total_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_TOTSEC32);
     be0:	f894 3063 	ldrb.w	r3, [r4, #99]	; 0x63
     be4:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
     be8:	0412      	lsls	r2, r2, #16
     bea:	eb02 6203 	add.w	r2, r2, r3, lsl #24
     bee:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
     bf2:	441a      	add	r2, r3
     bf4:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
     bf8:	eb02 2303 	add.w	r3, r2, r3, lsl #8

    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);
     bfc:	eb01 2206 	add.w	r2, r1, r6, lsl #8
     c00:	4442      	add	r2, r8
     c02:	fb05 2207 	mla	r2, r5, r7, r2
     c06:	1a9b      	subs	r3, r3, r2

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
     c08:	2800      	cmp	r0, #0
     c0a:	d053      	beq.n	cb4 <fatfs_init+0x268>
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
     c0c:	fbb3 f3f0 	udiv	r3, r3, r0

        if(count_of_clusters < 4085)
     c10:	f640 72f4 	movw	r2, #4084	; 0xff4
     c14:	4293      	cmp	r3, r2
     c16:	d951      	bls.n	cbc <fatfs_init+0x270>
            // Volume is FAT12
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525)
     c18:	f64f 72f4 	movw	r2, #65524	; 0xfff4
     c1c:	4293      	cmp	r3, r2
     c1e:	d927      	bls.n	c70 <fatfs_init+0x224>
            return FAT_INIT_OK;
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
     c20:	2301      	movs	r3, #1
     c22:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
            return FAT_INIT_OK;
     c26:	2000      	movs	r0, #0
     c28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        fs->lba_begin = 0;
     c2c:	2300      	movs	r3, #0
     c2e:	61e3      	str	r3, [r4, #28]
     c30:	e75e      	b.n	af0 <fatfs_init+0xa4>
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
     c32:	f894 9067 	ldrb.w	r9, [r4, #103]	; 0x67
     c36:	f894 7066 	ldrb.w	r7, [r4, #102]	; 0x66
     c3a:	043f      	lsls	r7, r7, #16
     c3c:	eb07 6709 	add.w	r7, r7, r9, lsl #24
     c40:	f894 9064 	ldrb.w	r9, [r4, #100]	; 0x64
     c44:	444f      	add	r7, r9
     c46:	f894 9065 	ldrb.w	r9, [r4, #101]	; 0x65
     c4a:	eb07 2709 	add.w	r7, r7, r9, lsl #8
     c4e:	6227      	str	r7, [r4, #32]
     c50:	e77f      	b.n	b52 <fatfs_init+0x106>
        FATSz = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
     c52:	f894 7067 	ldrb.w	r7, [r4, #103]	; 0x67
     c56:	f894 3066 	ldrb.w	r3, [r4, #102]	; 0x66
     c5a:	041b      	lsls	r3, r3, #16
     c5c:	eb03 6307 	add.w	r3, r3, r7, lsl #24
     c60:	f894 7064 	ldrb.w	r7, [r4, #100]	; 0x64
     c64:	443b      	add	r3, r7
     c66:	f894 7065 	ldrb.w	r7, [r4, #101]	; 0x65
     c6a:	eb03 2707 	add.w	r7, r3, r7, lsl #8
     c6e:	e7b0      	b.n	bd2 <fatfs_init+0x186>
            fs->rootdir_first_cluster = 0;
     c70:	2000      	movs	r0, #0
     c72:	60a0      	str	r0, [r4, #8]
            fs->fat_type = FAT_TYPE_16;
     c74:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
            return FAT_INIT_OK;
     c78:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_MEDIA_ACCESS_ERROR;
     c7c:	f04f 30ff 	mov.w	r0, #4294967295
     c80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_MEDIA_ACCESS_ERROR;
     c84:	f04f 30ff 	mov.w	r0, #4294967295
     c88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_INVALID_SIGNATURE;
     c8c:	f06f 0002 	mvn.w	r0, #2
     c90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_ENDIAN_ERROR;
     c94:	f06f 0003 	mvn.w	r0, #3
     c98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_MEDIA_ACCESS_ERROR;
     c9c:	f04f 30ff 	mov.w	r0, #4294967295
     ca0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_INVALID_SECTOR_SIZE;
     ca4:	f06f 0001 	mvn.w	r0, #1
     ca8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_INVALID_SIGNATURE;
     cac:	f06f 0002 	mvn.w	r0, #2
     cb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        }
    }
    else
        return FAT_INIT_WRONG_FILESYS_TYPE;
     cb4:	f06f 0004 	mvn.w	r0, #4
     cb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            return FAT_INIT_WRONG_FILESYS_TYPE;
     cbc:	f06f 0004 	mvn.w	r0, #4
}
     cc0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     cc4:	00002605 	.word	0x00002605

00000cc8 <fatfs_lba_of_cluster>:
// fatfs_lba_of_cluster: This function converts a cluster number into a sector /
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
     cc8:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
     ccc:	b12b      	cbz	r3, cda <fatfs_lba_of_cluster+0x12>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
     cce:	3902      	subs	r1, #2
     cd0:	7803      	ldrb	r3, [r0, #0]
     cd2:	6840      	ldr	r0, [r0, #4]
     cd4:	fb03 0001 	mla	r0, r3, r1, r0
}
     cd8:	4770      	bx	lr
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
     cda:	3902      	subs	r1, #2
     cdc:	7802      	ldrb	r2, [r0, #0]
     cde:	6843      	ldr	r3, [r0, #4]
     ce0:	fb02 3101 	mla	r1, r2, r1, r3
     ce4:	8d00      	ldrh	r0, [r0, #40]	; 0x28
     ce6:	0140      	lsls	r0, r0, #5
     ce8:	eb01 2060 	add.w	r0, r1, r0, asr #9
     cec:	4770      	bx	lr

00000cee <fatfs_sector_read>:
//-----------------------------------------------------------------------------
// fatfs_sector_read:
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
     cee:	b538      	push	{r3, r4, r5, lr}
     cf0:	460d      	mov	r5, r1
     cf2:	4611      	mov	r1, r2
    return fs->disk_io.read_media(lba, target, count);
     cf4:	6b04      	ldr	r4, [r0, #48]	; 0x30
     cf6:	461a      	mov	r2, r3
     cf8:	4628      	mov	r0, r5
     cfa:	47a0      	blx	r4
}
     cfc:	bd38      	pop	{r3, r4, r5, pc}

00000cfe <fatfs_sector_write>:
//-----------------------------------------------------------------------------
// fatfs_sector_write:
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
     cfe:	b538      	push	{r3, r4, r5, lr}
     d00:	460d      	mov	r5, r1
     d02:	4611      	mov	r1, r2
    return fs->disk_io.write_media(lba, target, count);
     d04:	6b44      	ldr	r4, [r0, #52]	; 0x34
     d06:	461a      	mov	r2, r3
     d08:	4628      	mov	r0, r5
     d0a:	47a0      	blx	r4
}
     d0c:	bd38      	pop	{r3, r4, r5, pc}
	...

00000d10 <fatfs_sector_reader>:
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
     d10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     d14:	4605      	mov	r5, r0
     d16:	4698      	mov	r8, r3
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
     d18:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
     d1c:	b943      	cbnz	r3, d30 <fatfs_sector_reader+0x20>
     d1e:	b939      	cbnz	r1, d30 <fatfs_sector_reader+0x20>
    {
        if (offset < fs->rootdir_sectors)
     d20:	6903      	ldr	r3, [r0, #16]
     d22:	4293      	cmp	r3, r2
     d24:	d92f      	bls.n	d86 <fatfs_sector_reader+0x76>
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
     d26:	69c3      	ldr	r3, [r0, #28]
     d28:	68c0      	ldr	r0, [r0, #12]
     d2a:	4403      	add	r3, r0
     d2c:	1898      	adds	r0, r3, r2
        if (offset < fs->rootdir_sectors)
     d2e:	e014      	b.n	d5a <fatfs_sector_reader+0x4a>
    {
        // Set start of cluster chain to initial value
        cluster_chain = start_cluster;

        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;
     d30:	7828      	ldrb	r0, [r5, #0]
     d32:	fbb2 f6f0 	udiv	r6, r2, r0
     d36:	fb00 2916 	mls	r9, r0, r6, r2
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
     d3a:	b13e      	cbz	r6, d4c <fatfs_sector_reader+0x3c>
     d3c:	2400      	movs	r4, #0
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
     d3e:	4f16      	ldr	r7, [pc, #88]	; (d98 <fatfs_sector_reader+0x88>)
     d40:	4628      	mov	r0, r5
     d42:	47b8      	blx	r7
     d44:	4601      	mov	r1, r0
        for (i=0; i<cluster_to_read; i++)
     d46:	3401      	adds	r4, #1
     d48:	42a6      	cmp	r6, r4
     d4a:	d1f9      	bne.n	d40 <fatfs_sector_reader+0x30>

        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER)
     d4c:	f1b1 3fff 	cmp.w	r1, #4294967295
     d50:	d01c      	beq.n	d8c <fatfs_sector_reader+0x7c>
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
     d52:	4628      	mov	r0, r5
     d54:	4b11      	ldr	r3, [pc, #68]	; (d9c <fatfs_sector_reader+0x8c>)
     d56:	4798      	blx	r3
     d58:	4448      	add	r0, r9
    }

    // User provided target array
    if (target)
     d5a:	f1b8 0f00 	cmp.w	r8, #0
     d5e:	d005      	beq.n	d6c <fatfs_sector_reader+0x5c>
        return fs->disk_io.read_media(lba, target, 1);
     d60:	6b2b      	ldr	r3, [r5, #48]	; 0x30
     d62:	2201      	movs	r2, #1
     d64:	4641      	mov	r1, r8
     d66:	4798      	blx	r3
     d68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
     d6c:	f8d5 3240 	ldr.w	r3, [r5, #576]	; 0x240
     d70:	4298      	cmp	r0, r3
     d72:	d00e      	beq.n	d92 <fatfs_sector_reader+0x82>
    {
        fs->currentsector.address = lba;
     d74:	f8c5 0240 	str.w	r0, [r5, #576]	; 0x240
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
     d78:	6b2b      	ldr	r3, [r5, #48]	; 0x30
     d7a:	2201      	movs	r2, #1
     d7c:	f105 0140 	add.w	r1, r5, #64	; 0x40
     d80:	4798      	blx	r3
     d82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            return 0;
     d86:	2000      	movs	r0, #0
     d88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            return 0;
     d8c:	2000      	movs	r0, #0
     d8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
    else
        return 1;
     d92:	2001      	movs	r0, #1
}
     d94:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     d98:	00002671 	.word	0x00002671
     d9c:	00000cc9 	.word	0x00000cc9

00000da0 <fatfs_write_sector>:
// fatfs_write_sector: Write to the provided cluster and sector offset
// Returns True if success, returns False if not
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_write_sector(struct fatfs *fs, uint32 cluster, uint32 sector, uint8 *target)
{
     da0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // No write access?
    if (!fs->disk_io.write_media)
     da2:	6b46      	ldr	r6, [r0, #52]	; 0x34
     da4:	b36e      	cbz	r6, e02 <fatfs_write_sector+0x62>
     da6:	461f      	mov	r7, r3
     da8:	4615      	mov	r5, r2
     daa:	4604      	mov	r4, r0
        return 0;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && cluster == 0)
     dac:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
     db0:	b99b      	cbnz	r3, dda <fatfs_write_sector+0x3a>
     db2:	b991      	cbnz	r1, dda <fatfs_write_sector+0x3a>
    {
        uint32 lba;

        // In FAT16 we cannot extend the root dir!
        if (sector < fs->rootdir_sectors)
     db4:	6903      	ldr	r3, [r0, #16]
     db6:	4293      	cmp	r3, r2
     db8:	d925      	bls.n	e06 <fatfs_write_sector+0x66>
            lba = fs->lba_begin + fs->rootdir_first_sector + sector;
     dba:	69c0      	ldr	r0, [r0, #28]
     dbc:	68e3      	ldr	r3, [r4, #12]
     dbe:	4418      	add	r0, r3
     dc0:	4410      	add	r0, r2
        else
            return 0;

        // User target buffer passed in
        if (target)
     dc2:	b11f      	cbz	r7, dcc <fatfs_write_sector+0x2c>
        {
            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
     dc4:	2201      	movs	r2, #1
     dc6:	4639      	mov	r1, r7
     dc8:	47b0      	blx	r6
     dca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = lba;
     dcc:	f8c4 0240 	str.w	r0, [r4, #576]	; 0x240

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
     dd0:	2201      	movs	r2, #1
     dd2:	f104 0140 	add.w	r1, r4, #64	; 0x40
     dd6:	47b0      	blx	r6
     dd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    // FAT16/32 Other
    else
    {
        // User target buffer passed in
        if (target)
     dda:	b13f      	cbz	r7, dec <fatfs_write_sector+0x4c>
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;
     ddc:	4620      	mov	r0, r4
     dde:	4b0b      	ldr	r3, [pc, #44]	; (e0c <fatfs_write_sector+0x6c>)
     de0:	4798      	blx	r3

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
     de2:	2201      	movs	r2, #1
     de4:	4639      	mov	r1, r7
     de6:	4428      	add	r0, r5
     de8:	47b0      	blx	r6
     dea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
     dec:	4620      	mov	r0, r4
     dee:	4b07      	ldr	r3, [pc, #28]	; (e0c <fatfs_write_sector+0x6c>)
     df0:	4798      	blx	r3
     df2:	4428      	add	r0, r5
     df4:	f8c4 0240 	str.w	r0, [r4, #576]	; 0x240

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
     df8:	2201      	movs	r2, #1
     dfa:	f104 0140 	add.w	r1, r4, #64	; 0x40
     dfe:	47b0      	blx	r6
     e00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
     e02:	2000      	movs	r0, #0
     e04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return 0;
     e06:	2000      	movs	r0, #0
        }
    }
}
     e08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     e0a:	bf00      	nop
     e0c:	00000cc9 	.word	0x00000cc9

00000e10 <fatfs_get_root_cluster>:
//-----------------------------------------------------------------------------
uint32 fatfs_get_root_cluster(struct fatfs *fs)
{
    // NOTE: On FAT16 this will be 0 which has a special meaning...
    return fs->rootdir_first_cluster;
}
     e10:	6880      	ldr	r0, [r0, #8]
     e12:	4770      	bx	lr

00000e14 <fatfs_get_file_entry>:
//-------------------------------------------------------------
// fatfs_get_file_entry: Find the file entry for a filename
//-------------------------------------------------------------
uint32 fatfs_get_file_entry(struct fatfs *fs, uint32 Cluster, char *name_to_find, struct fat_dir_entry *sfEntry)
{
     e14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     e18:	b0cb      	sub	sp, #300	; 0x12c
     e1a:	4682      	mov	sl, r0
     e1c:	9102      	str	r1, [sp, #8]
     e1e:	9201      	str	r2, [sp, #4]
     e20:	9303      	str	r3, [sp, #12]
    char short_filename[13];
    struct lfn_cache lfn;
    int dotRequired = 0;
    struct fat_dir_entry *directoryEntry;

    fatfs_lfn_cache_init(&lfn, 1);
     e22:	2101      	movs	r1, #1
     e24:	a804      	add	r0, sp, #16
     e26:	4b52      	ldr	r3, [pc, #328]	; (f70 <fatfs_get_file_entry+0x15c>)
     e28:	4798      	blx	r3
     e2a:	f04f 0b00 	mov.w	fp, #0
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) )
     e2e:	4f51      	ldr	r7, [pc, #324]	; (f74 <fatfs_get_file_entry+0x160>)
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
     e30:	f8df 8158 	ldr.w	r8, [pc, #344]	; f8c <fatfs_get_file_entry+0x178>
                    fatfs_lfn_cache_init(&lfn, 0);

                // Normal SFN Entry and Long text exists
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) )
     e34:	f8df 9158 	ldr.w	r9, [pc, #344]	; f90 <fatfs_get_file_entry+0x17c>
     e38:	e08b      	b.n	f52 <fatfs_get_file_entry+0x13e>
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
     e3a:	4620      	mov	r0, r4
     e3c:	47c0      	blx	r8
     e3e:	b180      	cbz	r0, e62 <fatfs_get_file_entry+0x4e>
                    fatfs_lfn_cache_init(&lfn, 0);
     e40:	2100      	movs	r1, #0
     e42:	a804      	add	r0, sp, #16
     e44:	4b4a      	ldr	r3, [pc, #296]	; (f70 <fatfs_get_file_entry+0x15c>)
     e46:	4798      	blx	r3
     e48:	3420      	adds	r4, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
     e4a:	42a6      	cmp	r6, r4
     e4c:	d07f      	beq.n	f4e <fatfs_get_file_entry+0x13a>
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
     e4e:	4625      	mov	r5, r4
                if (fatfs_entry_lfn_text(directoryEntry) )
     e50:	4620      	mov	r0, r4
     e52:	47b8      	blx	r7
     e54:	2800      	cmp	r0, #0
     e56:	d0f0      	beq.n	e3a <fatfs_get_file_entry+0x26>
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);
     e58:	4621      	mov	r1, r4
     e5a:	a804      	add	r0, sp, #16
     e5c:	4b46      	ldr	r3, [pc, #280]	; (f78 <fatfs_get_file_entry+0x164>)
     e5e:	4798      	blx	r3
     e60:	e7f2      	b.n	e48 <fatfs_get_file_entry+0x34>
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) )
     e62:	4621      	mov	r1, r4
     e64:	a804      	add	r0, sp, #16
     e66:	47c8      	blx	r9
     e68:	b300      	cbz	r0, eac <fatfs_get_file_entry+0x98>
                {
                    long_filename = fatfs_lfn_cache_get(&lfn);
     e6a:	a804      	add	r0, sp, #16
     e6c:	4b43      	ldr	r3, [pc, #268]	; (f7c <fatfs_get_file_entry+0x168>)
     e6e:	4798      	blx	r3

                    // Compare names to see if they match
                    if (fatfs_compare_names(long_filename, name_to_find))
     e70:	9901      	ldr	r1, [sp, #4]
     e72:	4b43      	ldr	r3, [pc, #268]	; (f80 <fatfs_get_file_entry+0x16c>)
     e74:	4798      	blx	r3
     e76:	b920      	cbnz	r0, e82 <fatfs_get_file_entry+0x6e>
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
     e78:	2100      	movs	r1, #0
     e7a:	a804      	add	r0, sp, #16
     e7c:	4b3c      	ldr	r3, [pc, #240]	; (f70 <fatfs_get_file_entry+0x15c>)
     e7e:	4798      	blx	r3
     e80:	e7e2      	b.n	e48 <fatfs_get_file_entry+0x34>
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
     e82:	6820      	ldr	r0, [r4, #0]
     e84:	6861      	ldr	r1, [r4, #4]
     e86:	68a2      	ldr	r2, [r4, #8]
     e88:	68e3      	ldr	r3, [r4, #12]
     e8a:	9e03      	ldr	r6, [sp, #12]
     e8c:	6030      	str	r0, [r6, #0]
     e8e:	6071      	str	r1, [r6, #4]
     e90:	60b2      	str	r2, [r6, #8]
     e92:	60f3      	str	r3, [r6, #12]
     e94:	6928      	ldr	r0, [r5, #16]
     e96:	6969      	ldr	r1, [r5, #20]
     e98:	69aa      	ldr	r2, [r5, #24]
     e9a:	69eb      	ldr	r3, [r5, #28]
     e9c:	6130      	str	r0, [r6, #16]
     e9e:	6171      	str	r1, [r6, #20]
     ea0:	61b2      	str	r2, [r6, #24]
     ea2:	61f3      	str	r3, [r6, #28]
                        return 1;
     ea4:	2001      	movs	r0, #1
        else
            break;
    } // End of while loop

    return 0;
}
     ea6:	b04b      	add	sp, #300	; 0x12c
     ea8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (fatfs_entry_sfn_only(directoryEntry) )
     eac:	4620      	mov	r0, r4
     eae:	4b35      	ldr	r3, [pc, #212]	; (f84 <fatfs_get_file_entry+0x170>)
     eb0:	4798      	blx	r3
     eb2:	2800      	cmp	r0, #0
     eb4:	d0c8      	beq.n	e48 <fatfs_get_file_entry+0x34>
                    memset(short_filename, 0, sizeof(short_filename));
     eb6:	2300      	movs	r3, #0
     eb8:	9346      	str	r3, [sp, #280]	; 0x118
     eba:	9347      	str	r3, [sp, #284]	; 0x11c
     ebc:	9348      	str	r3, [sp, #288]	; 0x120
     ebe:	f88d 3124 	strb.w	r3, [sp, #292]	; 0x124
     ec2:	1e63      	subs	r3, r4, #1
     ec4:	f20d 1217 	addw	r2, sp, #279	; 0x117
     ec8:	1de0      	adds	r0, r4, #7
                        short_filename[i] = directoryEntry->Name[i];
     eca:	f813 1f01 	ldrb.w	r1, [r3, #1]!
     ece:	f802 1f01 	strb.w	r1, [r2, #1]!
                    for (i=0; i<8; i++)
     ed2:	4298      	cmp	r0, r3
     ed4:	d1f9      	bne.n	eca <fatfs_get_file_entry+0xb6>
                        short_filename[i+1] = directoryEntry->Name[i];
     ed6:	7a2b      	ldrb	r3, [r5, #8]
     ed8:	f88d 3121 	strb.w	r3, [sp, #289]	; 0x121
                        if (directoryEntry->Name[i] != ' ')
     edc:	3b20      	subs	r3, #32
     ede:	bf18      	it	ne
     ee0:	2301      	movne	r3, #1
                        short_filename[i+1] = directoryEntry->Name[i];
     ee2:	7a6a      	ldrb	r2, [r5, #9]
     ee4:	f88d 2122 	strb.w	r2, [sp, #290]	; 0x122
                            dotRequired = 1;
     ee8:	2a20      	cmp	r2, #32
     eea:	bf18      	it	ne
     eec:	2301      	movne	r3, #1
                        short_filename[i+1] = directoryEntry->Name[i];
     eee:	7aaa      	ldrb	r2, [r5, #10]
     ef0:	f88d 2123 	strb.w	r2, [sp, #291]	; 0x123
                        if (directoryEntry->Name[i] != ' ')
     ef4:	2a20      	cmp	r2, #32
     ef6:	d011      	beq.n	f1c <fatfs_get_file_entry+0x108>
                        if (short_filename[0]!='.')
     ef8:	f89d 3118 	ldrb.w	r3, [sp, #280]	; 0x118
     efc:	2b2e      	cmp	r3, #46	; 0x2e
                            short_filename[8] = '.';
     efe:	bf14      	ite	ne
     f00:	232e      	movne	r3, #46	; 0x2e
                            short_filename[8] = ' ';
     f02:	2320      	moveq	r3, #32
     f04:	f88d 3120 	strb.w	r3, [sp, #288]	; 0x120
                    if (fatfs_compare_names(short_filename, name_to_find))
     f08:	9901      	ldr	r1, [sp, #4]
     f0a:	a846      	add	r0, sp, #280	; 0x118
     f0c:	4b1c      	ldr	r3, [pc, #112]	; (f80 <fatfs_get_file_entry+0x16c>)
     f0e:	4798      	blx	r3
     f10:	b950      	cbnz	r0, f28 <fatfs_get_file_entry+0x114>
                    fatfs_lfn_cache_init(&lfn, 0);
     f12:	2100      	movs	r1, #0
     f14:	a804      	add	r0, sp, #16
     f16:	4b16      	ldr	r3, [pc, #88]	; (f70 <fatfs_get_file_entry+0x15c>)
     f18:	4798      	blx	r3
     f1a:	e795      	b.n	e48 <fatfs_get_file_entry+0x34>
                    if (dotRequired)
     f1c:	2b00      	cmp	r3, #0
     f1e:	d1eb      	bne.n	ef8 <fatfs_get_file_entry+0xe4>
                        short_filename[8] = ' ';
     f20:	2320      	movs	r3, #32
     f22:	f88d 3120 	strb.w	r3, [sp, #288]	; 0x120
     f26:	e7ef      	b.n	f08 <fatfs_get_file_entry+0xf4>
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
     f28:	6828      	ldr	r0, [r5, #0]
     f2a:	6869      	ldr	r1, [r5, #4]
     f2c:	68aa      	ldr	r2, [r5, #8]
     f2e:	68eb      	ldr	r3, [r5, #12]
     f30:	9e03      	ldr	r6, [sp, #12]
     f32:	6030      	str	r0, [r6, #0]
     f34:	6071      	str	r1, [r6, #4]
     f36:	60b2      	str	r2, [r6, #8]
     f38:	60f3      	str	r3, [r6, #12]
     f3a:	6928      	ldr	r0, [r5, #16]
     f3c:	6969      	ldr	r1, [r5, #20]
     f3e:	69aa      	ldr	r2, [r5, #24]
     f40:	69eb      	ldr	r3, [r5, #28]
     f42:	6130      	str	r0, [r6, #16]
     f44:	6171      	str	r1, [r6, #20]
     f46:	61b2      	str	r2, [r6, #24]
     f48:	61f3      	str	r3, [r6, #28]
                        return 1;
     f4a:	2001      	movs	r0, #1
     f4c:	e7ab      	b.n	ea6 <fatfs_get_file_entry+0x92>
     f4e:	f10b 0b01 	add.w	fp, fp, #1
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
     f52:	2300      	movs	r3, #0
     f54:	465a      	mov	r2, fp
     f56:	9902      	ldr	r1, [sp, #8]
     f58:	4650      	mov	r0, sl
     f5a:	4c0b      	ldr	r4, [pc, #44]	; (f88 <fatfs_get_file_entry+0x174>)
     f5c:	47a0      	blx	r4
     f5e:	b120      	cbz	r0, f6a <fatfs_get_file_entry+0x156>
     f60:	f10a 0440 	add.w	r4, sl, #64	; 0x40
     f64:	f50a 7610 	add.w	r6, sl, #576	; 0x240
     f68:	e771      	b.n	e4e <fatfs_get_file_entry+0x3a>
    return 0;
     f6a:	2000      	movs	r0, #0
     f6c:	e79b      	b.n	ea6 <fatfs_get_file_entry+0x92>
     f6e:	bf00      	nop
     f70:	00001e35 	.word	0x00001e35
     f74:	00001eed 	.word	0x00001eed
     f78:	00001e55 	.word	0x00001e55
     f7c:	00001ec7 	.word	0x00001ec7
     f80:	00002429 	.word	0x00002429
     f84:	00001f5b 	.word	0x00001f5b
     f88:	00000d11 	.word	0x00000d11
     f8c:	00001efd 	.word	0x00001efd
     f90:	00001f23 	.word	0x00001f23

00000f94 <fatfs_sfn_exists>:
// fatfs_sfn_exists: Check if a short filename exists.
// NOTE: shortname is XXXXXXXXYYY not XXXXXXXX.YYY
//-------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_sfn_exists(struct fatfs *fs, uint32 Cluster, char *shortname)
{
     f94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     f98:	b083      	sub	sp, #12
     f9a:	4681      	mov	r9, r0
     f9c:	9100      	str	r1, [sp, #0]
     f9e:	9201      	str	r2, [sp, #4]
     fa0:	f04f 0a00 	mov.w	sl, #0
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) )
     fa4:	4f18      	ldr	r7, [pc, #96]	; (1008 <fatfs_sfn_exists+0x74>)
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
     fa6:	f8df 806c 	ldr.w	r8, [pc, #108]	; 1014 <fatfs_sfn_exists+0x80>
                    ;
                else
#endif
                // Normal Entry, only 8.3 Text
                if (fatfs_entry_sfn_only(directoryEntry) )
     faa:	f8df b06c 	ldr.w	fp, [pc, #108]	; 1018 <fatfs_sfn_exists+0x84>
     fae:	e01c      	b.n	fea <fatfs_sfn_exists+0x56>
     fb0:	3420      	adds	r4, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
     fb2:	42b4      	cmp	r4, r6
     fb4:	d017      	beq.n	fe6 <fatfs_sfn_exists+0x52>
                if (fatfs_entry_lfn_text(directoryEntry) )
     fb6:	4620      	mov	r0, r4
     fb8:	47b8      	blx	r7
     fba:	2800      	cmp	r0, #0
     fbc:	d1f8      	bne.n	fb0 <fatfs_sfn_exists+0x1c>
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
     fbe:	4620      	mov	r0, r4
     fc0:	47c0      	blx	r8
     fc2:	2800      	cmp	r0, #0
     fc4:	d1f4      	bne.n	fb0 <fatfs_sfn_exists+0x1c>
                if (fatfs_entry_sfn_only(directoryEntry) )
     fc6:	4620      	mov	r0, r4
     fc8:	47d8      	blx	fp
     fca:	2800      	cmp	r0, #0
     fcc:	d0f0      	beq.n	fb0 <fatfs_sfn_exists+0x1c>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
     fce:	220b      	movs	r2, #11
     fd0:	9901      	ldr	r1, [sp, #4]
     fd2:	4620      	mov	r0, r4
     fd4:	4b0d      	ldr	r3, [pc, #52]	; (100c <fatfs_sfn_exists+0x78>)
     fd6:	4798      	blx	r3
     fd8:	2800      	cmp	r0, #0
     fda:	d1e9      	bne.n	fb0 <fatfs_sfn_exists+0x1c>
                        return 1;
     fdc:	2301      	movs	r3, #1
        else
            break;
    } // End of while loop

    return 0;
}
     fde:	4618      	mov	r0, r3
     fe0:	b003      	add	sp, #12
     fe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     fe6:	f10a 0a01 	add.w	sl, sl, #1
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
     fea:	2300      	movs	r3, #0
     fec:	4652      	mov	r2, sl
     fee:	9900      	ldr	r1, [sp, #0]
     ff0:	4648      	mov	r0, r9
     ff2:	4c07      	ldr	r4, [pc, #28]	; (1010 <fatfs_sfn_exists+0x7c>)
     ff4:	47a0      	blx	r4
     ff6:	4603      	mov	r3, r0
     ff8:	2800      	cmp	r0, #0
     ffa:	d0f0      	beq.n	fde <fatfs_sfn_exists+0x4a>
     ffc:	f109 0440 	add.w	r4, r9, #64	; 0x40
    1000:	f509 7610 	add.w	r6, r9, #576	; 0x240
    1004:	e7d7      	b.n	fb6 <fatfs_sfn_exists+0x22>
    1006:	bf00      	nop
    1008:	00001eed 	.word	0x00001eed
    100c:	0000355d 	.word	0x0000355d
    1010:	00000d11 	.word	0x00000d11
    1014:	00001efd 	.word	0x00001efd
    1018:	00001f5b 	.word	0x00001f5b

0000101c <fatfs_update_file_length>:
// fatfs_update_file_length: Find a SFN entry and update it
// NOTE: shortname is XXXXXXXXYYY not XXXXXXXX.YYY
//-------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_update_file_length(struct fatfs *fs, uint32 Cluster, char *shortname, uint32 fileLength)
{
    101c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1020:	b085      	sub	sp, #20
    uint16 recordoffset = 0;
    int x=0;
    struct fat_dir_entry *directoryEntry;

    // No write access?
    if (!fs->disk_io.write_media)
    1022:	6b44      	ldr	r4, [r0, #52]	; 0x34
    1024:	2c00      	cmp	r4, #0
    1026:	d043      	beq.n	10b0 <fatfs_update_file_length+0x94>
    1028:	9303      	str	r3, [sp, #12]
    102a:	9202      	str	r2, [sp, #8]
    102c:	9101      	str	r1, [sp, #4]
    102e:	4605      	mov	r5, r0
    1030:	f04f 0b00 	mov.w	fp, #0

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
    1034:	f8df 8088 	ldr.w	r8, [pc, #136]	; 10c0 <fatfs_update_file_length+0xa4>
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) )
    1038:	4e1e      	ldr	r6, [pc, #120]	; (10b4 <fatfs_update_file_length+0x98>)
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    103a:	f8df a088 	ldr.w	sl, [pc, #136]	; 10c4 <fatfs_update_file_length+0xa8>
    103e:	e02a      	b.n	1096 <fatfs_update_file_length+0x7a>
    1040:	3420      	adds	r4, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    1042:	42bc      	cmp	r4, r7
    1044:	d025      	beq.n	1092 <fatfs_update_file_length+0x76>
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
    1046:	f105 0940 	add.w	r9, r5, #64	; 0x40
    104a:	9400      	str	r4, [sp, #0]
                if (fatfs_entry_lfn_text(directoryEntry) )
    104c:	4620      	mov	r0, r4
    104e:	47b0      	blx	r6
    1050:	2800      	cmp	r0, #0
    1052:	d1f5      	bne.n	1040 <fatfs_update_file_length+0x24>
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    1054:	4620      	mov	r0, r4
    1056:	47d0      	blx	sl
    1058:	2800      	cmp	r0, #0
    105a:	d1f1      	bne.n	1040 <fatfs_update_file_length+0x24>
                    ;

                // Normal Entry, only 8.3 Text
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
    105c:	9800      	ldr	r0, [sp, #0]
    105e:	4b16      	ldr	r3, [pc, #88]	; (10b8 <fatfs_update_file_length+0x9c>)
    1060:	4798      	blx	r3
    1062:	2800      	cmp	r0, #0
    1064:	d0ec      	beq.n	1040 <fatfs_update_file_length+0x24>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
    1066:	220b      	movs	r2, #11
    1068:	9902      	ldr	r1, [sp, #8]
    106a:	9800      	ldr	r0, [sp, #0]
    106c:	4b13      	ldr	r3, [pc, #76]	; (10bc <fatfs_update_file_length+0xa0>)
    106e:	4798      	blx	r3
    1070:	2800      	cmp	r0, #0
    1072:	d1e5      	bne.n	1040 <fatfs_update_file_length+0x24>
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
    1074:	9b00      	ldr	r3, [sp, #0]
    1076:	461a      	mov	r2, r3
    1078:	9b03      	ldr	r3, [sp, #12]
    107a:	61d3      	str	r3, [r2, #28]

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
    107c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    107e:	2201      	movs	r2, #1
    1080:	4649      	mov	r1, r9
    1082:	f8d5 0240 	ldr.w	r0, [r5, #576]	; 0x240
    1086:	4798      	blx	r3
    1088:	4603      	mov	r3, r0
        else
            break;
    } // End of while loop

    return 0;
}
    108a:	4618      	mov	r0, r3
    108c:	b005      	add	sp, #20
    108e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1092:	f10b 0b01 	add.w	fp, fp, #1
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
    1096:	2300      	movs	r3, #0
    1098:	465a      	mov	r2, fp
    109a:	9901      	ldr	r1, [sp, #4]
    109c:	4628      	mov	r0, r5
    109e:	47c0      	blx	r8
    10a0:	4603      	mov	r3, r0
    10a2:	2800      	cmp	r0, #0
    10a4:	d0f1      	beq.n	108a <fatfs_update_file_length+0x6e>
    10a6:	f105 0440 	add.w	r4, r5, #64	; 0x40
    10aa:	f505 7710 	add.w	r7, r5, #576	; 0x240
    10ae:	e7ca      	b.n	1046 <fatfs_update_file_length+0x2a>
        return 0;
    10b0:	2300      	movs	r3, #0
    10b2:	e7ea      	b.n	108a <fatfs_update_file_length+0x6e>
    10b4:	00001eed 	.word	0x00001eed
    10b8:	00001f5b 	.word	0x00001f5b
    10bc:	0000355d 	.word	0x0000355d
    10c0:	00000d11 	.word	0x00000d11
    10c4:	00001efd 	.word	0x00001efd

000010c8 <fatfs_cache_init>:
        file->cluster_cache_data[i] = 0;
    }
#endif

    return 1;
}
    10c8:	2001      	movs	r0, #1
    10ca:	4770      	bx	lr

000010cc <fatfs_cache_get_next_cluster>:
        return 1;
    }
#endif

    return 0;
}
    10cc:	2000      	movs	r0, #0
    10ce:	4770      	bx	lr

000010d0 <fatfs_cache_set_next_cluster>:
        file->cluster_cache_data[slot] = nextCluster;
    }
#endif

    return 1;
}
    10d0:	2001      	movs	r0, #1
    10d2:	4770      	bx	lr

000010d4 <fat_list_insert_last>:
static FAT_INLINE void fat_list_insert_last(struct fat_list *list, struct fat_node *node)
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
    10d4:	6843      	ldr	r3, [r0, #4]
    10d6:	b13b      	cbz	r3, 10e8 <fat_list_insert_last+0x14>
    new_node->previous = node;
    10d8:	600b      	str	r3, [r1, #0]
    new_node->next = node->next;
    10da:	685a      	ldr	r2, [r3, #4]
    10dc:	604a      	str	r2, [r1, #4]
    if (!node->next)
    10de:	685a      	ldr	r2, [r3, #4]
    10e0:	b19a      	cbz	r2, 110a <fat_list_insert_last+0x36>
        node->next->previous = new_node;
    10e2:	6011      	str	r1, [r2, #0]
    node->next = new_node;
    10e4:	6059      	str	r1, [r3, #4]
    10e6:	4770      	bx	lr
    if (!list->head)
    10e8:	6803      	ldr	r3, [r0, #0]
    10ea:	b13b      	cbz	r3, 10fc <fat_list_insert_last+0x28>
    new_node->previous = node->previous;
    10ec:	681a      	ldr	r2, [r3, #0]
    10ee:	600a      	str	r2, [r1, #0]
    new_node->next = node;
    10f0:	604b      	str	r3, [r1, #4]
    if (!node->previous)
    10f2:	681a      	ldr	r2, [r3, #0]
    10f4:	b13a      	cbz	r2, 1106 <fat_list_insert_last+0x32>
        node->previous->next = new_node;
    10f6:	6051      	str	r1, [r2, #4]
    node->previous = new_node;
    10f8:	6019      	str	r1, [r3, #0]
    10fa:	4770      	bx	lr
        list->head = node;
    10fc:	6001      	str	r1, [r0, #0]
        list->tail = node;
    10fe:	6041      	str	r1, [r0, #4]
        node->previous = 0;
    1100:	600b      	str	r3, [r1, #0]
        node->next = 0;
    1102:	604b      	str	r3, [r1, #4]
    1104:	4770      	bx	lr
        list->head = new_node;
    1106:	6001      	str	r1, [r0, #0]
    1108:	e7f6      	b.n	10f8 <fat_list_insert_last+0x24>
        list->tail = new_node;
    110a:	6041      	str	r1, [r0, #4]
    110c:	e7ea      	b.n	10e4 <fat_list_insert_last+0x10>
	...

00001110 <_allocate_file>:

//-----------------------------------------------------------------------------
// _allocate_file: Find a slot in the open files buffer for a new file
//-----------------------------------------------------------------------------
static FL_FILE* _allocate_file(void)
{
    1110:	b510      	push	{r4, lr}
{
    struct fat_node * node;

    FAT_ASSERT(list);

    node = fat_list_first(list);
    1112:	4b0e      	ldr	r3, [pc, #56]	; (114c <_allocate_file+0x3c>)
    1114:	681c      	ldr	r4, [r3, #0]
    if (node)
    1116:	b1b4      	cbz	r4, 1146 <_allocate_file+0x36>
    if(!node->previous)
    1118:	6823      	ldr	r3, [r4, #0]
    111a:	b163      	cbz	r3, 1136 <_allocate_file+0x26>
        node->previous->next = node->next;
    111c:	6862      	ldr	r2, [r4, #4]
    111e:	605a      	str	r2, [r3, #4]
    if(!node->next)
    1120:	6863      	ldr	r3, [r4, #4]
    1122:	b163      	cbz	r3, 113e <_allocate_file+0x2e>
        node->next->previous = node->previous;
    1124:	6822      	ldr	r2, [r4, #0]
    1126:	601a      	str	r2, [r3, #0]
    // Allocate free file
    struct fat_node *node = fat_list_pop_head(&_free_file_list);

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);
    1128:	4621      	mov	r1, r4
    112a:	4809      	ldr	r0, [pc, #36]	; (1150 <_allocate_file+0x40>)
    112c:	4b09      	ldr	r3, [pc, #36]	; (1154 <_allocate_file+0x44>)
    112e:	4798      	blx	r3

    return fat_list_entry(node, FL_FILE, list_node);
    1130:	f2a4 403c 	subw	r0, r4, #1084	; 0x43c
}
    1134:	bd10      	pop	{r4, pc}
        list->head = node->next;
    1136:	6862      	ldr	r2, [r4, #4]
    1138:	4b04      	ldr	r3, [pc, #16]	; (114c <_allocate_file+0x3c>)
    113a:	601a      	str	r2, [r3, #0]
    113c:	e7f0      	b.n	1120 <_allocate_file+0x10>
        list->tail = node->previous;
    113e:	6822      	ldr	r2, [r4, #0]
    1140:	4b02      	ldr	r3, [pc, #8]	; (114c <_allocate_file+0x3c>)
    1142:	605a      	str	r2, [r3, #4]
    1144:	e7f0      	b.n	1128 <_allocate_file+0x18>
    if (node)
    1146:	2000      	movs	r0, #0
    1148:	bd10      	pop	{r4, pc}
    114a:	bf00      	nop
    114c:	20000460 	.word	0x20000460
    1150:	20000468 	.word	0x20000468
    1154:	000010d5 	.word	0x000010d5

00001158 <_check_file_open>:
//-----------------------------------------------------------------------------
// _check_file_open: Returns true if the file is already open
//-----------------------------------------------------------------------------
static int _check_file_open(FL_FILE* file)
{
    1158:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    struct fat_node *node;

    // Compare open files
    fat_list_for_each(&_open_file_list, node)
    115c:	4b12      	ldr	r3, [pc, #72]	; (11a8 <_check_file_open+0x50>)
    115e:	689c      	ldr	r4, [r3, #8]
    1160:	b1f4      	cbz	r4, 11a0 <_check_file_open+0x48>
    1162:	4606      	mov	r6, r0

        // If not the current file
        if (openFile != file)
        {
            // Compare path and name
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
    1164:	f100 0814 	add.w	r8, r0, #20
    1168:	4f10      	ldr	r7, [pc, #64]	; (11ac <_check_file_open+0x54>)
    116a:	f500 798c 	add.w	r9, r0, #280	; 0x118
    116e:	e001      	b.n	1174 <_check_file_open+0x1c>
    fat_list_for_each(&_open_file_list, node)
    1170:	6864      	ldr	r4, [r4, #4]
    1172:	b194      	cbz	r4, 119a <_check_file_open+0x42>
        FL_FILE* openFile = fat_list_entry(node, FL_FILE, list_node);
    1174:	f2a4 453c 	subw	r5, r4, #1084	; 0x43c
        if (openFile != file)
    1178:	42b5      	cmp	r5, r6
    117a:	d0f9      	beq.n	1170 <_check_file_open+0x18>
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
    117c:	4641      	mov	r1, r8
    117e:	f5a4 6085 	sub.w	r0, r4, #1064	; 0x428
    1182:	47b8      	blx	r7
    1184:	2800      	cmp	r0, #0
    1186:	d0f3      	beq.n	1170 <_check_file_open+0x18>
    1188:	4649      	mov	r1, r9
    118a:	f5a4 7049 	sub.w	r0, r4, #804	; 0x324
    118e:	47b8      	blx	r7
    1190:	2800      	cmp	r0, #0
    1192:	d0ed      	beq.n	1170 <_check_file_open+0x18>
                return 1;
    1194:	2001      	movs	r0, #1
        }
    }

    return 0;
}
    1196:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;
    119a:	2000      	movs	r0, #0
    119c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    11a0:	2000      	movs	r0, #0
    11a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    11a6:	bf00      	nop
    11a8:	20000460 	.word	0x20000460
    11ac:	00002429 	.word	0x00002429

000011b0 <_open_directory>:
//-----------------------------------------------------------------------------
// _open_directory: Cycle through path string to find the start cluster
// address of the highest subdir.
//-----------------------------------------------------------------------------
static int _open_directory(char *path, uint32 *pathCluster)
{
    11b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    11b4:	b0ca      	sub	sp, #296	; 0x128
    11b6:	4680      	mov	r8, r0
    11b8:	468a      	mov	sl, r1
    char currentfolder[FATFS_MAX_LONG_FILENAME];
    struct fat_dir_entry sfEntry;
    uint32 startcluster;

    // Set starting cluster to root cluster
    startcluster = fatfs_get_root_cluster(&_fs);
    11ba:	481c      	ldr	r0, [pc, #112]	; (122c <_open_directory+0x7c>)
    11bc:	4b1c      	ldr	r3, [pc, #112]	; (1230 <_open_directory+0x80>)
    11be:	4798      	blx	r3
    11c0:	4604      	mov	r4, r0

    // Find number of levels
    levels = fatfs_total_path_levels(path);
    11c2:	4640      	mov	r0, r8
    11c4:	4b1b      	ldr	r3, [pc, #108]	; (1234 <_open_directory+0x84>)
    11c6:	4798      	blx	r3

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++)
    11c8:	1c43      	adds	r3, r0, #1
    11ca:	2b00      	cmp	r3, #0
    11cc:	dd22      	ble.n	1214 <_open_directory+0x64>
    11ce:	461e      	mov	r6, r3
    11d0:	2500      	movs	r5, #0
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
    11d2:	4f19      	ldr	r7, [pc, #100]	; (1238 <_open_directory+0x88>)
            return 0;

        // Find clusteraddress for folder (currentfolder)
        if (fatfs_get_file_entry(&_fs, startcluster, currentfolder,&sfEntry))
    11d4:	f8df 9054 	ldr.w	r9, [pc, #84]	; 122c <_open_directory+0x7c>
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
    11d8:	f44f 7382 	mov.w	r3, #260	; 0x104
    11dc:	aa09      	add	r2, sp, #36	; 0x24
    11de:	4629      	mov	r1, r5
    11e0:	4640      	mov	r0, r8
    11e2:	47b8      	blx	r7
    11e4:	f1b0 3fff 	cmp.w	r0, #4294967295
    11e8:	d01b      	beq.n	1222 <_open_directory+0x72>
        if (fatfs_get_file_entry(&_fs, startcluster, currentfolder,&sfEntry))
    11ea:	ab01      	add	r3, sp, #4
    11ec:	aa09      	add	r2, sp, #36	; 0x24
    11ee:	4621      	mov	r1, r4
    11f0:	4648      	mov	r0, r9
    11f2:	4c12      	ldr	r4, [pc, #72]	; (123c <_open_directory+0x8c>)
    11f4:	47a0      	blx	r4
    11f6:	b1b0      	cbz	r0, 1226 <_open_directory+0x76>
        {
            // Check entry is folder
            if (fatfs_entry_is_dir(&sfEntry))
    11f8:	a801      	add	r0, sp, #4
    11fa:	4b11      	ldr	r3, [pc, #68]	; (1240 <_open_directory+0x90>)
    11fc:	4798      	blx	r3
    11fe:	4603      	mov	r3, r0
    1200:	b158      	cbz	r0, 121a <_open_directory+0x6a>
                startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
    1202:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    1206:	f8bd 401e 	ldrh.w	r4, [sp, #30]
    120a:	eb04 4403 	add.w	r4, r4, r3, lsl #16
    for (sublevel=0;sublevel<(levels+1);sublevel++)
    120e:	3501      	adds	r5, #1
    1210:	42ae      	cmp	r6, r5
    1212:	d1e1      	bne.n	11d8 <_open_directory+0x28>
        }
        else
            return 0;
    }

    *pathCluster = startcluster;
    1214:	f8ca 4000 	str.w	r4, [sl]
    return 1;
    1218:	2301      	movs	r3, #1
}
    121a:	4618      	mov	r0, r3
    121c:	b04a      	add	sp, #296	; 0x128
    121e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            return 0;
    1222:	2300      	movs	r3, #0
    1224:	e7f9      	b.n	121a <_open_directory+0x6a>
            return 0;
    1226:	2300      	movs	r3, #0
    1228:	e7f7      	b.n	121a <_open_directory+0x6a>
    122a:	bf00      	nop
    122c:	20000470 	.word	0x20000470
    1230:	00000e11 	.word	0x00000e11
    1234:	000022bf 	.word	0x000022bf
    1238:	00002315 	.word	0x00002315
    123c:	00000e15 	.word	0x00000e15
    1240:	00001f89 	.word	0x00001f89

00001244 <_write_sectors>:
//-----------------------------------------------------------------------------
// _write_sectors: Write sector(s) to disk
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
static uint32 _write_sectors(FL_FILE* file, uint32 offset, uint8 *buf, uint32 count)
{
    1244:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1248:	b085      	sub	sp, #20
    124a:	4606      	mov	r6, r0
    124c:	9200      	str	r2, [sp, #0]
    124e:	461a      	mov	r2, r3
    1250:	9301      	str	r3, [sp, #4]
    uint32 SectorNumber = 0;
    uint32 ClusterIdx = 0;
    uint32 Cluster = 0;
    uint32 LastCluster = FAT32_LAST_CLUSTER;
    1252:	f04f 33ff 	mov.w	r3, #4294967295
    1256:	9303      	str	r3, [sp, #12]
    uint32 i;
    uint32 lba;
    uint32 TotalWriteCount = count;

    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;
    1258:	4b35      	ldr	r3, [pc, #212]	; (1330 <_write_sectors+0xec>)
    125a:	f893 8010 	ldrb.w	r8, [r3, #16]
    125e:	fbb1 f7f8 	udiv	r7, r1, r8
    1262:	fb08 1a17 	mls	sl, r8, r7, r1
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);

    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
    1266:	4613      	mov	r3, r2
    1268:	4453      	add	r3, sl
    126a:	4598      	cmp	r8, r3
        count = _fs.sectors_per_cluster - SectorNumber;
    126c:	bf34      	ite	cc
    126e:	eba8 080a 	subcc.w	r8, r8, sl
    1272:	f8dd 8004 	ldrcs.w	r8, [sp, #4]

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
    1276:	f8d0 4228 	ldr.w	r4, [r0, #552]	; 0x228
    127a:	42a7      	cmp	r7, r4
    127c:	d00a      	beq.n	1294 <_write_sectors+0x50>
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
    127e:	b117      	cbz	r7, 1286 <_write_sectors+0x42>
    1280:	1c63      	adds	r3, r4, #1
    1282:	429f      	cmp	r7, r3
    1284:	d009      	beq.n	129a <_write_sectors+0x56>
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;
    1286:	6875      	ldr	r5, [r6, #4]
            i = 0;
    1288:	2400      	movs	r4, #0
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
    128a:	42a7      	cmp	r7, r4
    128c:	d924      	bls.n	12d8 <_write_sectors+0x94>
        {
            uint32 nextCluster;

            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    128e:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 1348 <_write_sectors+0x104>
    1292:	e00d      	b.n	12b0 <_write_sectors+0x6c>
        Cluster = file->last_fat_lookup.CurrentCluster;
    1294:	f8d0 522c 	ldr.w	r5, [r0, #556]	; 0x22c
    1298:	e032      	b.n	1300 <_write_sectors+0xbc>
            Cluster = file->last_fat_lookup.CurrentCluster;
    129a:	f8d0 522c 	ldr.w	r5, [r0, #556]	; 0x22c
    129e:	e7f4      	b.n	128a <_write_sectors+0x46>

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }

            LastCluster = Cluster;
    12a0:	9503      	str	r5, [sp, #12]
            Cluster = nextCluster;
    12a2:	9d02      	ldr	r5, [sp, #8]

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
    12a4:	f1b5 3fff 	cmp.w	r5, #4294967295
    12a8:	d019      	beq.n	12de <_write_sectors+0x9a>
        for ( ;i<ClusterIdx; i++)
    12aa:	3401      	adds	r4, #1
    12ac:	42a7      	cmp	r7, r4
    12ae:	d023      	beq.n	12f8 <_write_sectors+0xb4>
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    12b0:	ab02      	add	r3, sp, #8
    12b2:	4622      	mov	r2, r4
    12b4:	4631      	mov	r1, r6
    12b6:	481f      	ldr	r0, [pc, #124]	; (1334 <_write_sectors+0xf0>)
    12b8:	47c8      	blx	r9
    12ba:	2800      	cmp	r0, #0
    12bc:	d1f0      	bne.n	12a0 <_write_sectors+0x5c>
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
    12be:	4629      	mov	r1, r5
    12c0:	481c      	ldr	r0, [pc, #112]	; (1334 <_write_sectors+0xf0>)
    12c2:	4b1d      	ldr	r3, [pc, #116]	; (1338 <_write_sectors+0xf4>)
    12c4:	4798      	blx	r3
    12c6:	4603      	mov	r3, r0
    12c8:	9002      	str	r0, [sp, #8]
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
    12ca:	4622      	mov	r2, r4
    12cc:	4631      	mov	r1, r6
    12ce:	4819      	ldr	r0, [pc, #100]	; (1334 <_write_sectors+0xf0>)
    12d0:	f8df b078 	ldr.w	fp, [pc, #120]	; 134c <_write_sectors+0x108>
    12d4:	47d8      	blx	fp
    12d6:	e7e3      	b.n	12a0 <_write_sectors+0x5c>
                break;
        }

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
    12d8:	f1b5 3fff 	cmp.w	r5, #4294967295
    12dc:	d10c      	bne.n	12f8 <_write_sectors+0xb4>
        {
            // Add some more cluster(s) to the last good cluster chain
            if (!fatfs_add_free_space(&_fs, &LastCluster,  (TotalWriteCount + _fs.sectors_per_cluster -1) / _fs.sectors_per_cluster))
    12de:	4814      	ldr	r0, [pc, #80]	; (1330 <_write_sectors+0xec>)
    12e0:	f810 2f10 	ldrb.w	r2, [r0, #16]!
    12e4:	1e53      	subs	r3, r2, #1
    12e6:	9901      	ldr	r1, [sp, #4]
    12e8:	440b      	add	r3, r1
    12ea:	fbb3 f2f2 	udiv	r2, r3, r2
    12ee:	a903      	add	r1, sp, #12
    12f0:	4b12      	ldr	r3, [pc, #72]	; (133c <_write_sectors+0xf8>)
    12f2:	4798      	blx	r3
    12f4:	b1c0      	cbz	r0, 1328 <_write_sectors+0xe4>
                return 0;

            Cluster = LastCluster;
    12f6:	9d03      	ldr	r5, [sp, #12]
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
    12f8:	f8c6 522c 	str.w	r5, [r6, #556]	; 0x22c
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
    12fc:	f8c6 7228 	str.w	r7, [r6, #552]	; 0x228
    }

    // Calculate write address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + SectorNumber;
    1300:	4c0c      	ldr	r4, [pc, #48]	; (1334 <_write_sectors+0xf0>)
    1302:	4629      	mov	r1, r5
    1304:	4620      	mov	r0, r4
    1306:	4b0e      	ldr	r3, [pc, #56]	; (1340 <_write_sectors+0xfc>)
    1308:	4798      	blx	r3

    if (fatfs_sector_write(&_fs, lba, buf, count))
    130a:	4643      	mov	r3, r8
    130c:	9a00      	ldr	r2, [sp, #0]
    130e:	eb00 010a 	add.w	r1, r0, sl
    1312:	4620      	mov	r0, r4
    1314:	4c0b      	ldr	r4, [pc, #44]	; (1344 <_write_sectors+0x100>)
    1316:	47a0      	blx	r4
    1318:	2800      	cmp	r0, #0
        return count;
    else
        return 0;
    131a:	bf08      	it	eq
    131c:	f04f 0800 	moveq.w	r8, #0
}
    1320:	4640      	mov	r0, r8
    1322:	b005      	add	sp, #20
    1324:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                return 0;
    1328:	f04f 0800 	mov.w	r8, #0
    132c:	e7f8      	b.n	1320 <_write_sectors+0xdc>
    132e:	bf00      	nop
    1330:	20000460 	.word	0x20000460
    1334:	20000470 	.word	0x20000470
    1338:	00002671 	.word	0x00002671
    133c:	0000290d 	.word	0x0000290d
    1340:	00000cc9 	.word	0x00000cc9
    1344:	00000cff 	.word	0x00000cff
    1348:	000010cd 	.word	0x000010cd
    134c:	000010d1 	.word	0x000010d1

00001350 <_read_sectors>:
{
    1350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1354:	b085      	sub	sp, #20
    1356:	4605      	mov	r5, r0
    1358:	9201      	str	r2, [sp, #4]
    135a:	469a      	mov	sl, r3
    ClusterIdx = offset / _fs.sectors_per_cluster;
    135c:	4b2c      	ldr	r3, [pc, #176]	; (1410 <_read_sectors+0xc0>)
    135e:	7c1b      	ldrb	r3, [r3, #16]
    1360:	fbb1 f6f3 	udiv	r6, r1, r3
    1364:	fb03 1916 	mls	r9, r3, r6, r1
    if ((Sector + count) > _fs.sectors_per_cluster)
    1368:	eb0a 0209 	add.w	r2, sl, r9
    136c:	4293      	cmp	r3, r2
        count = _fs.sectors_per_cluster - Sector;
    136e:	bf38      	it	cc
    1370:	eba3 0a09 	subcc.w	sl, r3, r9
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
    1374:	f8d0 4228 	ldr.w	r4, [r0, #552]	; 0x228
    1378:	42a6      	cmp	r6, r4
    137a:	d00c      	beq.n	1396 <_read_sectors+0x46>
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
    137c:	b116      	cbz	r6, 1384 <_read_sectors+0x34>
    137e:	1c63      	adds	r3, r4, #1
    1380:	429e      	cmp	r6, r3
    1382:	d00f      	beq.n	13a4 <_read_sectors+0x54>
            Cluster = file->startcluster;
    1384:	686f      	ldr	r7, [r5, #4]
            i = 0;
    1386:	2400      	movs	r4, #0
        for ( ;i<ClusterIdx; i++)
    1388:	42a6      	cmp	r6, r4
    138a:	d924      	bls.n	13d6 <_read_sectors+0x86>
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    138c:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1424 <_read_sectors+0xd4>
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
    1390:	f8df b094 	ldr.w	fp, [pc, #148]	; 1428 <_read_sectors+0xd8>
    1394:	e00d      	b.n	13b2 <_read_sectors+0x62>
        Cluster = file->last_fat_lookup.CurrentCluster;
    1396:	f8d0 722c 	ldr.w	r7, [r0, #556]	; 0x22c
    if (Cluster == FAT32_LAST_CLUSTER)
    139a:	f1b7 3fff 	cmp.w	r7, #4294967295
    139e:	d121      	bne.n	13e4 <_read_sectors+0x94>
        return 0;
    13a0:	2000      	movs	r0, #0
    13a2:	e02f      	b.n	1404 <_read_sectors+0xb4>
            Cluster = file->last_fat_lookup.CurrentCluster;
    13a4:	f8d0 722c 	ldr.w	r7, [r0, #556]	; 0x22c
    13a8:	e7ee      	b.n	1388 <_read_sectors+0x38>
            Cluster = nextCluster;
    13aa:	9f03      	ldr	r7, [sp, #12]
        for ( ;i<ClusterIdx; i++)
    13ac:	3401      	adds	r4, #1
    13ae:	42a6      	cmp	r6, r4
    13b0:	d011      	beq.n	13d6 <_read_sectors+0x86>
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    13b2:	ab03      	add	r3, sp, #12
    13b4:	4622      	mov	r2, r4
    13b6:	4629      	mov	r1, r5
    13b8:	4816      	ldr	r0, [pc, #88]	; (1414 <_read_sectors+0xc4>)
    13ba:	47c0      	blx	r8
    13bc:	2800      	cmp	r0, #0
    13be:	d1f4      	bne.n	13aa <_read_sectors+0x5a>
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
    13c0:	4639      	mov	r1, r7
    13c2:	4814      	ldr	r0, [pc, #80]	; (1414 <_read_sectors+0xc4>)
    13c4:	47d8      	blx	fp
    13c6:	4603      	mov	r3, r0
    13c8:	9003      	str	r0, [sp, #12]
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
    13ca:	4622      	mov	r2, r4
    13cc:	4629      	mov	r1, r5
    13ce:	4811      	ldr	r0, [pc, #68]	; (1414 <_read_sectors+0xc4>)
    13d0:	4f11      	ldr	r7, [pc, #68]	; (1418 <_read_sectors+0xc8>)
    13d2:	47b8      	blx	r7
    13d4:	e7e9      	b.n	13aa <_read_sectors+0x5a>
        if (Cluster != FAT32_LAST_CLUSTER)
    13d6:	f1b7 3fff 	cmp.w	r7, #4294967295
    13da:	d016      	beq.n	140a <_read_sectors+0xba>
            file->last_fat_lookup.CurrentCluster = Cluster;
    13dc:	f8c5 722c 	str.w	r7, [r5, #556]	; 0x22c
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
    13e0:	f8c5 6228 	str.w	r6, [r5, #552]	; 0x228
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;
    13e4:	4c0b      	ldr	r4, [pc, #44]	; (1414 <_read_sectors+0xc4>)
    13e6:	4639      	mov	r1, r7
    13e8:	4620      	mov	r0, r4
    13ea:	4b0c      	ldr	r3, [pc, #48]	; (141c <_read_sectors+0xcc>)
    13ec:	4798      	blx	r3
    if (fatfs_sector_read(&_fs, lba, buffer, count))
    13ee:	4653      	mov	r3, sl
    13f0:	9a01      	ldr	r2, [sp, #4]
    13f2:	eb00 0109 	add.w	r1, r0, r9
    13f6:	4620      	mov	r0, r4
    13f8:	4c09      	ldr	r4, [pc, #36]	; (1420 <_read_sectors+0xd0>)
    13fa:	47a0      	blx	r4
    13fc:	2800      	cmp	r0, #0
        return 0;
    13fe:	bf14      	ite	ne
    1400:	4650      	movne	r0, sl
    1402:	2000      	moveq	r0, #0
}
    1404:	b005      	add	sp, #20
    1406:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return 0;
    140a:	2000      	movs	r0, #0
    140c:	e7fa      	b.n	1404 <_read_sectors+0xb4>
    140e:	bf00      	nop
    1410:	20000460 	.word	0x20000460
    1414:	20000470 	.word	0x20000470
    1418:	000010d1 	.word	0x000010d1
    141c:	00000cc9 	.word	0x00000cc9
    1420:	00000cef 	.word	0x00000cef
    1424:	000010cd 	.word	0x000010cd
    1428:	00002671 	.word	0x00002671

0000142c <_free_file>:
{
    142c:	b508      	push	{r3, lr}
    fat_list_remove(&_open_file_list, &file->list_node);
    142e:	f200 413c 	addw	r1, r0, #1084	; 0x43c
    if(!node->previous)
    1432:	f8d0 343c 	ldr.w	r3, [r0, #1084]	; 0x43c
    1436:	b163      	cbz	r3, 1452 <_free_file+0x26>
        node->previous->next = node->next;
    1438:	f8d0 2440 	ldr.w	r2, [r0, #1088]	; 0x440
    143c:	605a      	str	r2, [r3, #4]
    if(!node->next)
    143e:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
    1442:	b15b      	cbz	r3, 145c <_free_file+0x30>
        node->next->previous = node->previous;
    1444:	f8d0 243c 	ldr.w	r2, [r0, #1084]	; 0x43c
    1448:	601a      	str	r2, [r3, #0]
    fat_list_insert_last(&_free_file_list, &file->list_node);
    144a:	4807      	ldr	r0, [pc, #28]	; (1468 <_free_file+0x3c>)
    144c:	4b07      	ldr	r3, [pc, #28]	; (146c <_free_file+0x40>)
    144e:	4798      	blx	r3
    1450:	bd08      	pop	{r3, pc}
        list->head = node->next;
    1452:	f8d0 2440 	ldr.w	r2, [r0, #1088]	; 0x440
    1456:	4b04      	ldr	r3, [pc, #16]	; (1468 <_free_file+0x3c>)
    1458:	609a      	str	r2, [r3, #8]
    145a:	e7f0      	b.n	143e <_free_file+0x12>
        list->tail = node->previous;
    145c:	f8d0 243c 	ldr.w	r2, [r0, #1084]	; 0x43c
    1460:	4b01      	ldr	r3, [pc, #4]	; (1468 <_free_file+0x3c>)
    1462:	60da      	str	r2, [r3, #12]
    1464:	e7f1      	b.n	144a <_free_file+0x1e>
    1466:	bf00      	nop
    1468:	20000460 	.word	0x20000460
    146c:	000010d5 	.word	0x000010d5

00001470 <_open_file>:
{
    1470:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1474:	b08b      	sub	sp, #44	; 0x2c
    1476:	4681      	mov	r9, r0
    file = _allocate_file();
    1478:	4b3f      	ldr	r3, [pc, #252]	; (1578 <_open_file+0x108>)
    147a:	4798      	blx	r3
    if (!file)
    147c:	4604      	mov	r4, r0
    147e:	2800      	cmp	r0, #0
    1480:	d05c      	beq.n	153c <_open_file+0xcc>
    memset(file->path, '\0', sizeof(file->path));
    1482:	f100 0714 	add.w	r7, r0, #20
    1486:	f44f 7582 	mov.w	r5, #260	; 0x104
    148a:	462a      	mov	r2, r5
    148c:	2100      	movs	r1, #0
    148e:	4638      	mov	r0, r7
    1490:	f8df 8110 	ldr.w	r8, [pc, #272]	; 15a4 <_open_file+0x134>
    1494:	47c0      	blx	r8
    memset(file->filename, '\0', sizeof(file->filename));
    1496:	f504 768c 	add.w	r6, r4, #280	; 0x118
    149a:	462a      	mov	r2, r5
    149c:	2100      	movs	r1, #0
    149e:	4630      	mov	r0, r6
    14a0:	47c0      	blx	r8
    if (fatfs_split_path((char*)path, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
    14a2:	9500      	str	r5, [sp, #0]
    14a4:	4633      	mov	r3, r6
    14a6:	462a      	mov	r2, r5
    14a8:	4639      	mov	r1, r7
    14aa:	4648      	mov	r0, r9
    14ac:	4d33      	ldr	r5, [pc, #204]	; (157c <_open_file+0x10c>)
    14ae:	47a8      	blx	r5
    14b0:	f1b0 3fff 	cmp.w	r0, #4294967295
    14b4:	d046      	beq.n	1544 <_open_file+0xd4>
    if (_check_file_open(file))
    14b6:	4620      	mov	r0, r4
    14b8:	4b31      	ldr	r3, [pc, #196]	; (1580 <_open_file+0x110>)
    14ba:	4798      	blx	r3
    14bc:	2800      	cmp	r0, #0
    14be:	d146      	bne.n	154e <_open_file+0xde>
    if (file->path[0]==0)
    14c0:	7d23      	ldrb	r3, [r4, #20]
    14c2:	2b00      	cmp	r3, #0
    14c4:	d148      	bne.n	1558 <_open_file+0xe8>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    14c6:	482f      	ldr	r0, [pc, #188]	; (1584 <_open_file+0x114>)
    14c8:	4b2f      	ldr	r3, [pc, #188]	; (1588 <_open_file+0x118>)
    14ca:	4798      	blx	r3
    14cc:	6020      	str	r0, [r4, #0]
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry))
    14ce:	ab02      	add	r3, sp, #8
    14d0:	4632      	mov	r2, r6
    14d2:	6821      	ldr	r1, [r4, #0]
    14d4:	482b      	ldr	r0, [pc, #172]	; (1584 <_open_file+0x114>)
    14d6:	4d2d      	ldr	r5, [pc, #180]	; (158c <_open_file+0x11c>)
    14d8:	47a8      	blx	r5
    14da:	2800      	cmp	r0, #0
    14dc:	d047      	beq.n	156e <_open_file+0xfe>
        if (fatfs_entry_is_file(&sfEntry))
    14de:	a802      	add	r0, sp, #8
    14e0:	4b2b      	ldr	r3, [pc, #172]	; (1590 <_open_file+0x120>)
    14e2:	4798      	blx	r3
    14e4:	2800      	cmp	r0, #0
    14e6:	d042      	beq.n	156e <_open_file+0xfe>
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
    14e8:	ab02      	add	r3, sp, #8
    14ea:	cb03      	ldmia	r3!, {r0, r1}
    14ec:	f8c4 021c 	str.w	r0, [r4, #540]	; 0x21c
    14f0:	f8c4 1220 	str.w	r1, [r4, #544]	; 0x220
    14f4:	8819      	ldrh	r1, [r3, #0]
    14f6:	789b      	ldrb	r3, [r3, #2]
    14f8:	f8a4 1224 	strh.w	r1, [r4, #548]	; 0x224
    14fc:	f884 3226 	strb.w	r3, [r4, #550]	; 0x226
            file->filelength = FAT_HTONL(sfEntry.FileSize);
    1500:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1502:	60e3      	str	r3, [r4, #12]
            file->bytenum = 0;
    1504:	2200      	movs	r2, #0
    1506:	60a2      	str	r2, [r4, #8]
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
    1508:	f8bd 101c 	ldrh.w	r1, [sp, #28]
    150c:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
    1510:	eb03 4301 	add.w	r3, r3, r1, lsl #16
    1514:	6063      	str	r3, [r4, #4]
            file->file_data_address = 0xFFFFFFFF;
    1516:	f04f 33ff 	mov.w	r3, #4294967295
    151a:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
            file->file_data_dirty = 0;
    151e:	f8c4 2434 	str.w	r2, [r4, #1076]	; 0x434
            file->filelength_changed = 0;
    1522:	6122      	str	r2, [r4, #16]
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    1524:	f8c4 3228 	str.w	r3, [r4, #552]	; 0x228
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
    1528:	f8c4 322c 	str.w	r3, [r4, #556]	; 0x22c
            fatfs_cache_init(&_fs, file);
    152c:	4d15      	ldr	r5, [pc, #84]	; (1584 <_open_file+0x114>)
    152e:	4621      	mov	r1, r4
    1530:	4628      	mov	r0, r5
    1532:	4b18      	ldr	r3, [pc, #96]	; (1594 <_open_file+0x124>)
    1534:	4798      	blx	r3
            fatfs_fat_purge(&_fs);
    1536:	4628      	mov	r0, r5
    1538:	4b17      	ldr	r3, [pc, #92]	; (1598 <_open_file+0x128>)
    153a:	4798      	blx	r3
}
    153c:	4620      	mov	r0, r4
    153e:	b00b      	add	sp, #44	; 0x2c
    1540:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        _free_file(file);
    1544:	4620      	mov	r0, r4
    1546:	4b15      	ldr	r3, [pc, #84]	; (159c <_open_file+0x12c>)
    1548:	4798      	blx	r3
        return NULL;
    154a:	2400      	movs	r4, #0
    154c:	e7f6      	b.n	153c <_open_file+0xcc>
        _free_file(file);
    154e:	4620      	mov	r0, r4
    1550:	4b12      	ldr	r3, [pc, #72]	; (159c <_open_file+0x12c>)
    1552:	4798      	blx	r3
        return NULL;
    1554:	2400      	movs	r4, #0
    1556:	e7f1      	b.n	153c <_open_file+0xcc>
        if (!_open_directory(file->path, &file->parentcluster))
    1558:	4621      	mov	r1, r4
    155a:	4638      	mov	r0, r7
    155c:	4b10      	ldr	r3, [pc, #64]	; (15a0 <_open_file+0x130>)
    155e:	4798      	blx	r3
    1560:	2800      	cmp	r0, #0
    1562:	d1b4      	bne.n	14ce <_open_file+0x5e>
            _free_file(file);
    1564:	4620      	mov	r0, r4
    1566:	4b0d      	ldr	r3, [pc, #52]	; (159c <_open_file+0x12c>)
    1568:	4798      	blx	r3
            return NULL;
    156a:	2400      	movs	r4, #0
    156c:	e7e6      	b.n	153c <_open_file+0xcc>
    _free_file(file);
    156e:	4620      	mov	r0, r4
    1570:	4b0a      	ldr	r3, [pc, #40]	; (159c <_open_file+0x12c>)
    1572:	4798      	blx	r3
    return NULL;
    1574:	2400      	movs	r4, #0
    1576:	e7e1      	b.n	153c <_open_file+0xcc>
    1578:	00001111 	.word	0x00001111
    157c:	000023b1 	.word	0x000023b1
    1580:	00001159 	.word	0x00001159
    1584:	20000470 	.word	0x20000470
    1588:	00000e11 	.word	0x00000e11
    158c:	00000e15 	.word	0x00000e15
    1590:	00001f91 	.word	0x00001f91
    1594:	000010c9 	.word	0x000010c9
    1598:	00002639 	.word	0x00002639
    159c:	0000142d 	.word	0x0000142d
    15a0:	000011b1 	.word	0x000011b1
    15a4:	00003305 	.word	0x00003305

000015a8 <fl_init>:
{
    15a8:	b538      	push	{r3, r4, r5, lr}
    list->head = list->tail = 0;
    15aa:	4c09      	ldr	r4, [pc, #36]	; (15d0 <fl_init+0x28>)
    15ac:	2300      	movs	r3, #0
    15ae:	6063      	str	r3, [r4, #4]
    15b0:	6023      	str	r3, [r4, #0]
    15b2:	60e3      	str	r3, [r4, #12]
    15b4:	60a3      	str	r3, [r4, #8]
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);
    15b6:	f504 610b 	add.w	r1, r4, #2224	; 0x8b0
    15ba:	4620      	mov	r0, r4
    15bc:	4d05      	ldr	r5, [pc, #20]	; (15d4 <fl_init+0x2c>)
    15be:	47a8      	blx	r5
    15c0:	f604 41f4 	addw	r1, r4, #3316	; 0xcf4
    15c4:	4620      	mov	r0, r4
    15c6:	47a8      	blx	r5
    _filelib_init = 1;
    15c8:	2301      	movs	r3, #1
    15ca:	f8c4 3cfc 	str.w	r3, [r4, #3324]	; 0xcfc
    15ce:	bd38      	pop	{r3, r4, r5, pc}
    15d0:	20000460 	.word	0x20000460
    15d4:	000010d5 	.word	0x000010d5

000015d8 <fl_attach_media>:
{
    15d8:	b538      	push	{r3, r4, r5, lr}
    15da:	4605      	mov	r5, r0
    15dc:	460c      	mov	r4, r1
    CHECK_FL_INIT();
    15de:	4b0a      	ldr	r3, [pc, #40]	; (1608 <fl_attach_media+0x30>)
    15e0:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    15e4:	b16b      	cbz	r3, 1602 <fl_attach_media+0x2a>
    _fs.disk_io.read_media = rd;
    15e6:	4808      	ldr	r0, [pc, #32]	; (1608 <fl_attach_media+0x30>)
    15e8:	6405      	str	r5, [r0, #64]	; 0x40
    _fs.disk_io.write_media = wr;
    15ea:	6444      	str	r4, [r0, #68]	; 0x44
    if ((res = fatfs_init(&_fs)) != FAT_INIT_OK)
    15ec:	3010      	adds	r0, #16
    15ee:	4b07      	ldr	r3, [pc, #28]	; (160c <fl_attach_media+0x34>)
    15f0:	4798      	blx	r3
    15f2:	4603      	mov	r3, r0
    15f4:	b918      	cbnz	r0, 15fe <fl_attach_media+0x26>
    _filelib_valid = 1;
    15f6:	2101      	movs	r1, #1
    15f8:	4a03      	ldr	r2, [pc, #12]	; (1608 <fl_attach_media+0x30>)
    15fa:	f8c2 1d00 	str.w	r1, [r2, #3328]	; 0xd00
}
    15fe:	4618      	mov	r0, r3
    1600:	bd38      	pop	{r3, r4, r5, pc}
    CHECK_FL_INIT();
    1602:	4b03      	ldr	r3, [pc, #12]	; (1610 <fl_attach_media+0x38>)
    1604:	4798      	blx	r3
    1606:	e7ee      	b.n	15e6 <fl_attach_media+0xe>
    1608:	20000460 	.word	0x20000460
    160c:	00000a4d 	.word	0x00000a4d
    1610:	000015a9 	.word	0x000015a9

00001614 <fl_shutdown>:
{
    1614:	b510      	push	{r4, lr}
    CHECK_FL_INIT();
    1616:	4b0a      	ldr	r3, [pc, #40]	; (1640 <fl_shutdown+0x2c>)
    1618:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    161c:	b163      	cbz	r3, 1638 <fl_shutdown+0x24>
    FL_LOCK(&_fs);
    161e:	4b08      	ldr	r3, [pc, #32]	; (1640 <fl_shutdown+0x2c>)
    1620:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1622:	b103      	cbz	r3, 1626 <fl_shutdown+0x12>
    1624:	4798      	blx	r3
    fatfs_fat_purge(&_fs);
    1626:	4c06      	ldr	r4, [pc, #24]	; (1640 <fl_shutdown+0x2c>)
    1628:	f104 0010 	add.w	r0, r4, #16
    162c:	4b05      	ldr	r3, [pc, #20]	; (1644 <fl_shutdown+0x30>)
    162e:	4798      	blx	r3
    FL_UNLOCK(&_fs);
    1630:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    1632:	b103      	cbz	r3, 1636 <fl_shutdown+0x22>
    1634:	4798      	blx	r3
    1636:	bd10      	pop	{r4, pc}
    CHECK_FL_INIT();
    1638:	4b03      	ldr	r3, [pc, #12]	; (1648 <fl_shutdown+0x34>)
    163a:	4798      	blx	r3
    163c:	e7ef      	b.n	161e <fl_shutdown+0xa>
    163e:	bf00      	nop
    1640:	20000460 	.word	0x20000460
    1644:	00002639 	.word	0x00002639
    1648:	000015a9 	.word	0x000015a9

0000164c <fl_fopen>:
{
    164c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1650:	b093      	sub	sp, #76	; 0x4c
    1652:	4680      	mov	r8, r0
    1654:	460c      	mov	r4, r1
    CHECK_FL_INIT();
    1656:	4bbd      	ldr	r3, [pc, #756]	; (194c <fl_fopen+0x300>)
    1658:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    165c:	b19b      	cbz	r3, 1686 <fl_fopen+0x3a>
    if (!_filelib_valid)
    165e:	4bbb      	ldr	r3, [pc, #748]	; (194c <fl_fopen+0x300>)
    1660:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	; 0xd00
    1664:	2b00      	cmp	r3, #0
    1666:	f000 81f2 	beq.w	1a4e <fl_fopen+0x402>
    if (!path || !mode)
    166a:	f1b8 0f00 	cmp.w	r8, #0
    166e:	f000 81f0 	beq.w	1a52 <fl_fopen+0x406>
    1672:	2c00      	cmp	r4, #0
    1674:	f000 81ef 	beq.w	1a56 <fl_fopen+0x40a>
    for (i=0;i<(int)strlen(mode);i++)
    1678:	4620      	mov	r0, r4
    167a:	4bb5      	ldr	r3, [pc, #724]	; (1950 <fl_fopen+0x304>)
    167c:	4798      	blx	r3
    167e:	1e61      	subs	r1, r4, #1
    1680:	2400      	movs	r4, #0
    1682:	4622      	mov	r2, r4
    1684:	e005      	b.n	1692 <fl_fopen+0x46>
    CHECK_FL_INIT();
    1686:	4bb3      	ldr	r3, [pc, #716]	; (1954 <fl_fopen+0x308>)
    1688:	4798      	blx	r3
    168a:	e7e8      	b.n	165e <fl_fopen+0x12>
            flags |= FILE_READ;
    168c:	f044 0401 	orr.w	r4, r4, #1
    for (i=0;i<(int)strlen(mode);i++)
    1690:	3201      	adds	r2, #1
    1692:	4282      	cmp	r2, r0
    1694:	f280 80be 	bge.w	1814 <fl_fopen+0x1c8>
        switch (mode[i])
    1698:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    169c:	3b2b      	subs	r3, #43	; 0x2b
    169e:	2b4c      	cmp	r3, #76	; 0x4c
    16a0:	d8f6      	bhi.n	1690 <fl_fopen+0x44>
    16a2:	a501      	add	r5, pc, #4	; (adr r5, 16a8 <fl_fopen+0x5c>)
    16a4:	f855 f023 	ldr.w	pc, [r5, r3, lsl #2]
    16a8:	000017e9 	.word	0x000017e9
    16ac:	00001691 	.word	0x00001691
    16b0:	00001691 	.word	0x00001691
    16b4:	00001691 	.word	0x00001691
    16b8:	00001691 	.word	0x00001691
    16bc:	00001691 	.word	0x00001691
    16c0:	00001691 	.word	0x00001691
    16c4:	00001691 	.word	0x00001691
    16c8:	00001691 	.word	0x00001691
    16cc:	00001691 	.word	0x00001691
    16d0:	00001691 	.word	0x00001691
    16d4:	00001691 	.word	0x00001691
    16d8:	00001691 	.word	0x00001691
    16dc:	00001691 	.word	0x00001691
    16e0:	00001691 	.word	0x00001691
    16e4:	00001691 	.word	0x00001691
    16e8:	00001691 	.word	0x00001691
    16ec:	00001691 	.word	0x00001691
    16f0:	00001691 	.word	0x00001691
    16f4:	00001691 	.word	0x00001691
    16f8:	00001691 	.word	0x00001691
    16fc:	00001691 	.word	0x00001691
    1700:	000017e3 	.word	0x000017e3
    1704:	0000180f 	.word	0x0000180f
    1708:	00001691 	.word	0x00001691
    170c:	00001691 	.word	0x00001691
    1710:	00001691 	.word	0x00001691
    1714:	00001691 	.word	0x00001691
    1718:	00001691 	.word	0x00001691
    171c:	00001691 	.word	0x00001691
    1720:	00001691 	.word	0x00001691
    1724:	00001691 	.word	0x00001691
    1728:	00001691 	.word	0x00001691
    172c:	00001691 	.word	0x00001691
    1730:	00001691 	.word	0x00001691
    1734:	00001691 	.word	0x00001691
    1738:	00001691 	.word	0x00001691
    173c:	00001691 	.word	0x00001691
    1740:	00001691 	.word	0x00001691
    1744:	0000168d 	.word	0x0000168d
    1748:	00001691 	.word	0x00001691
    174c:	00001691 	.word	0x00001691
    1750:	00001691 	.word	0x00001691
    1754:	00001691 	.word	0x00001691
    1758:	000017dd 	.word	0x000017dd
    175c:	00001691 	.word	0x00001691
    1760:	00001691 	.word	0x00001691
    1764:	00001691 	.word	0x00001691
    1768:	00001691 	.word	0x00001691
    176c:	00001691 	.word	0x00001691
    1770:	00001691 	.word	0x00001691
    1774:	00001691 	.word	0x00001691
    1778:	00001691 	.word	0x00001691
    177c:	00001691 	.word	0x00001691
    1780:	000017e3 	.word	0x000017e3
    1784:	0000180f 	.word	0x0000180f
    1788:	00001691 	.word	0x00001691
    178c:	00001691 	.word	0x00001691
    1790:	00001691 	.word	0x00001691
    1794:	00001691 	.word	0x00001691
    1798:	00001691 	.word	0x00001691
    179c:	00001691 	.word	0x00001691
    17a0:	00001691 	.word	0x00001691
    17a4:	00001691 	.word	0x00001691
    17a8:	00001691 	.word	0x00001691
    17ac:	00001691 	.word	0x00001691
    17b0:	00001691 	.word	0x00001691
    17b4:	00001691 	.word	0x00001691
    17b8:	00001691 	.word	0x00001691
    17bc:	00001691 	.word	0x00001691
    17c0:	00001691 	.word	0x00001691
    17c4:	0000168d 	.word	0x0000168d
    17c8:	00001691 	.word	0x00001691
    17cc:	00001691 	.word	0x00001691
    17d0:	00001691 	.word	0x00001691
    17d4:	00001691 	.word	0x00001691
    17d8:	000017dd 	.word	0x000017dd
            flags |= FILE_CREATE;
    17dc:	f044 0432 	orr.w	r4, r4, #50	; 0x32
            break;
    17e0:	e756      	b.n	1690 <fl_fopen+0x44>
            flags |= FILE_CREATE;
    17e2:	f044 0426 	orr.w	r4, r4, #38	; 0x26
            break;
    17e6:	e753      	b.n	1690 <fl_fopen+0x44>
            if (flags & FILE_READ)
    17e8:	f014 0f01 	tst.w	r4, #1
    17ec:	d002      	beq.n	17f4 <fl_fopen+0x1a8>
                flags |= FILE_WRITE;
    17ee:	f044 0402 	orr.w	r4, r4, #2
    17f2:	e74d      	b.n	1690 <fl_fopen+0x44>
            else if (flags & FILE_WRITE)
    17f4:	f014 0f02 	tst.w	r4, #2
    17f8:	d002      	beq.n	1800 <fl_fopen+0x1b4>
                flags |= FILE_CREATE;
    17fa:	f044 0431 	orr.w	r4, r4, #49	; 0x31
    17fe:	e747      	b.n	1690 <fl_fopen+0x44>
            else if (flags & FILE_APPEND)
    1800:	f014 0f04 	tst.w	r4, #4
    1804:	f43f af44 	beq.w	1690 <fl_fopen+0x44>
                flags |= FILE_CREATE;
    1808:	f044 0427 	orr.w	r4, r4, #39	; 0x27
    180c:	e740      	b.n	1690 <fl_fopen+0x44>
            flags |= FILE_BINARY;
    180e:	f044 0408 	orr.w	r4, r4, #8
            break;
    1812:	e73d      	b.n	1690 <fl_fopen+0x44>
    if (!_fs.disk_io.write_media)
    1814:	4b4d      	ldr	r3, [pc, #308]	; (194c <fl_fopen+0x300>)
    1816:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1818:	b15b      	cbz	r3, 1832 <fl_fopen+0x1e6>
    FL_LOCK(&_fs);
    181a:	4b4c      	ldr	r3, [pc, #304]	; (194c <fl_fopen+0x300>)
    181c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    181e:	b103      	cbz	r3, 1822 <fl_fopen+0x1d6>
    1820:	4798      	blx	r3
    if (flags & FILE_READ)
    1822:	f014 0901 	ands.w	r9, r4, #1
    1826:	d107      	bne.n	1838 <fl_fopen+0x1ec>
    if (!file && (flags & FILE_CREATE))
    1828:	f014 0f20 	tst.w	r4, #32
    182c:	d10c      	bne.n	1848 <fl_fopen+0x1fc>
    182e:	2500      	movs	r5, #0
    1830:	e105      	b.n	1a3e <fl_fopen+0x3f2>
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
    1832:	f004 04d9 	and.w	r4, r4, #217	; 0xd9
    1836:	e7f0      	b.n	181a <fl_fopen+0x1ce>
        file = _open_file(path);
    1838:	4640      	mov	r0, r8
    183a:	4b47      	ldr	r3, [pc, #284]	; (1958 <fl_fopen+0x30c>)
    183c:	4798      	blx	r3
    if (!file && (flags & FILE_CREATE))
    183e:	4605      	mov	r5, r0
    1840:	2800      	cmp	r0, #0
    1842:	f040 80fa 	bne.w	1a3a <fl_fopen+0x3ee>
    1846:	e7ef      	b.n	1828 <fl_fopen+0x1dc>
    if (!_fs.disk_io.write_media)
    1848:	4b40      	ldr	r3, [pc, #256]	; (194c <fl_fopen+0x300>)
    184a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    184c:	2b00      	cmp	r3, #0
    184e:	f000 8106 	beq.w	1a5e <fl_fopen+0x412>
    file = _allocate_file();
    1852:	4b42      	ldr	r3, [pc, #264]	; (195c <fl_fopen+0x310>)
    1854:	4798      	blx	r3
    if (!file)
    1856:	4605      	mov	r5, r0
    1858:	2800      	cmp	r0, #0
    185a:	f000 8100 	beq.w	1a5e <fl_fopen+0x412>
    memset(file->path, '\0', sizeof(file->path));
    185e:	f100 0b14 	add.w	fp, r0, #20
    1862:	f44f 7682 	mov.w	r6, #260	; 0x104
    1866:	4632      	mov	r2, r6
    1868:	2100      	movs	r1, #0
    186a:	4658      	mov	r0, fp
    186c:	4f3c      	ldr	r7, [pc, #240]	; (1960 <fl_fopen+0x314>)
    186e:	47b8      	blx	r7
    memset(file->filename, '\0', sizeof(file->filename));
    1870:	f505 7a8c 	add.w	sl, r5, #280	; 0x118
    1874:	4632      	mov	r2, r6
    1876:	2100      	movs	r1, #0
    1878:	4650      	mov	r0, sl
    187a:	47b8      	blx	r7
    if (fatfs_split_path((char*)filename, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
    187c:	9600      	str	r6, [sp, #0]
    187e:	4653      	mov	r3, sl
    1880:	4632      	mov	r2, r6
    1882:	4659      	mov	r1, fp
    1884:	4640      	mov	r0, r8
    1886:	4e37      	ldr	r6, [pc, #220]	; (1964 <fl_fopen+0x318>)
    1888:	47b0      	blx	r6
    188a:	f1b0 3fff 	cmp.w	r0, #4294967295
    188e:	d042      	beq.n	1916 <fl_fopen+0x2ca>
    if (_check_file_open(file))
    1890:	4628      	mov	r0, r5
    1892:	4b35      	ldr	r3, [pc, #212]	; (1968 <fl_fopen+0x31c>)
    1894:	4798      	blx	r3
    1896:	4607      	mov	r7, r0
    1898:	2800      	cmp	r0, #0
    189a:	d140      	bne.n	191e <fl_fopen+0x2d2>
    if (file->path[0] == 0)
    189c:	7d2b      	ldrb	r3, [r5, #20]
    189e:	2b00      	cmp	r3, #0
    18a0:	d141      	bne.n	1926 <fl_fopen+0x2da>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    18a2:	4832      	ldr	r0, [pc, #200]	; (196c <fl_fopen+0x320>)
    18a4:	4b32      	ldr	r3, [pc, #200]	; (1970 <fl_fopen+0x324>)
    18a6:	4798      	blx	r3
    18a8:	6028      	str	r0, [r5, #0]
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry) == 1)
    18aa:	ab0a      	add	r3, sp, #40	; 0x28
    18ac:	4652      	mov	r2, sl
    18ae:	6829      	ldr	r1, [r5, #0]
    18b0:	482e      	ldr	r0, [pc, #184]	; (196c <fl_fopen+0x320>)
    18b2:	4e30      	ldr	r6, [pc, #192]	; (1974 <fl_fopen+0x328>)
    18b4:	47b0      	blx	r6
    18b6:	2801      	cmp	r0, #1
    18b8:	d03f      	beq.n	193a <fl_fopen+0x2ee>
    file->startcluster = 0;
    18ba:	462a      	mov	r2, r5
    18bc:	2300      	movs	r3, #0
    18be:	f842 3f04 	str.w	r3, [r2, #4]!
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
    18c2:	2301      	movs	r3, #1
    18c4:	4619      	mov	r1, r3
    18c6:	4829      	ldr	r0, [pc, #164]	; (196c <fl_fopen+0x320>)
    18c8:	4e2b      	ldr	r6, [pc, #172]	; (1978 <fl_fopen+0x32c>)
    18ca:	47b0      	blx	r6
    18cc:	2800      	cmp	r0, #0
    18ce:	d038      	beq.n	1942 <fl_fopen+0x2f6>
        fatfs_lfn_create_sfn(shortFilename, file->filename);
    18d0:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 1990 <fl_fopen+0x344>
    18d4:	4651      	mov	r1, sl
    18d6:	a807      	add	r0, sp, #28
    18d8:	47d8      	blx	fp
        if (tailNum != 0)
    18da:	2f00      	cmp	r7, #0
    18dc:	d05a      	beq.n	1994 <fl_fopen+0x348>
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
    18de:	f505 7607 	add.w	r6, r5, #540	; 0x21c
    18e2:	463a      	mov	r2, r7
    18e4:	a907      	add	r1, sp, #28
    18e6:	4630      	mov	r0, r6
    18e8:	4b24      	ldr	r3, [pc, #144]	; (197c <fl_fopen+0x330>)
    18ea:	4798      	blx	r3
        if (fatfs_sfn_exists(&_fs, file->parentcluster, (char*)file->shortfilename) == 0)
    18ec:	9605      	str	r6, [sp, #20]
    18ee:	4632      	mov	r2, r6
    18f0:	6829      	ldr	r1, [r5, #0]
    18f2:	481e      	ldr	r0, [pc, #120]	; (196c <fl_fopen+0x320>)
    18f4:	4b22      	ldr	r3, [pc, #136]	; (1980 <fl_fopen+0x334>)
    18f6:	4798      	blx	r3
    18f8:	2800      	cmp	r0, #0
    18fa:	d05e      	beq.n	19ba <fl_fopen+0x36e>
        tailNum++;
    18fc:	3701      	adds	r7, #1
    while (tailNum < 9999);
    18fe:	f242 730f 	movw	r3, #9999	; 0x270f
    1902:	429f      	cmp	r7, r3
    1904:	d1e6      	bne.n	18d4 <fl_fopen+0x288>
        fatfs_free_cluster_chain(&_fs, file->startcluster);
    1906:	6869      	ldr	r1, [r5, #4]
    1908:	4818      	ldr	r0, [pc, #96]	; (196c <fl_fopen+0x320>)
    190a:	4b1e      	ldr	r3, [pc, #120]	; (1984 <fl_fopen+0x338>)
    190c:	4798      	blx	r3
        _free_file(file);
    190e:	4628      	mov	r0, r5
    1910:	4b1d      	ldr	r3, [pc, #116]	; (1988 <fl_fopen+0x33c>)
    1912:	4798      	blx	r3
    1914:	e087      	b.n	1a26 <fl_fopen+0x3da>
        _free_file(file);
    1916:	4628      	mov	r0, r5
    1918:	4b1b      	ldr	r3, [pc, #108]	; (1988 <fl_fopen+0x33c>)
    191a:	4798      	blx	r3
    191c:	e083      	b.n	1a26 <fl_fopen+0x3da>
        _free_file(file);
    191e:	4628      	mov	r0, r5
    1920:	4b19      	ldr	r3, [pc, #100]	; (1988 <fl_fopen+0x33c>)
    1922:	4798      	blx	r3
    1924:	e07f      	b.n	1a26 <fl_fopen+0x3da>
        if (!_open_directory(file->path, &file->parentcluster))
    1926:	4629      	mov	r1, r5
    1928:	4658      	mov	r0, fp
    192a:	4b18      	ldr	r3, [pc, #96]	; (198c <fl_fopen+0x340>)
    192c:	4798      	blx	r3
    192e:	2800      	cmp	r0, #0
    1930:	d1bb      	bne.n	18aa <fl_fopen+0x25e>
            _free_file(file);
    1932:	4628      	mov	r0, r5
    1934:	4b14      	ldr	r3, [pc, #80]	; (1988 <fl_fopen+0x33c>)
    1936:	4798      	blx	r3
    1938:	e075      	b.n	1a26 <fl_fopen+0x3da>
        _free_file(file);
    193a:	4628      	mov	r0, r5
    193c:	4b12      	ldr	r3, [pc, #72]	; (1988 <fl_fopen+0x33c>)
    193e:	4798      	blx	r3
    1940:	e071      	b.n	1a26 <fl_fopen+0x3da>
        _free_file(file);
    1942:	4628      	mov	r0, r5
    1944:	4b10      	ldr	r3, [pc, #64]	; (1988 <fl_fopen+0x33c>)
    1946:	4798      	blx	r3
    1948:	e06d      	b.n	1a26 <fl_fopen+0x3da>
    194a:	bf00      	nop
    194c:	20000460 	.word	0x20000460
    1950:	00003481 	.word	0x00003481
    1954:	000015a9 	.word	0x000015a9
    1958:	00001471 	.word	0x00001471
    195c:	00001111 	.word	0x00001111
    1960:	00003305 	.word	0x00003305
    1964:	000023b1 	.word	0x000023b1
    1968:	00001159 	.word	0x00001159
    196c:	20000470 	.word	0x20000470
    1970:	00000e11 	.word	0x00000e11
    1974:	00000e15 	.word	0x00000e15
    1978:	00002981 	.word	0x00002981
    197c:	00002191 	.word	0x00002191
    1980:	00000f95 	.word	0x00000f95
    1984:	00002881 	.word	0x00002881
    1988:	0000142d 	.word	0x0000142d
    198c:	000011b1 	.word	0x000011b1
    1990:	000020bd 	.word	0x000020bd
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);
    1994:	f505 7207 	add.w	r2, r5, #540	; 0x21c
    1998:	ab07      	add	r3, sp, #28
    199a:	cb03      	ldmia	r3!, {r0, r1}
    199c:	f8c5 021c 	str.w	r0, [r5, #540]	; 0x21c
    19a0:	6051      	str	r1, [r2, #4]
    19a2:	8819      	ldrh	r1, [r3, #0]
    19a4:	789b      	ldrb	r3, [r3, #2]
    19a6:	8111      	strh	r1, [r2, #8]
    19a8:	7293      	strb	r3, [r2, #10]
        if (fatfs_sfn_exists(&_fs, file->parentcluster, (char*)file->shortfilename) == 0)
    19aa:	9205      	str	r2, [sp, #20]
    19ac:	6829      	ldr	r1, [r5, #0]
    19ae:	482f      	ldr	r0, [pc, #188]	; (1a6c <fl_fopen+0x420>)
    19b0:	4b2f      	ldr	r3, [pc, #188]	; (1a70 <fl_fopen+0x424>)
    19b2:	4798      	blx	r3
    19b4:	b108      	cbz	r0, 19ba <fl_fopen+0x36e>
        tailNum++;
    19b6:	3701      	adds	r7, #1
    19b8:	e78c      	b.n	18d4 <fl_fopen+0x288>
    if (tailNum == 9999)
    19ba:	f242 730f 	movw	r3, #9999	; 0x270f
    19be:	429f      	cmp	r7, r3
    19c0:	d0a1      	beq.n	1906 <fl_fopen+0x2ba>
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
    19c2:	6829      	ldr	r1, [r5, #0]
    19c4:	2300      	movs	r3, #0
    19c6:	9302      	str	r3, [sp, #8]
    19c8:	9301      	str	r3, [sp, #4]
    19ca:	686b      	ldr	r3, [r5, #4]
    19cc:	9300      	str	r3, [sp, #0]
    19ce:	9b05      	ldr	r3, [sp, #20]
    19d0:	4652      	mov	r2, sl
    19d2:	4826      	ldr	r0, [pc, #152]	; (1a6c <fl_fopen+0x420>)
    19d4:	4e27      	ldr	r6, [pc, #156]	; (1a74 <fl_fopen+0x428>)
    19d6:	47b0      	blx	r6
    19d8:	b1f0      	cbz	r0, 1a18 <fl_fopen+0x3cc>
    file->filelength = 0;
    19da:	2300      	movs	r3, #0
    19dc:	60eb      	str	r3, [r5, #12]
    file->bytenum = 0;
    19de:	60ab      	str	r3, [r5, #8]
    file->file_data_address = 0xFFFFFFFF;
    19e0:	f04f 32ff 	mov.w	r2, #4294967295
    19e4:	f8c5 2430 	str.w	r2, [r5, #1072]	; 0x430
    file->file_data_dirty = 0;
    19e8:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434
    file->filelength_changed = 0;
    19ec:	612b      	str	r3, [r5, #16]
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    19ee:	f8c5 2228 	str.w	r2, [r5, #552]	; 0x228
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
    19f2:	f8c5 222c 	str.w	r2, [r5, #556]	; 0x22c
    fatfs_cache_init(&_fs, file);
    19f6:	4e1d      	ldr	r6, [pc, #116]	; (1a6c <fl_fopen+0x420>)
    19f8:	4629      	mov	r1, r5
    19fa:	4630      	mov	r0, r6
    19fc:	4b1e      	ldr	r3, [pc, #120]	; (1a78 <fl_fopen+0x42c>)
    19fe:	4798      	blx	r3
    fatfs_fat_purge(&_fs);
    1a00:	4630      	mov	r0, r6
    1a02:	4b1e      	ldr	r3, [pc, #120]	; (1a7c <fl_fopen+0x430>)
    1a04:	4798      	blx	r3
    if (!(flags & FILE_READ))
    1a06:	f1b9 0f00 	cmp.w	r9, #0
    1a0a:	d116      	bne.n	1a3a <fl_fopen+0x3ee>
        if ((flags & FILE_CREATE) && !file)
    1a0c:	b9ad      	cbnz	r5, 1a3a <fl_fopen+0x3ee>
            if (flags & (FILE_WRITE | FILE_APPEND))
    1a0e:	f014 0f06 	tst.w	r4, #6
    1a12:	d10d      	bne.n	1a30 <fl_fopen+0x3e4>
    1a14:	2500      	movs	r5, #0
    1a16:	e012      	b.n	1a3e <fl_fopen+0x3f2>
        fatfs_free_cluster_chain(&_fs, file->startcluster);
    1a18:	6869      	ldr	r1, [r5, #4]
    1a1a:	4814      	ldr	r0, [pc, #80]	; (1a6c <fl_fopen+0x420>)
    1a1c:	4b18      	ldr	r3, [pc, #96]	; (1a80 <fl_fopen+0x434>)
    1a1e:	4798      	blx	r3
        _free_file(file);
    1a20:	4628      	mov	r0, r5
    1a22:	4b18      	ldr	r3, [pc, #96]	; (1a84 <fl_fopen+0x438>)
    1a24:	4798      	blx	r3
    if (!(flags & FILE_READ))
    1a26:	f1b9 0f00 	cmp.w	r9, #0
    1a2a:	d0f0      	beq.n	1a0e <fl_fopen+0x3c2>
    1a2c:	2500      	movs	r5, #0
    1a2e:	e003      	b.n	1a38 <fl_fopen+0x3ec>
                file = _open_file(path);
    1a30:	4640      	mov	r0, r8
    1a32:	4b15      	ldr	r3, [pc, #84]	; (1a88 <fl_fopen+0x43c>)
    1a34:	4798      	blx	r3
    1a36:	4605      	mov	r5, r0
    if (file)
    1a38:	b10d      	cbz	r5, 1a3e <fl_fopen+0x3f2>
        file->flags = flags;
    1a3a:	f885 4438 	strb.w	r4, [r5, #1080]	; 0x438
    FL_UNLOCK(&_fs);
    1a3e:	4b13      	ldr	r3, [pc, #76]	; (1a8c <fl_fopen+0x440>)
    1a40:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1a42:	b153      	cbz	r3, 1a5a <fl_fopen+0x40e>
    1a44:	4798      	blx	r3
    1a46:	4628      	mov	r0, r5
}
    1a48:	b013      	add	sp, #76	; 0x4c
    1a4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return NULL;
    1a4e:	2000      	movs	r0, #0
    1a50:	e7fa      	b.n	1a48 <fl_fopen+0x3fc>
        return NULL;
    1a52:	2000      	movs	r0, #0
    1a54:	e7f8      	b.n	1a48 <fl_fopen+0x3fc>
    1a56:	2000      	movs	r0, #0
    1a58:	e7f6      	b.n	1a48 <fl_fopen+0x3fc>
    1a5a:	4628      	mov	r0, r5
    1a5c:	e7f4      	b.n	1a48 <fl_fopen+0x3fc>
    if (!(flags & FILE_READ))
    1a5e:	2500      	movs	r5, #0
    1a60:	f1b9 0f00 	cmp.w	r9, #0
    1a64:	d0d2      	beq.n	1a0c <fl_fopen+0x3c0>
    1a66:	2500      	movs	r5, #0
    1a68:	e7e9      	b.n	1a3e <fl_fopen+0x3f2>
    1a6a:	bf00      	nop
    1a6c:	20000470 	.word	0x20000470
    1a70:	00000f95 	.word	0x00000f95
    1a74:	00002a15 	.word	0x00002a15
    1a78:	000010c9 	.word	0x000010c9
    1a7c:	00002639 	.word	0x00002639
    1a80:	00002881 	.word	0x00002881
    1a84:	0000142d 	.word	0x0000142d
    1a88:	00001471 	.word	0x00001471
    1a8c:	20000460 	.word	0x20000460

00001a90 <fl_fflush>:
#endif
//-----------------------------------------------------------------------------
// fl_fflush: Flush un-written data to the file
//-----------------------------------------------------------------------------
int fl_fflush(void *f)
{
    1a90:	b538      	push	{r3, r4, r5, lr}
    1a92:	4604      	mov	r4, r0
#if FATFS_INC_WRITE_SUPPORT
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
    1a94:	4b11      	ldr	r3, [pc, #68]	; (1adc <fl_fflush+0x4c>)
    1a96:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1a9a:	b16b      	cbz	r3, 1ab8 <fl_fflush+0x28>

    if (file)
    1a9c:	b154      	cbz	r4, 1ab4 <fl_fflush+0x24>
    {
        FL_LOCK(&_fs);
    1a9e:	4b0f      	ldr	r3, [pc, #60]	; (1adc <fl_fflush+0x4c>)
    1aa0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1aa2:	b103      	cbz	r3, 1aa6 <fl_fflush+0x16>
    1aa4:	4798      	blx	r3

        // If some write data still in buffer
        if (file->file_data_dirty)
    1aa6:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    1aaa:	b943      	cbnz	r3, 1abe <fl_fflush+0x2e>
            // Write back current sector before loading next
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
                file->file_data_dirty = 0;
        }

        FL_UNLOCK(&_fs);
    1aac:	4b0b      	ldr	r3, [pc, #44]	; (1adc <fl_fflush+0x4c>)
    1aae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1ab0:	b103      	cbz	r3, 1ab4 <fl_fflush+0x24>
    1ab2:	4798      	blx	r3
    }
#endif
    return 0;
}
    1ab4:	2000      	movs	r0, #0
    1ab6:	bd38      	pop	{r3, r4, r5, pc}
    CHECK_FL_INIT();
    1ab8:	4b09      	ldr	r3, [pc, #36]	; (1ae0 <fl_fflush+0x50>)
    1aba:	4798      	blx	r3
    1abc:	e7ee      	b.n	1a9c <fl_fflush+0xc>
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
    1abe:	2301      	movs	r3, #1
    1ac0:	f504 720c 	add.w	r2, r4, #560	; 0x230
    1ac4:	f8d4 1430 	ldr.w	r1, [r4, #1072]	; 0x430
    1ac8:	4620      	mov	r0, r4
    1aca:	4d06      	ldr	r5, [pc, #24]	; (1ae4 <fl_fflush+0x54>)
    1acc:	47a8      	blx	r5
    1ace:	2800      	cmp	r0, #0
    1ad0:	d0ec      	beq.n	1aac <fl_fflush+0x1c>
                file->file_data_dirty = 0;
    1ad2:	2300      	movs	r3, #0
    1ad4:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
    1ad8:	e7e8      	b.n	1aac <fl_fflush+0x1c>
    1ada:	bf00      	nop
    1adc:	20000460 	.word	0x20000460
    1ae0:	000015a9 	.word	0x000015a9
    1ae4:	00001245 	.word	0x00001245

00001ae8 <fl_fclose>:
//-----------------------------------------------------------------------------
// fl_fclose: Close an open file
//-----------------------------------------------------------------------------
void fl_fclose(void *f)
{
    1ae8:	b538      	push	{r3, r4, r5, lr}
    1aea:	4604      	mov	r4, r0
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
    1aec:	4b17      	ldr	r3, [pc, #92]	; (1b4c <fl_fclose+0x64>)
    1aee:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1af2:	b303      	cbz	r3, 1b36 <fl_fclose+0x4e>

    if (file)
    1af4:	b1f4      	cbz	r4, 1b34 <fl_fclose+0x4c>
    {
        FL_LOCK(&_fs);
    1af6:	4b15      	ldr	r3, [pc, #84]	; (1b4c <fl_fclose+0x64>)
    1af8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1afa:	b103      	cbz	r3, 1afe <fl_fclose+0x16>
    1afc:	4798      	blx	r3

        // Flush un-written data to file
        fl_fflush(f);
    1afe:	4620      	mov	r0, r4
    1b00:	4b13      	ldr	r3, [pc, #76]	; (1b50 <fl_fclose+0x68>)
    1b02:	4798      	blx	r3

        // File size changed?
        if (file->filelength_changed)
    1b04:	6923      	ldr	r3, [r4, #16]
    1b06:	b9cb      	cbnz	r3, 1b3c <fl_fclose+0x54>
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
    1b08:	2300      	movs	r3, #0
    1b0a:	60a3      	str	r3, [r4, #8]
        file->filelength = 0;
    1b0c:	60e3      	str	r3, [r4, #12]
        file->startcluster = 0;
    1b0e:	6063      	str	r3, [r4, #4]
        file->file_data_address = 0xFFFFFFFF;
    1b10:	f04f 32ff 	mov.w	r2, #4294967295
    1b14:	f8c4 2430 	str.w	r2, [r4, #1072]	; 0x430
        file->file_data_dirty = 0;
    1b18:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
        file->filelength_changed = 0;
    1b1c:	6123      	str	r3, [r4, #16]

        // Free file handle
        _free_file(file);
    1b1e:	4620      	mov	r0, r4
    1b20:	4b0c      	ldr	r3, [pc, #48]	; (1b54 <fl_fclose+0x6c>)
    1b22:	4798      	blx	r3

        fatfs_fat_purge(&_fs);
    1b24:	4c09      	ldr	r4, [pc, #36]	; (1b4c <fl_fclose+0x64>)
    1b26:	f104 0010 	add.w	r0, r4, #16
    1b2a:	4b0b      	ldr	r3, [pc, #44]	; (1b58 <fl_fclose+0x70>)
    1b2c:	4798      	blx	r3

        FL_UNLOCK(&_fs);
    1b2e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    1b30:	b103      	cbz	r3, 1b34 <fl_fclose+0x4c>
    1b32:	4798      	blx	r3
    1b34:	bd38      	pop	{r3, r4, r5, pc}
    CHECK_FL_INIT();
    1b36:	4b09      	ldr	r3, [pc, #36]	; (1b5c <fl_fclose+0x74>)
    1b38:	4798      	blx	r3
    1b3a:	e7db      	b.n	1af4 <fl_fclose+0xc>
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
    1b3c:	68e3      	ldr	r3, [r4, #12]
    1b3e:	f504 7207 	add.w	r2, r4, #540	; 0x21c
    1b42:	6821      	ldr	r1, [r4, #0]
    1b44:	4806      	ldr	r0, [pc, #24]	; (1b60 <fl_fclose+0x78>)
    1b46:	4d07      	ldr	r5, [pc, #28]	; (1b64 <fl_fclose+0x7c>)
    1b48:	47a8      	blx	r5
    1b4a:	e7dd      	b.n	1b08 <fl_fclose+0x20>
    1b4c:	20000460 	.word	0x20000460
    1b50:	00001a91 	.word	0x00001a91
    1b54:	0000142d 	.word	0x0000142d
    1b58:	00002639 	.word	0x00002639
    1b5c:	000015a9 	.word	0x000015a9
    1b60:	20000470 	.word	0x20000470
    1b64:	0000101d 	.word	0x0000101d

00001b68 <fl_fread>:
}
//-----------------------------------------------------------------------------
// fl_fread: Read a block of data from the file
//-----------------------------------------------------------------------------
int fl_fread(void * buffer, int size, int length, void *f )
{
    1b68:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1b6c:	4682      	mov	sl, r0
    1b6e:	461d      	mov	r5, r3
    uint32 sector;
    uint32 offset;
    int copyCount;
    int count = size * length;
    1b70:	fb02 f601 	mul.w	r6, r2, r1
    int bytesRead = 0;

    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
    1b74:	4b3f      	ldr	r3, [pc, #252]	; (1c74 <fl_fread+0x10c>)
    1b76:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1b7a:	b1fb      	cbz	r3, 1bbc <fl_fread+0x54>

    if (buffer==NULL || file==NULL)
    1b7c:	f1ba 0f00 	cmp.w	sl, #0
    1b80:	d068      	beq.n	1c54 <fl_fread+0xec>
    1b82:	2d00      	cmp	r5, #0
    1b84:	d069      	beq.n	1c5a <fl_fread+0xf2>
        return -1;

    // No read permissions
    if (!(file->flags & FILE_READ))
    1b86:	f895 3438 	ldrb.w	r3, [r5, #1080]	; 0x438
    1b8a:	f013 0f01 	tst.w	r3, #1
    1b8e:	d067      	beq.n	1c60 <fl_fread+0xf8>
        return -1;

    // Nothing to be done
    if (!count)
    1b90:	2e00      	cmp	r6, #0
    1b92:	d067      	beq.n	1c64 <fl_fread+0xfc>
        return 0;

    // Check if read starts past end of file
    if (file->bytenum >= file->filelength)
    1b94:	68ab      	ldr	r3, [r5, #8]
    1b96:	68ea      	ldr	r2, [r5, #12]
    1b98:	4293      	cmp	r3, r2
    1b9a:	d266      	bcs.n	1c6a <fl_fread+0x102>
        return -1;

    // Limit to file size
    if ( (file->bytenum + count) > file->filelength )
    1b9c:	18f1      	adds	r1, r6, r3
    1b9e:	428a      	cmp	r2, r1
        count = file->filelength - file->bytenum;
    1ba0:	bf34      	ite	cc
    1ba2:	eba2 0903 	subcc.w	r9, r2, r3
    int count = size * length;
    1ba6:	46b1      	movcs	r9, r6

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;
    1ba8:	0a5f      	lsrs	r7, r3, #9

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
    1baa:	f3c3 0808 	ubfx	r8, r3, #0, #9

    while (bytesRead < count)
    1bae:	f1b9 0f00 	cmp.w	r9, #0
    1bb2:	dd5d      	ble.n	1c70 <fl_fread+0x108>
    1bb4:	2600      	movs	r6, #0
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
    1bb6:	f8df b0cc 	ldr.w	fp, [pc, #204]	; 1c84 <fl_fread+0x11c>
    1bba:	e02f      	b.n	1c1c <fl_fread+0xb4>
    CHECK_FL_INIT();
    1bbc:	4b2e      	ldr	r3, [pc, #184]	; (1c78 <fl_fread+0x110>)
    1bbe:	4798      	blx	r3
    1bc0:	e7dc      	b.n	1b7c <fl_fread+0x14>
            if (file->file_data_address != sector)
    1bc2:	f8d5 3430 	ldr.w	r3, [r5, #1072]	; 0x430
    1bc6:	42bb      	cmp	r3, r7
    1bc8:	d011      	beq.n	1bee <fl_fread+0x86>
                if (file->file_data_dirty)
    1bca:	f8d5 3434 	ldr.w	r3, [r5, #1076]	; 0x434
    1bce:	2b00      	cmp	r3, #0
    1bd0:	d13c      	bne.n	1c4c <fl_fread+0xe4>
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
    1bd2:	2301      	movs	r3, #1
    1bd4:	f505 720c 	add.w	r2, r5, #560	; 0x230
    1bd8:	4639      	mov	r1, r7
    1bda:	4628      	mov	r0, r5
    1bdc:	4c27      	ldr	r4, [pc, #156]	; (1c7c <fl_fread+0x114>)
    1bde:	47a0      	blx	r4
    1be0:	2800      	cmp	r0, #0
    1be2:	d03f      	beq.n	1c64 <fl_fread+0xfc>
                file->file_data_address = sector;
    1be4:	f8c5 7430 	str.w	r7, [r5, #1072]	; 0x430
                file->file_data_dirty = 0;
    1be8:	2300      	movs	r3, #0
    1bea:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434
            copyCount = FAT_SECTOR_SIZE - offset;
    1bee:	f5c8 7300 	rsb	r3, r8, #512	; 0x200
            if (copyCount > (count - bytesRead))
    1bf2:	eba9 0406 	sub.w	r4, r9, r6
    1bf6:	429c      	cmp	r4, r3
    1bf8:	bfa8      	it	ge
    1bfa:	461c      	movge	r4, r3
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
    1bfc:	f505 710c 	add.w	r1, r5, #560	; 0x230
    1c00:	4622      	mov	r2, r4
    1c02:	4441      	add	r1, r8
    1c04:	eb0a 0006 	add.w	r0, sl, r6
    1c08:	47d8      	blx	fp

            // Move onto next sector and reset copy offset
            sector++;
    1c0a:	3701      	adds	r7, #1
            offset = 0;
        }

        // Increase total read count
        bytesRead += copyCount;
    1c0c:	4426      	add	r6, r4

        // Increment file pointer
        file->bytenum += copyCount;
    1c0e:	68ab      	ldr	r3, [r5, #8]
    1c10:	441c      	add	r4, r3
    1c12:	60ac      	str	r4, [r5, #8]
    1c14:	f04f 0800 	mov.w	r8, #0
    while (bytesRead < count)
    1c18:	45b1      	cmp	r9, r6
    1c1a:	dd23      	ble.n	1c64 <fl_fread+0xfc>
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
    1c1c:	f1b8 0f00 	cmp.w	r8, #0
    1c20:	d1cf      	bne.n	1bc2 <fl_fread+0x5a>
    1c22:	eba9 0206 	sub.w	r2, r9, r6
    1c26:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    1c2a:	dbca      	blt.n	1bc2 <fl_fread+0x5a>
            uint32 sectorsRead = _read_sectors(file, sector, (uint8*)((uint8*)buffer + bytesRead), (count - bytesRead) / FAT_SECTOR_SIZE);
    1c2c:	4613      	mov	r3, r2
    1c2e:	2a00      	cmp	r2, #0
    1c30:	bfb8      	it	lt
    1c32:	f202 13ff 	addwlt	r3, r2, #511	; 0x1ff
    1c36:	125b      	asrs	r3, r3, #9
    1c38:	eb0a 0206 	add.w	r2, sl, r6
    1c3c:	4639      	mov	r1, r7
    1c3e:	4628      	mov	r0, r5
    1c40:	4c0e      	ldr	r4, [pc, #56]	; (1c7c <fl_fread+0x114>)
    1c42:	47a0      	blx	r4
            if (sectorsRead)
    1c44:	b170      	cbz	r0, 1c64 <fl_fread+0xfc>
                copyCount = FAT_SECTOR_SIZE * sectorsRead;
    1c46:	0244      	lsls	r4, r0, #9
                sector+= sectorsRead;
    1c48:	4407      	add	r7, r0
        {
    1c4a:	e7df      	b.n	1c0c <fl_fread+0xa4>
                    fl_fflush(file);
    1c4c:	4628      	mov	r0, r5
    1c4e:	4b0c      	ldr	r3, [pc, #48]	; (1c80 <fl_fread+0x118>)
    1c50:	4798      	blx	r3
    1c52:	e7be      	b.n	1bd2 <fl_fread+0x6a>
        return -1;
    1c54:	f04f 36ff 	mov.w	r6, #4294967295
    1c58:	e004      	b.n	1c64 <fl_fread+0xfc>
    1c5a:	f04f 36ff 	mov.w	r6, #4294967295
    1c5e:	e001      	b.n	1c64 <fl_fread+0xfc>
        return -1;
    1c60:	f04f 36ff 	mov.w	r6, #4294967295
    }

    return bytesRead;
}
    1c64:	4630      	mov	r0, r6
    1c66:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return -1;
    1c6a:	f04f 36ff 	mov.w	r6, #4294967295
    1c6e:	e7f9      	b.n	1c64 <fl_fread+0xfc>
    int bytesRead = 0;
    1c70:	2600      	movs	r6, #0
    1c72:	e7f7      	b.n	1c64 <fl_fread+0xfc>
    1c74:	20000460 	.word	0x20000460
    1c78:	000015a9 	.word	0x000015a9
    1c7c:	00001351 	.word	0x00001351
    1c80:	00001a91 	.word	0x00001a91
    1c84:	000031d1 	.word	0x000031d1

00001c88 <fl_fwrite>:
//-----------------------------------------------------------------------------
// fl_fwrite: Write a block of data to the stream
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fl_fwrite(const void * data, int size, int count, void *f )
{
    1c88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1c8c:	b085      	sub	sp, #20
    1c8e:	4682      	mov	sl, r0
    1c90:	460c      	mov	r4, r1
    1c92:	4616      	mov	r6, r2
    1c94:	461d      	mov	r5, r3
    uint8 *buffer = (uint8 *)data;
    uint32 bytesWritten = 0;
    uint32 copyCount;

    // If first call to library, initialise
    CHECK_FL_INIT();
    1c96:	4b60      	ldr	r3, [pc, #384]	; (1e18 <fl_fwrite+0x190>)
    1c98:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1c9c:	b1ab      	cbz	r3, 1cca <fl_fwrite+0x42>

    if (!file)
    1c9e:	2d00      	cmp	r5, #0
    1ca0:	f000 80b1 	beq.w	1e06 <fl_fwrite+0x17e>
        return -1;

    FL_LOCK(&_fs);
    1ca4:	4b5c      	ldr	r3, [pc, #368]	; (1e18 <fl_fwrite+0x190>)
    1ca6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1ca8:	b103      	cbz	r3, 1cac <fl_fwrite+0x24>
    1caa:	4798      	blx	r3

    // No write permissions
    if (!(file->flags & FILE_WRITE))
    1cac:	f895 3438 	ldrb.w	r3, [r5, #1080]	; 0x438
    1cb0:	f013 0f02 	tst.w	r3, #2
    1cb4:	d10c      	bne.n	1cd0 <fl_fwrite+0x48>
    {
        FL_UNLOCK(&_fs);
    1cb6:	4b58      	ldr	r3, [pc, #352]	; (1e18 <fl_fwrite+0x190>)
    1cb8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1cba:	2b00      	cmp	r3, #0
    1cbc:	f000 80a7 	beq.w	1e0e <fl_fwrite+0x186>
    1cc0:	4798      	blx	r3
        return -1;
    1cc2:	f04f 33ff 	mov.w	r3, #4294967295
    1cc6:	9303      	str	r3, [sp, #12]
    1cc8:	e08e      	b.n	1de8 <fl_fwrite+0x160>
    CHECK_FL_INIT();
    1cca:	4b54      	ldr	r3, [pc, #336]	; (1e1c <fl_fwrite+0x194>)
    1ccc:	4798      	blx	r3
    1cce:	e7e6      	b.n	1c9e <fl_fwrite+0x16>
    uint32 length = (size*count);
    1cd0:	fb06 f204 	mul.w	r2, r6, r4
    1cd4:	9203      	str	r2, [sp, #12]
    1cd6:	4691      	mov	r9, r2
    }

    // Append writes to end of file
    if (file->flags & FILE_APPEND)
    1cd8:	f013 0f04 	tst.w	r3, #4
    1cdc:	d006      	beq.n	1cec <fl_fwrite+0x64>
        file->bytenum = file->filelength;
    1cde:	68eb      	ldr	r3, [r5, #12]
    1ce0:	60ab      	str	r3, [r5, #8]
    // Else write to current position

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;
    1ce2:	0a5f      	lsrs	r7, r3, #9

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
    1ce4:	f3c3 0808 	ubfx	r8, r3, #0, #9

    while (bytesWritten < length)
    1ce8:	b93a      	cbnz	r2, 1cfa <fl_fwrite+0x72>
    1cea:	e079      	b.n	1de0 <fl_fwrite+0x158>
    sector = file->bytenum / FAT_SECTOR_SIZE;
    1cec:	68ab      	ldr	r3, [r5, #8]
    1cee:	0a5f      	lsrs	r7, r3, #9
    offset = file->bytenum % FAT_SECTOR_SIZE;
    1cf0:	f3c3 0808 	ubfx	r8, r3, #0, #9
    while (bytesWritten < length)
    1cf4:	9b03      	ldr	r3, [sp, #12]
    1cf6:	2b00      	cmp	r3, #0
    1cf8:	d06b      	beq.n	1dd2 <fl_fwrite+0x14a>
{
    1cfa:	2600      	movs	r6, #0
                file->file_data_address = sector;
                file->file_data_dirty = 0;
            }

            // Copy from application buffer into sector buffer
            memcpy((uint8*)(file->file_data_sector + offset), (uint8*)(buffer + bytesWritten), copyCount);
    1cfc:	f8df b130 	ldr.w	fp, [pc, #304]	; 1e30 <fl_fwrite+0x1a8>
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);
    1d00:	9701      	str	r7, [sp, #4]
    1d02:	e03c      	b.n	1d7e <fl_fwrite+0xf6>
                    fl_fflush(file);
    1d04:	4628      	mov	r0, r5
    1d06:	4b46      	ldr	r3, [pc, #280]	; (1e20 <fl_fwrite+0x198>)
    1d08:	4798      	blx	r3
    1d0a:	e049      	b.n	1da0 <fl_fwrite+0x118>
            copyCount = FAT_SECTOR_SIZE - offset;
    1d0c:	f5c8 7400 	rsb	r4, r8, #512	; 0x200
            if (copyCount > (length - bytesWritten))
    1d10:	eba9 0306 	sub.w	r3, r9, r6
    1d14:	429c      	cmp	r4, r3
    1d16:	bf28      	it	cs
    1d18:	461c      	movcs	r4, r3
            if (file->file_data_address != sector)
    1d1a:	f8d5 3430 	ldr.w	r3, [r5, #1072]	; 0x430
    1d1e:	9a01      	ldr	r2, [sp, #4]
    1d20:	4293      	cmp	r3, r2
    1d22:	d017      	beq.n	1d54 <fl_fwrite+0xcc>
                if (file->file_data_dirty)
    1d24:	f8d5 3434 	ldr.w	r3, [r5, #1076]	; 0x434
    1d28:	2b00      	cmp	r3, #0
    1d2a:	d161      	bne.n	1df0 <fl_fwrite+0x168>
                if (copyCount != FAT_SECTOR_SIZE)
    1d2c:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    1d30:	d00a      	beq.n	1d48 <fl_fwrite+0xc0>
                    if (!_read_sectors(file, sector, file->file_data_sector, 1))
    1d32:	f505 730c 	add.w	r3, r5, #560	; 0x230
    1d36:	461a      	mov	r2, r3
    1d38:	9302      	str	r3, [sp, #8]
    1d3a:	2301      	movs	r3, #1
    1d3c:	9901      	ldr	r1, [sp, #4]
    1d3e:	4628      	mov	r0, r5
    1d40:	4f38      	ldr	r7, [pc, #224]	; (1e24 <fl_fwrite+0x19c>)
    1d42:	47b8      	blx	r7
    1d44:	2800      	cmp	r0, #0
    1d46:	d057      	beq.n	1df8 <fl_fwrite+0x170>
                file->file_data_address = sector;
    1d48:	9b01      	ldr	r3, [sp, #4]
    1d4a:	f8c5 3430 	str.w	r3, [r5, #1072]	; 0x430
                file->file_data_dirty = 0;
    1d4e:	2300      	movs	r3, #0
    1d50:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434
            memcpy((uint8*)(file->file_data_sector + offset), (uint8*)(buffer + bytesWritten), copyCount);
    1d54:	f505 700c 	add.w	r0, r5, #560	; 0x230
    1d58:	4622      	mov	r2, r4
    1d5a:	eb0a 0106 	add.w	r1, sl, r6
    1d5e:	4440      	add	r0, r8
    1d60:	47d8      	blx	fp

            // Mark buffer as dirty
            file->file_data_dirty = 1;
    1d62:	2301      	movs	r3, #1
    1d64:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434

            // Increase total read count
            bytesWritten += copyCount;
    1d68:	4426      	add	r6, r4

            // Increment file pointer
            file->bytenum += copyCount;
    1d6a:	68ab      	ldr	r3, [r5, #8]
    1d6c:	441c      	add	r4, r3
    1d6e:	60ac      	str	r4, [r5, #8]

            // Move onto next sector and reset copy offset
            sector++;
    1d70:	9b01      	ldr	r3, [sp, #4]
    1d72:	3301      	adds	r3, #1
    1d74:	9301      	str	r3, [sp, #4]
    1d76:	f04f 0800 	mov.w	r8, #0
    while (bytesWritten < length)
    1d7a:	454e      	cmp	r6, r9
    1d7c:	d229      	bcs.n	1dd2 <fl_fwrite+0x14a>
        if ((offset == 0) && ((length - bytesWritten) >= FAT_SECTOR_SIZE))
    1d7e:	f1b8 0f00 	cmp.w	r8, #0
    1d82:	d1c3      	bne.n	1d0c <fl_fwrite+0x84>
    1d84:	eba9 0406 	sub.w	r4, r9, r6
    1d88:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    1d8c:	d3be      	bcc.n	1d0c <fl_fwrite+0x84>
            if (file->file_data_address != 0xFFFFFFFF)
    1d8e:	f8d5 3430 	ldr.w	r3, [r5, #1072]	; 0x430
    1d92:	f1b3 3fff 	cmp.w	r3, #4294967295
    1d96:	d00a      	beq.n	1dae <fl_fwrite+0x126>
                if (file->file_data_dirty)
    1d98:	f8d5 3434 	ldr.w	r3, [r5, #1076]	; 0x434
    1d9c:	2b00      	cmp	r3, #0
    1d9e:	d1b1      	bne.n	1d04 <fl_fwrite+0x7c>
                file->file_data_address = 0xFFFFFFFF;
    1da0:	f04f 33ff 	mov.w	r3, #4294967295
    1da4:	f8c5 3430 	str.w	r3, [r5, #1072]	; 0x430
                file->file_data_dirty = 0;
    1da8:	2300      	movs	r3, #0
    1daa:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434
            sectorsWrote = _write_sectors(file, sector, (uint8*)(buffer + bytesWritten), (length - bytesWritten) / FAT_SECTOR_SIZE);
    1dae:	0a63      	lsrs	r3, r4, #9
    1db0:	eb0a 0206 	add.w	r2, sl, r6
    1db4:	9f01      	ldr	r7, [sp, #4]
    1db6:	4639      	mov	r1, r7
    1db8:	4628      	mov	r0, r5
    1dba:	4c1b      	ldr	r4, [pc, #108]	; (1e28 <fl_fwrite+0x1a0>)
    1dbc:	47a0      	blx	r4
            copyCount = FAT_SECTOR_SIZE * sectorsWrote;
    1dbe:	0242      	lsls	r2, r0, #9
            bytesWritten += copyCount;
    1dc0:	4416      	add	r6, r2
            file->bytenum += copyCount;
    1dc2:	68ab      	ldr	r3, [r5, #8]
    1dc4:	4413      	add	r3, r2
    1dc6:	60ab      	str	r3, [r5, #8]
            sector+= sectorsWrote;
    1dc8:	463b      	mov	r3, r7
    1dca:	4403      	add	r3, r0
    1dcc:	9301      	str	r3, [sp, #4]
            if (!sectorsWrote)
    1dce:	2800      	cmp	r0, #0
    1dd0:	d1d1      	bne.n	1d76 <fl_fwrite+0xee>
            offset = 0;
        }
    }

    // Write increased extent of the file?
    if (file->bytenum > file->filelength)
    1dd2:	68ab      	ldr	r3, [r5, #8]
    1dd4:	68ea      	ldr	r2, [r5, #12]
    1dd6:	4293      	cmp	r3, r2
    1dd8:	d902      	bls.n	1de0 <fl_fwrite+0x158>
    {
        // Increase file size to new point
        file->filelength = file->bytenum;
    1dda:	60eb      	str	r3, [r5, #12]

        // We are changing the file length and this
        // will need to be writen back at some point
        file->filelength_changed = 1;
    1ddc:	2301      	movs	r3, #1
    1dde:	612b      	str	r3, [r5, #16]
    // If time & date support is enabled, always force directory entry to be
    // written in-order to update file modify / access time & date.
    file->filelength_changed = 1;
#endif

    FL_UNLOCK(&_fs);
    1de0:	4b0d      	ldr	r3, [pc, #52]	; (1e18 <fl_fwrite+0x190>)
    1de2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1de4:	b103      	cbz	r3, 1de8 <fl_fwrite+0x160>
    1de6:	4798      	blx	r3

    return (size*count);
}
    1de8:	9803      	ldr	r0, [sp, #12]
    1dea:	b005      	add	sp, #20
    1dec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    fl_fflush(file);
    1df0:	4628      	mov	r0, r5
    1df2:	4b0b      	ldr	r3, [pc, #44]	; (1e20 <fl_fwrite+0x198>)
    1df4:	4798      	blx	r3
    1df6:	e799      	b.n	1d2c <fl_fwrite+0xa4>
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);
    1df8:	f44f 7200 	mov.w	r2, #512	; 0x200
    1dfc:	2100      	movs	r1, #0
    1dfe:	9802      	ldr	r0, [sp, #8]
    1e00:	4b0a      	ldr	r3, [pc, #40]	; (1e2c <fl_fwrite+0x1a4>)
    1e02:	4798      	blx	r3
    1e04:	e7a0      	b.n	1d48 <fl_fwrite+0xc0>
        return -1;
    1e06:	f04f 33ff 	mov.w	r3, #4294967295
    1e0a:	9303      	str	r3, [sp, #12]
    1e0c:	e7ec      	b.n	1de8 <fl_fwrite+0x160>
        return -1;
    1e0e:	f04f 33ff 	mov.w	r3, #4294967295
    1e12:	9303      	str	r3, [sp, #12]
    1e14:	e7e8      	b.n	1de8 <fl_fwrite+0x160>
    1e16:	bf00      	nop
    1e18:	20000460 	.word	0x20000460
    1e1c:	000015a9 	.word	0x000015a9
    1e20:	00001a91 	.word	0x00001a91
    1e24:	00001351 	.word	0x00001351
    1e28:	00001245 	.word	0x00001245
    1e2c:	00003305 	.word	0x00003305
    1e30:	000031d1 	.word	0x000031d1

00001e34 <fatfs_lfn_cache_init>:
//-----------------------------------------------------------------------------
void fatfs_lfn_cache_init(struct lfn_cache *lfn, int wipeTable)
{
    int i = 0;

    lfn->no_of_strings = 0;
    1e34:	2300      	movs	r3, #0
    1e36:	f880 3105 	strb.w	r3, [r0, #261]	; 0x105

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
    1e3a:	b151      	cbz	r1, 1e52 <fatfs_lfn_cache_init+0x1e>
    1e3c:	4603      	mov	r3, r0
    1e3e:	f500 7082 	add.w	r0, r0, #260	; 0x104
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
            memset(lfn->String[i], 0x00, MAX_LFN_ENTRY_LENGTH);
    1e42:	2200      	movs	r2, #0
    1e44:	601a      	str	r2, [r3, #0]
    1e46:	605a      	str	r2, [r3, #4]
    1e48:	609a      	str	r2, [r3, #8]
    1e4a:	731a      	strb	r2, [r3, #12]
    1e4c:	330d      	adds	r3, #13
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
    1e4e:	4283      	cmp	r3, r0
    1e50:	d1f8      	bne.n	1e44 <fatfs_lfn_cache_init+0x10>
    1e52:	4770      	bx	lr

00001e54 <fatfs_lfn_cache_entry>:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;
    1e54:	780b      	ldrb	r3, [r1, #0]
    1e56:	f003 031f 	and.w	r3, r3, #31
    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
        return ;

    // This is an error condition
    if (LFNIndex == 0)
    1e5a:	1e5a      	subs	r2, r3, #1
    1e5c:	b2d2      	uxtb	r2, r2
    1e5e:	2a13      	cmp	r2, #19
    1e60:	d830      	bhi.n	1ec4 <fatfs_lfn_cache_entry+0x70>
{
    1e62:	b410      	push	{r4}
        return ;

    if (lfn->no_of_strings == 0)
    1e64:	f890 2105 	ldrb.w	r2, [r0, #261]	; 0x105
    1e68:	b90a      	cbnz	r2, 1e6e <fatfs_lfn_cache_entry+0x1a>
        lfn->no_of_strings = LFNIndex;
    1e6a:	f880 3105 	strb.w	r3, [r0, #261]	; 0x105

    lfn->String[LFNIndex-1][0] = entryBuffer[1];
    1e6e:	3b01      	subs	r3, #1
    1e70:	784c      	ldrb	r4, [r1, #1]
    1e72:	eb03 0243 	add.w	r2, r3, r3, lsl #1
    1e76:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    1e7a:	1883      	adds	r3, r0, r2
    1e7c:	5484      	strb	r4, [r0, r2]
    lfn->String[LFNIndex-1][1] = entryBuffer[3];
    1e7e:	78cc      	ldrb	r4, [r1, #3]
    1e80:	705c      	strb	r4, [r3, #1]
    lfn->String[LFNIndex-1][2] = entryBuffer[5];
    1e82:	794c      	ldrb	r4, [r1, #5]
    1e84:	709c      	strb	r4, [r3, #2]
    lfn->String[LFNIndex-1][3] = entryBuffer[7];
    1e86:	79cc      	ldrb	r4, [r1, #7]
    1e88:	70dc      	strb	r4, [r3, #3]
    lfn->String[LFNIndex-1][4] = entryBuffer[9];
    1e8a:	7a4c      	ldrb	r4, [r1, #9]
    1e8c:	711c      	strb	r4, [r3, #4]
    lfn->String[LFNIndex-1][5] = entryBuffer[0x0E];
    1e8e:	7b8c      	ldrb	r4, [r1, #14]
    1e90:	715c      	strb	r4, [r3, #5]
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
    1e92:	7c0c      	ldrb	r4, [r1, #16]
    1e94:	719c      	strb	r4, [r3, #6]
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    1e96:	7c8c      	ldrb	r4, [r1, #18]
    1e98:	71dc      	strb	r4, [r3, #7]
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    1e9a:	7d0c      	ldrb	r4, [r1, #20]
    1e9c:	721c      	strb	r4, [r3, #8]
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    1e9e:	7d8c      	ldrb	r4, [r1, #22]
    1ea0:	725c      	strb	r4, [r3, #9]
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];
    1ea2:	7e0c      	ldrb	r4, [r1, #24]
    1ea4:	729c      	strb	r4, [r3, #10]
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    1ea6:	7f0c      	ldrb	r4, [r1, #28]
    1ea8:	72dc      	strb	r4, [r3, #11]
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
    1eaa:	7f89      	ldrb	r1, [r1, #30]
    1eac:	7319      	strb	r1, [r3, #12]
    1eae:	320d      	adds	r2, #13
    1eb0:	4410      	add	r0, r2

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF)
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
    1eb2:	2120      	movs	r1, #32
        if (lfn->String[LFNIndex-1][i]==0xFF)
    1eb4:	781a      	ldrb	r2, [r3, #0]
    1eb6:	2aff      	cmp	r2, #255	; 0xff
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
    1eb8:	bf08      	it	eq
    1eba:	7019      	strbeq	r1, [r3, #0]
    1ebc:	3301      	adds	r3, #1
    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
    1ebe:	4283      	cmp	r3, r0
    1ec0:	d1f8      	bne.n	1eb4 <fatfs_lfn_cache_entry+0x60>
}
    1ec2:	bc10      	pop	{r4}
    1ec4:	4770      	bx	lr

00001ec6 <fatfs_lfn_cache_get>:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
    1ec6:	f890 3105 	ldrb.w	r3, [r0, #261]	; 0x105
    1eca:	2b14      	cmp	r3, #20
    1ecc:	d003      	beq.n	1ed6 <fatfs_lfn_cache_get+0x10>
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
    1ece:	b933      	cbnz	r3, 1ede <fatfs_lfn_cache_get+0x18>
        lfn->String[lfn->no_of_strings][0] = '\0';
    else
        lfn->String[0][0] = '\0';
    1ed0:	2300      	movs	r3, #0
    1ed2:	7003      	strb	r3, [r0, #0]

    return (char*)&lfn->String[0][0];
}
    1ed4:	4770      	bx	lr
        lfn->Null = '\0';
    1ed6:	2300      	movs	r3, #0
    1ed8:	f880 3104 	strb.w	r3, [r0, #260]	; 0x104
    1edc:	4770      	bx	lr
        lfn->String[lfn->no_of_strings][0] = '\0';
    1ede:	eb03 0243 	add.w	r2, r3, r3, lsl #1
    1ee2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    1ee6:	2200      	movs	r2, #0
    1ee8:	54c2      	strb	r2, [r0, r3]
    1eea:	4770      	bx	lr

00001eec <fatfs_entry_lfn_text>:
// fatfs_entry_lfn_text: If LFN text entry found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_text(struct fat_dir_entry *entry)
{
    if ((entry->Attr & FILE_ATTR_LFN_TEXT) == FILE_ATTR_LFN_TEXT)
    1eec:	7ac0      	ldrb	r0, [r0, #11]
    1eee:	f000 000f 	and.w	r0, r0, #15
        return 1;
    else
        return 0;
}
    1ef2:	280f      	cmp	r0, #15
    1ef4:	bf14      	ite	ne
    1ef6:	2000      	movne	r0, #0
    1ef8:	2001      	moveq	r0, #1
    1efa:	4770      	bx	lr

00001efc <fatfs_entry_lfn_invalid>:
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  ||
    1efc:	7803      	ldrb	r3, [r0, #0]
    1efe:	b153      	cbz	r3, 1f16 <fatfs_entry_lfn_invalid+0x1a>
    1f00:	2be5      	cmp	r3, #229	; 0xe5
    1f02:	d00a      	beq.n	1f1a <fatfs_entry_lfn_invalid+0x1e>
         (entry->Name[0]==FILE_HEADER_DELETED)||
         (entry->Attr==FILE_ATTR_VOLUME_ID) ||
    1f04:	7ac3      	ldrb	r3, [r0, #11]
         (entry->Name[0]==FILE_HEADER_DELETED)||
    1f06:	2b08      	cmp	r3, #8
    1f08:	d009      	beq.n	1f1e <fatfs_entry_lfn_invalid+0x22>
         (entry->Attr==FILE_ATTR_VOLUME_ID) ||
    1f0a:	f013 0f06 	tst.w	r3, #6
    1f0e:	bf14      	ite	ne
    1f10:	2001      	movne	r0, #1
    1f12:	2000      	moveq	r0, #0
    1f14:	4770      	bx	lr
         (entry->Attr & FILE_ATTR_SYSHID) )
        return 1;
    1f16:	2001      	movs	r0, #1
    1f18:	4770      	bx	lr
    1f1a:	2001      	movs	r0, #1
    1f1c:	4770      	bx	lr
    1f1e:	2001      	movs	r0, #1
    else
        return 0;
}
    1f20:	4770      	bx	lr

00001f22 <fatfs_entry_lfn_exists>:
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    1f22:	7acb      	ldrb	r3, [r1, #11]
    1f24:	2b0f      	cmp	r3, #15
    1f26:	d00e      	beq.n	1f46 <fatfs_entry_lfn_exists+0x24>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    1f28:	780a      	ldrb	r2, [r1, #0]
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    1f2a:	b172      	cbz	r2, 1f4a <fatfs_entry_lfn_exists+0x28>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    1f2c:	2ae5      	cmp	r2, #229	; 0xe5
    1f2e:	d00e      	beq.n	1f4e <fatfs_entry_lfn_exists+0x2c>
         (entry->Name[0]!=FILE_HEADER_DELETED) &&
    1f30:	2b08      	cmp	r3, #8
    1f32:	d00e      	beq.n	1f52 <fatfs_entry_lfn_exists+0x30>
         (entry->Attr!=FILE_ATTR_VOLUME_ID) &&
    1f34:	f013 0f06 	tst.w	r3, #6
    1f38:	d10d      	bne.n	1f56 <fatfs_entry_lfn_exists+0x34>
         (!(entry->Attr&FILE_ATTR_SYSHID)) &&
    1f3a:	f890 0105 	ldrb.w	r0, [r0, #261]	; 0x105
    1f3e:	3000      	adds	r0, #0
    1f40:	bf18      	it	ne
    1f42:	2001      	movne	r0, #1
    1f44:	4770      	bx	lr
         (lfn->no_of_strings) )
        return 1;
    else
        return 0;
    1f46:	2000      	movs	r0, #0
    1f48:	4770      	bx	lr
    1f4a:	2000      	movs	r0, #0
    1f4c:	4770      	bx	lr
    1f4e:	2000      	movs	r0, #0
    1f50:	4770      	bx	lr
    1f52:	2000      	movs	r0, #0
    1f54:	4770      	bx	lr
    1f56:	2000      	movs	r0, #0
}
    1f58:	4770      	bx	lr

00001f5a <fatfs_entry_sfn_only>:
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    1f5a:	7ac3      	ldrb	r3, [r0, #11]
    1f5c:	2b0f      	cmp	r3, #15
    1f5e:	d00b      	beq.n	1f78 <fatfs_entry_sfn_only+0x1e>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    1f60:	7802      	ldrb	r2, [r0, #0]
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    1f62:	b15a      	cbz	r2, 1f7c <fatfs_entry_sfn_only+0x22>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    1f64:	2ae5      	cmp	r2, #229	; 0xe5
    1f66:	d00b      	beq.n	1f80 <fatfs_entry_sfn_only+0x26>
         (entry->Name[0]!=FILE_HEADER_DELETED) &&
    1f68:	2b08      	cmp	r3, #8
    1f6a:	d00b      	beq.n	1f84 <fatfs_entry_sfn_only+0x2a>
         (entry->Attr!=FILE_ATTR_VOLUME_ID) &&
    1f6c:	f013 0f06 	tst.w	r3, #6
    1f70:	bf0c      	ite	eq
    1f72:	2001      	moveq	r0, #1
    1f74:	2000      	movne	r0, #0
    1f76:	4770      	bx	lr
         (!(entry->Attr&FILE_ATTR_SYSHID)) )
        return 1;
    else
        return 0;
    1f78:	2000      	movs	r0, #0
    1f7a:	4770      	bx	lr
    1f7c:	2000      	movs	r0, #0
    1f7e:	4770      	bx	lr
    1f80:	2000      	movs	r0, #0
    1f82:	4770      	bx	lr
    1f84:	2000      	movs	r0, #0
}
    1f86:	4770      	bx	lr

00001f88 <fatfs_entry_is_dir>:
//-----------------------------------------------------------------------------
// fatfs_entry_is_dir: Returns 1 if a directory
//-----------------------------------------------------------------------------
int fatfs_entry_is_dir(struct fat_dir_entry *entry)
{
    if (entry->Attr & FILE_TYPE_DIR)
    1f88:	7ac0      	ldrb	r0, [r0, #11]
        return 1;
    else
        return 0;
}
    1f8a:	f3c0 1000 	ubfx	r0, r0, #4, #1
    1f8e:	4770      	bx	lr

00001f90 <fatfs_entry_is_file>:
//-----------------------------------------------------------------------------
// fatfs_entry_is_file: Returns 1 is a file entry
//-----------------------------------------------------------------------------
int fatfs_entry_is_file(struct fat_dir_entry *entry)
{
    if (entry->Attr & FILE_TYPE_FILE)
    1f90:	7ac0      	ldrb	r0, [r0, #11]
        return 1;
    else
        return 0;
}
    1f92:	f3c0 1040 	ubfx	r0, r0, #5, #1
    1f96:	4770      	bx	lr

00001f98 <fatfs_lfn_entries_required>:
//-----------------------------------------------------------------------------
// fatfs_lfn_entries_required: Calculate number of 13 characters entries
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_lfn_entries_required(char *filename)
{
    1f98:	b508      	push	{r3, lr}
    int length = (int)strlen(filename);
    1f9a:	4b06      	ldr	r3, [pc, #24]	; (1fb4 <fatfs_lfn_entries_required+0x1c>)
    1f9c:	4798      	blx	r3
    1f9e:	4603      	mov	r3, r0

    if (length)
    1fa0:	b130      	cbz	r0, 1fb0 <fatfs_lfn_entries_required+0x18>
        return (length + MAX_LFN_ENTRY_LENGTH - 1) / MAX_LFN_ENTRY_LENGTH;
    1fa2:	300c      	adds	r0, #12
    1fa4:	4b04      	ldr	r3, [pc, #16]	; (1fb8 <fatfs_lfn_entries_required+0x20>)
    1fa6:	fb83 2300 	smull	r2, r3, r3, r0
    1faa:	17c0      	asrs	r0, r0, #31
    1fac:	ebc0 03a3 	rsb	r3, r0, r3, asr #2
    else
        return 0;
}
    1fb0:	4618      	mov	r0, r3
    1fb2:	bd08      	pop	{r3, pc}
    1fb4:	00003481 	.word	0x00003481
    1fb8:	4ec4ec4f 	.word	0x4ec4ec4f

00001fbc <fatfs_filename_to_lfn>:
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
    1fbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1fc0:	b08e      	sub	sp, #56	; 0x38
    1fc2:	4606      	mov	r6, r0
    1fc4:	460c      	mov	r4, r1
    1fc6:	4690      	mov	r8, r2
    1fc8:	4699      	mov	r9, r3
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
    1fca:	ad01      	add	r5, sp, #4
    1fcc:	4f24      	ldr	r7, [pc, #144]	; (2060 <fatfs_filename_to_lfn+0xa4>)
    1fce:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1fd0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1fd2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1fd4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1fd6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1fd8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1fda:	683b      	ldr	r3, [r7, #0]
    1fdc:	602b      	str	r3, [r5, #0]

    // 13 characters entries
    int length = (int)strlen(filename);
    1fde:	4630      	mov	r0, r6
    1fe0:	4b20      	ldr	r3, [pc, #128]	; (2064 <fatfs_filename_to_lfn+0xa8>)
    1fe2:	4798      	blx	r3
    1fe4:	4605      	mov	r5, r0
    int entriesRequired = fatfs_lfn_entries_required(filename);
    1fe6:	4630      	mov	r0, r6
    1fe8:	4b1f      	ldr	r3, [pc, #124]	; (2068 <fatfs_filename_to_lfn+0xac>)
    1fea:	4798      	blx	r3
    1fec:	4682      	mov	sl, r0

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
    1fee:	eb08 0048 	add.w	r0, r8, r8, lsl #1
    1ff2:	eb08 0780 	add.w	r7, r8, r0, lsl #2

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
    1ff6:	2220      	movs	r2, #32
    1ff8:	2100      	movs	r1, #0
    1ffa:	4620      	mov	r0, r4
    1ffc:	4b1b      	ldr	r3, [pc, #108]	; (206c <fatfs_filename_to_lfn+0xb0>)
    1ffe:	4798      	blx	r3

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
    2000:	f10a 3aff 	add.w	sl, sl, #4294967295
    2004:	45d0      	cmp	r8, sl
    2006:	f108 0801 	add.w	r8, r8, #1
    200a:	bf08      	it	eq
    200c:	f048 0840 	orreq.w	r8, r8, #64	; 0x40
    2010:	fa5f f888 	uxtb.w	r8, r8
    2014:	f884 8000 	strb.w	r8, [r4]

    // LFN flag
    buffer[11] = 0x0F;
    2018:	230f      	movs	r3, #15
    201a:	72e3      	strb	r3, [r4, #11]

    // Checksum of short filename
    buffer[13] = sfnChk;
    201c:	f884 900d 	strb.w	r9, [r4, #13]
    2020:	463b      	mov	r3, r7
    2022:	aa01      	add	r2, sp, #4
    2024:	f107 000d 	add.w	r0, r7, #13
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
    2028:	27ff      	movs	r7, #255	; 0xff
            buffer[nameIndexes[i]] = 0x00;
    202a:	f04f 0c00 	mov.w	ip, #0
    202e:	e00b      	b.n	2048 <fatfs_filename_to_lfn+0x8c>
        else if ( (start+i) == length )
    2030:	429d      	cmp	r5, r3
            buffer[nameIndexes[i]] = 0x00;
    2032:	6811      	ldr	r1, [r2, #0]
    2034:	bf0f      	iteee	eq
    2036:	f804 c001 	strbeq.w	ip, [r4, r1]
            buffer[nameIndexes[i]] = 0xFF;
    203a:	5467      	strbne	r7, [r4, r1]
            buffer[nameIndexes[i]+1] = 0xFF;
    203c:	1909      	addne	r1, r1, r4
    203e:	704f      	strbne	r7, [r1, #1]
    2040:	3301      	adds	r3, #1
    2042:	3204      	adds	r2, #4
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    2044:	4283      	cmp	r3, r0
    2046:	d007      	beq.n	2058 <fatfs_filename_to_lfn+0x9c>
        if ( (start+i) < length )
    2048:	429d      	cmp	r5, r3
    204a:	ddf1      	ble.n	2030 <fatfs_filename_to_lfn+0x74>
            buffer[nameIndexes[i]] = filename[start+i];
    204c:	f816 e003 	ldrb.w	lr, [r6, r3]
    2050:	6811      	ldr	r1, [r2, #0]
    2052:	f804 e001 	strb.w	lr, [r4, r1]
    2056:	e7f3      	b.n	2040 <fatfs_filename_to_lfn+0x84>
        }
    }
}
    2058:	b00e      	add	sp, #56	; 0x38
    205a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    205e:	bf00      	nop
    2060:	000037a0 	.word	0x000037a0
    2064:	00003481 	.word	0x00003481
    2068:	00001f99 	.word	0x00001f99
    206c:	00003305 	.word	0x00003305

00002070 <fatfs_sfn_create_entry>:
//-----------------------------------------------------------------------------
// fatfs_sfn_create_entry: Create the short filename directory entry
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
{
    2070:	b4f0      	push	{r4, r5, r6, r7}
    2072:	9f04      	ldr	r7, [sp, #16]
    2074:	1e44      	subs	r4, r0, #1
    2076:	1e5d      	subs	r5, r3, #1
    2078:	300a      	adds	r0, #10
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];
    207a:	f814 6f01 	ldrb.w	r6, [r4, #1]!
    207e:	f805 6f01 	strb.w	r6, [r5, #1]!
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
    2082:	4284      	cmp	r4, r0
    2084:	d1f9      	bne.n	207a <fatfs_sfn_create_entry+0xa>

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    2086:	2000      	movs	r0, #0
    2088:	7358      	strb	r0, [r3, #13]
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    208a:	7398      	strb	r0, [r3, #14]
    208c:	73d8      	strb	r0, [r3, #15]
    entry->CrtDate[1] = 0x00;
    208e:	7458      	strb	r0, [r3, #17]
    entry->CrtDate[0] = 0x20;
    2090:	2420      	movs	r4, #32
    2092:	741c      	strb	r4, [r3, #16]
    entry->LstAccDate[1] = 0x00;
    2094:	74d8      	strb	r0, [r3, #19]
    entry->LstAccDate[0] = 0x20;
    2096:	749c      	strb	r4, [r3, #18]
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    2098:	7598      	strb	r0, [r3, #22]
    209a:	75d8      	strb	r0, [r3, #23]
    entry->WrtDate[1] = 0x00;
    209c:	7658      	strb	r0, [r3, #25]
    entry->WrtDate[0] = 0x20;
    209e:	761c      	strb	r4, [r3, #24]

    if (!dir)
    20a0:	b14f      	cbz	r7, 20b6 <fatfs_sfn_create_entry+0x46>
        entry->Attr = FILE_TYPE_FILE;
    else
        entry->Attr = FILE_TYPE_DIR;
    20a2:	2010      	movs	r0, #16
    20a4:	72d8      	strb	r0, [r3, #11]

    entry->NTRes = 0x00;
    20a6:	2000      	movs	r0, #0
    20a8:	7318      	strb	r0, [r3, #12]

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    20aa:	0c10      	lsrs	r0, r2, #16
    20ac:	8298      	strh	r0, [r3, #20]
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
    20ae:	835a      	strh	r2, [r3, #26]
    entry->FileSize = FAT_HTONL(size);
    20b0:	61d9      	str	r1, [r3, #28]
}
    20b2:	bcf0      	pop	{r4, r5, r6, r7}
    20b4:	4770      	bx	lr
        entry->Attr = FILE_TYPE_FILE;
    20b6:	72dc      	strb	r4, [r3, #11]
    20b8:	e7f5      	b.n	20a6 <fatfs_sfn_create_entry+0x36>
	...

000020bc <fatfs_lfn_create_sfn>:
//-----------------------------------------------------------------------------
// fatfs_lfn_create_sfn: Create a padded SFN
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_create_sfn(char *sfn_output, char *filename)
{
    20bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    20be:	b083      	sub	sp, #12
    20c0:	4606      	mov	r6, r0
    20c2:	460c      	mov	r4, r1
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
    20c4:	4608      	mov	r0, r1
    20c6:	4b31      	ldr	r3, [pc, #196]	; (218c <fatfs_lfn_create_sfn+0xd0>)
    20c8:	4798      	blx	r3

    // Invalid to start with .
    if (filename[0]=='.')
    20ca:	7823      	ldrb	r3, [r4, #0]
    20cc:	2b2e      	cmp	r3, #46	; 0x2e
    20ce:	d058      	beq.n	2182 <fatfs_lfn_create_sfn+0xc6>
    int len = (int)strlen(filename);
    20d0:	4605      	mov	r5, r0
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
    20d2:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
    20d6:	6033      	str	r3, [r6, #0]
    20d8:	6073      	str	r3, [r6, #4]
    20da:	f8c6 3007 	str.w	r3, [r6, #7]
    memset(ext, ' ', 3);
    20de:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    20e2:	f8ad 3004 	strh.w	r3, [sp, #4]
    20e6:	f88d 3006 	strb.w	r3, [sp, #6]

    // Find dot seperator
    for (i = 0; i< len; i++)
    20ea:	2800      	cmp	r0, #0
    20ec:	dd36      	ble.n	215c <fatfs_lfn_create_sfn+0xa0>
    20ee:	1e61      	subs	r1, r4, #1
    20f0:	f04f 32ff 	mov.w	r2, #4294967295
    20f4:	2300      	movs	r3, #0
    {
        if (filename[i]=='.')
    20f6:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    20fa:	282e      	cmp	r0, #46	; 0x2e
    20fc:	bf08      	it	eq
    20fe:	461a      	moveq	r2, r3
    for (i = 0; i< len; i++)
    2100:	3301      	adds	r3, #1
    2102:	429d      	cmp	r5, r3
    2104:	d1f7      	bne.n	20f6 <fatfs_lfn_create_sfn+0x3a>
            dotPos = i;
    }

    // Extract extensions
    if (dotPos!=-1)
    2106:	f1b2 3fff 	cmp.w	r2, #4294967295
    210a:	d03c      	beq.n	2186 <fatfs_lfn_create_sfn+0xca>
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
    210c:	1c51      	adds	r1, r2, #1
    210e:	1d10      	adds	r0, r2, #4
    2110:	4281      	cmp	r1, r0
    2112:	da09      	bge.n	2128 <fatfs_lfn_create_sfn+0x6c>
    2114:	a801      	add	r0, sp, #4
    2116:	1d15      	adds	r5, r2, #4
            if (i<len)
    2118:	428b      	cmp	r3, r1
                ext[i-(dotPos+1)] = filename[i];
    211a:	bfc4      	itt	gt
    211c:	5c67      	ldrbgt	r7, [r4, r1]
    211e:	7007      	strbgt	r7, [r0, #0]
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
    2120:	3101      	adds	r1, #1
    2122:	3001      	adds	r0, #1
    2124:	42a9      	cmp	r1, r5
    2126:	d1f7      	bne.n	2118 <fatfs_lfn_create_sfn+0x5c>
        len = dotPos;
    }

    // Add filename part
    pos = 0;
    for (i=0;i<len;i++)
    2128:	2a00      	cmp	r2, #0
    212a:	dd17      	ble.n	215c <fatfs_lfn_create_sfn+0xa0>
    212c:	1e61      	subs	r1, r4, #1
    int len = (int)strlen(filename);
    212e:	2500      	movs	r5, #0
    2130:	462c      	mov	r4, r5
    2132:	e004      	b.n	213e <fatfs_lfn_create_sfn+0x82>
            else
                sfn_output[pos++] = filename[i];
        }

        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
    2134:	2d08      	cmp	r5, #8
    2136:	d011      	beq.n	215c <fatfs_lfn_create_sfn+0xa0>
    for (i=0;i<len;i++)
    2138:	3401      	adds	r4, #1
    213a:	4294      	cmp	r4, r2
    213c:	da0e      	bge.n	215c <fatfs_lfn_create_sfn+0xa0>
        if ( (filename[i]!=' ') && (filename[i]!='.') )
    213e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    2142:	2b20      	cmp	r3, #32
    2144:	d0f6      	beq.n	2134 <fatfs_lfn_create_sfn+0x78>
    2146:	2b2e      	cmp	r3, #46	; 0x2e
    2148:	d0f4      	beq.n	2134 <fatfs_lfn_create_sfn+0x78>
            if (filename[i] >= 'a' && filename[i] <= 'z')
    214a:	f1a3 0061 	sub.w	r0, r3, #97	; 0x61
    214e:	b2c0      	uxtb	r0, r0
    2150:	2819      	cmp	r0, #25
                sfn_output[pos++] = filename[i] - 'a' + 'A';
    2152:	bf98      	it	ls
    2154:	3b20      	subls	r3, #32
                sfn_output[pos++] = filename[i];
    2156:	5573      	strb	r3, [r6, r5]
    2158:	3501      	adds	r5, #1
    215a:	e7eb      	b.n	2134 <fatfs_lfn_create_sfn+0x78>
    215c:	a801      	add	r0, sp, #4
    215e:	f106 0308 	add.w	r3, r6, #8
    2162:	360b      	adds	r6, #11
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
    2164:	f810 2b01 	ldrb.w	r2, [r0], #1
    2168:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
    216c:	b2c9      	uxtb	r1, r1
    216e:	2919      	cmp	r1, #25
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
    2170:	bf98      	it	ls
    2172:	3a20      	subls	r2, #32
        else
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL];
    2174:	701a      	strb	r2, [r3, #0]
    2176:	3301      	adds	r3, #1
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    2178:	42b3      	cmp	r3, r6
    217a:	d1f3      	bne.n	2164 <fatfs_lfn_create_sfn+0xa8>
    }

    return 1;
    217c:	2001      	movs	r0, #1
}
    217e:	b003      	add	sp, #12
    2180:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 0;
    2182:	2000      	movs	r0, #0
    2184:	e7fb      	b.n	217e <fatfs_lfn_create_sfn+0xc2>
    int len = (int)strlen(filename);
    2186:	461a      	mov	r2, r3
    2188:	e7d0      	b.n	212c <fatfs_lfn_create_sfn+0x70>
    218a:	bf00      	nop
    218c:	00003481 	.word	0x00003481

00002190 <fatfs_lfn_generate_tail>:
int fatfs_lfn_generate_tail(char *sfn_output, char *sfn_input, uint32 tailNum)
{
    int tail_chars;
    char tail_str[12];

    if (tailNum > 99999)
    2190:	4b2b      	ldr	r3, [pc, #172]	; (2240 <fatfs_lfn_generate_tail+0xb0>)
    2192:	429a      	cmp	r2, r3
    2194:	d901      	bls.n	219a <fatfs_lfn_generate_tail+0xa>
        return 0;
    2196:	2000      	movs	r0, #0
    2198:	4770      	bx	lr
{
    219a:	b5f0      	push	{r4, r5, r6, r7, lr}
    219c:	b08d      	sub	sp, #52	; 0x34
    219e:	4605      	mov	r5, r0
    21a0:	460e      	mov	r6, r1
    21a2:	4614      	mov	r4, r2

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str));
    21a4:	2300      	movs	r3, #0
    21a6:	9309      	str	r3, [sp, #36]	; 0x24
    21a8:	930a      	str	r3, [sp, #40]	; 0x28
    21aa:	930b      	str	r3, [sp, #44]	; 0x2c
    tail_str[0] = '~';
    21ac:	237e      	movs	r3, #126	; 0x7e
    21ae:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    const char digits[] = "0123456789ABCDEF";
    21b2:	af04      	add	r7, sp, #16
    21b4:	f8df e098 	ldr.w	lr, [pc, #152]	; 2250 <fatfs_lfn_generate_tail+0xc0>
    21b8:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    21bc:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    21be:	f8de 3000 	ldr.w	r3, [lr]
    21c2:	703b      	strb	r3, [r7, #0]
    cp = outbuf;
    21c4:	a801      	add	r0, sp, #4
        *cp++ = digits[(int)(num % 10)];
    21c6:	4f1f      	ldr	r7, [pc, #124]	; (2244 <fatfs_lfn_generate_tail+0xb4>)
    21c8:	e000      	b.n	21cc <fatfs_lfn_generate_tail+0x3c>
    21ca:	4608      	mov	r0, r1
    21cc:	4601      	mov	r1, r0
    21ce:	fba7 2304 	umull	r2, r3, r7, r4
    21d2:	08db      	lsrs	r3, r3, #3
    21d4:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    21d8:	eba4 0242 	sub.w	r2, r4, r2, lsl #1
    21dc:	ac0c      	add	r4, sp, #48	; 0x30
    21de:	4422      	add	r2, r4
    21e0:	f812 2c20 	ldrb.w	r2, [r2, #-32]
    21e4:	f801 2b01 	strb.w	r2, [r1], #1
    while ((num /= 10) > 0);
    21e8:	461c      	mov	r4, r3
    21ea:	2b00      	cmp	r3, #0
    21ec:	d1ed      	bne.n	21ca <fatfs_lfn_generate_tail+0x3a>
    *cp-- = 0;
    21ee:	700b      	strb	r3, [r1, #0]
    while (cp >= outbuf)
    21f0:	ab01      	add	r3, sp, #4
    21f2:	4298      	cmp	r0, r3
    21f4:	d321      	bcc.n	223a <fatfs_lfn_generate_tail+0xaa>
    21f6:	460b      	mov	r3, r1
    21f8:	f10d 0225 	add.w	r2, sp, #37	; 0x25
    21fc:	ac01      	add	r4, sp, #4
        *s++ = *cp--;
    21fe:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    2202:	f802 1b01 	strb.w	r1, [r2], #1
    while (cp >= outbuf)
    2206:	42a3      	cmp	r3, r4
    2208:	d1f9      	bne.n	21fe <fatfs_lfn_generate_tail+0x6e>
    220a:	3022      	adds	r0, #34	; 0x22
    *s = 0;
    220c:	2300      	movs	r3, #0
    220e:	7003      	strb	r3, [r0, #0]
    fatfs_itoa(tailNum, tail_str+1);

    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
    2210:	6832      	ldr	r2, [r6, #0]
    2212:	6873      	ldr	r3, [r6, #4]
    2214:	602a      	str	r2, [r5, #0]
    2216:	606b      	str	r3, [r5, #4]
    2218:	8932      	ldrh	r2, [r6, #8]
    221a:	7ab3      	ldrb	r3, [r6, #10]
    221c:	812a      	strh	r2, [r5, #8]
    221e:	72ab      	strb	r3, [r5, #10]

    // Overwrite with tail
    tail_chars = (int)strlen(tail_str);
    2220:	a809      	add	r0, sp, #36	; 0x24
    2222:	4b09      	ldr	r3, [pc, #36]	; (2248 <fatfs_lfn_generate_tail+0xb8>)
    2224:	4798      	blx	r3
    2226:	4602      	mov	r2, r0
    memcpy(sfn_output+(FAT_SFN_SIZE_PARTIAL-tail_chars), tail_str, tail_chars);
    2228:	f1c0 0008 	rsb	r0, r0, #8
    222c:	a909      	add	r1, sp, #36	; 0x24
    222e:	4428      	add	r0, r5
    2230:	4b06      	ldr	r3, [pc, #24]	; (224c <fatfs_lfn_generate_tail+0xbc>)
    2232:	4798      	blx	r3

    return 1;
    2234:	2001      	movs	r0, #1
}
    2236:	b00d      	add	sp, #52	; 0x34
    2238:	bdf0      	pop	{r4, r5, r6, r7, pc}
    while (cp >= outbuf)
    223a:	f10d 0025 	add.w	r0, sp, #37	; 0x25
    223e:	e7e5      	b.n	220c <fatfs_lfn_generate_tail+0x7c>
    2240:	0001869f 	.word	0x0001869f
    2244:	cccccccd 	.word	0xcccccccd
    2248:	00003481 	.word	0x00003481
    224c:	000031d1 	.word	0x000031d1
    2250:	000037d4 	.word	0x000037d4

00002254 <FileString_StrCmpNoCase>:
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
    2254:	b302      	cbz	r2, 2298 <FileString_StrCmpNoCase+0x44>
{
    2256:	b470      	push	{r4, r5, r6}
    2258:	1e46      	subs	r6, r0, #1
    225a:	3901      	subs	r1, #1
    {
        a = *s1;
    225c:	f816 4f01 	ldrb.w	r4, [r6, #1]!
        b = *s2;
    2260:	f811 5f01 	ldrb.w	r5, [r1, #1]!

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
    2264:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
    2268:	b2db      	uxtb	r3, r3
    226a:	2b19      	cmp	r3, #25
            a+= 32;
    226c:	bf9a      	itte	ls
    226e:	f104 0020 	addls.w	r0, r4, #32
    2272:	b2c0      	uxtbls	r0, r0
        a = *s1;
    2274:	4620      	movhi	r0, r4
        if ((b>='A') && (b<='Z'))
    2276:	f1a5 0341 	sub.w	r3, r5, #65	; 0x41
    227a:	b2db      	uxtb	r3, r3
    227c:	2b19      	cmp	r3, #25
            b+= 32;
    227e:	bf9a      	itte	ls
    2280:	f105 0320 	addls.w	r3, r5, #32
    2284:	b2db      	uxtbls	r3, r3
        b = *s2;
    2286:	462b      	movhi	r3, r5

        diff = a - b;

        // If different
        if (diff)
    2288:	1ac0      	subs	r0, r0, r3
    228a:	d103      	bne.n	2294 <FileString_StrCmpNoCase+0x40>
            return diff;

        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
    228c:	b114      	cbz	r4, 2294 <FileString_StrCmpNoCase+0x40>
    228e:	b10d      	cbz	r5, 2294 <FileString_StrCmpNoCase+0x40>
    while (n--)
    2290:	3a01      	subs	r2, #1
    2292:	d1e3      	bne.n	225c <FileString_StrCmpNoCase+0x8>

        s1++;
        s2++;
    }
    return 0;
}
    2294:	bc70      	pop	{r4, r5, r6}
    2296:	4770      	bx	lr
    return 0;
    2298:	4610      	mov	r0, r2
    229a:	4770      	bx	lr

0000229c <FileString_GetExtension>:
//-----------------------------------------------------------------------------
// FileString_GetExtension: Get index to extension within filename
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_GetExtension(char *str)
{
    229c:	4601      	mov	r1, r0
    int dotPos = -1;
    char *strSrc = str;

    // Find last '.' in string (if at all)
    while (*strSrc)
    229e:	7803      	ldrb	r3, [r0, #0]
    22a0:	b153      	cbz	r3, 22b8 <FileString_GetExtension+0x1c>
    22a2:	4602      	mov	r2, r0
    22a4:	f04f 30ff 	mov.w	r0, #4294967295
    {
        if (*strSrc=='.')
    22a8:	2b2e      	cmp	r3, #46	; 0x2e
    22aa:	bf08      	it	eq
    22ac:	1a50      	subeq	r0, r2, r1
    while (*strSrc)
    22ae:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    22b2:	2b00      	cmp	r3, #0
    22b4:	d1f8      	bne.n	22a8 <FileString_GetExtension+0xc>
    22b6:	4770      	bx	lr
    int dotPos = -1;
    22b8:	f04f 30ff 	mov.w	r0, #4294967295

        strSrc++;
    }

    return dotPos;
}
    22bc:	4770      	bx	lr

000022be <fatfs_total_path_levels>:
    if (!path)
    22be:	4602      	mov	r2, r0
    22c0:	b1f8      	cbz	r0, 2302 <fatfs_total_path_levels+0x44>
    if (*path == '/')
    22c2:	7801      	ldrb	r1, [r0, #0]
    22c4:	292f      	cmp	r1, #47	; 0x2f
    22c6:	d00c      	beq.n	22e2 <fatfs_total_path_levels+0x24>
    else if (path[1] == ':' || path[2] == '\\')
    22c8:	7843      	ldrb	r3, [r0, #1]
    22ca:	2b3a      	cmp	r3, #58	; 0x3a
    22cc:	d002      	beq.n	22d4 <fatfs_total_path_levels+0x16>
    22ce:	7883      	ldrb	r3, [r0, #2]
    22d0:	2b5c      	cmp	r3, #92	; 0x5c
    22d2:	d119      	bne.n	2308 <fatfs_total_path_levels+0x4a>
        path += 3;
    22d4:	3203      	adds	r2, #3
        expectedchar = '\\';
    22d6:	215c      	movs	r1, #92	; 0x5c
    while (*path)
    22d8:	7813      	ldrb	r3, [r2, #0]
    22da:	2000      	movs	r0, #0
    22dc:	b1c3      	cbz	r3, 2310 <fatfs_total_path_levels+0x52>
    22de:	2000      	movs	r0, #0
    22e0:	e006      	b.n	22f0 <fatfs_total_path_levels+0x32>
        path++;
    22e2:	3201      	adds	r2, #1
    22e4:	e7f8      	b.n	22d8 <fatfs_total_path_levels+0x1a>
            if (*path == expectedchar) { path++; break; }
    22e6:	4613      	mov	r3, r2
    22e8:	1c5a      	adds	r2, r3, #1
        levels++;
    22ea:	3001      	adds	r0, #1
    while (*path)
    22ec:	785b      	ldrb	r3, [r3, #1]
    22ee:	b17b      	cbz	r3, 2310 <fatfs_total_path_levels+0x52>
            if (*path == expectedchar) { path++; break; }
    22f0:	4299      	cmp	r1, r3
    22f2:	d0f8      	beq.n	22e6 <fatfs_total_path_levels+0x28>
        for (; *path; )
    22f4:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    22f8:	b14b      	cbz	r3, 230e <fatfs_total_path_levels+0x50>
            if (*path == expectedchar) { path++; break; }
    22fa:	4299      	cmp	r1, r3
    22fc:	d1fa      	bne.n	22f4 <fatfs_total_path_levels+0x36>
            path++;
    22fe:	4613      	mov	r3, r2
    2300:	e7f2      	b.n	22e8 <fatfs_total_path_levels+0x2a>
        return -1;
    2302:	f04f 30ff 	mov.w	r0, #4294967295
    2306:	4770      	bx	lr
        return -1;
    2308:	f04f 30ff 	mov.w	r0, #4294967295
    230c:	4770      	bx	lr
        levels++;
    230e:	3001      	adds	r0, #1
    return levels-1;
    2310:	3801      	subs	r0, #1
    2312:	4770      	bx	lr

00002314 <fatfs_get_substring>:
    if (!path || max_len <= 0)
    2314:	2800      	cmp	r0, #0
    2316:	d03d      	beq.n	2394 <fatfs_get_substring+0x80>
{
    2318:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    231c:	4605      	mov	r5, r0
    if (!path || max_len <= 0)
    231e:	2b00      	cmp	r3, #0
    2320:	dd3b      	ble.n	239a <fatfs_get_substring+0x86>
    if (*path == '/')
    2322:	7806      	ldrb	r6, [r0, #0]
    2324:	2e2f      	cmp	r6, #47	; 0x2f
    2326:	d016      	beq.n	2356 <fatfs_get_substring+0x42>
    else if (path[1] == ':' || path[2] == '\\')
    2328:	7840      	ldrb	r0, [r0, #1]
    232a:	283a      	cmp	r0, #58	; 0x3a
    232c:	d002      	beq.n	2334 <fatfs_get_substring+0x20>
    232e:	78a8      	ldrb	r0, [r5, #2]
    2330:	285c      	cmp	r0, #92	; 0x5c
    2332:	d136      	bne.n	23a2 <fatfs_get_substring+0x8e>
        path += 3;
    2334:	3503      	adds	r5, #3
        expectedchar = '\\';
    2336:	265c      	movs	r6, #92	; 0x5c
    2338:	4699      	mov	r9, r3
    233a:	4690      	mov	r8, r2
    233c:	460f      	mov	r7, r1
    pathlen = (int)strlen (path);
    233e:	4628      	mov	r0, r5
    2340:	4b1a      	ldr	r3, [pc, #104]	; (23ac <fatfs_get_substring+0x98>)
    2342:	4798      	blx	r3
    for (i = 0; i<pathlen; i++)
    2344:	2800      	cmp	r0, #0
    2346:	dd19      	ble.n	237c <fatfs_get_substring+0x68>
    2348:	462c      	mov	r4, r5
    234a:	4428      	add	r0, r5
    234c:	2100      	movs	r1, #0
    234e:	460d      	mov	r5, r1
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1)))
    2350:	f109 32ff 	add.w	r2, r9, #4294967295
    2354:	e004      	b.n	2360 <fatfs_get_substring+0x4c>
        path++;
    2356:	3501      	adds	r5, #1
    2358:	e7ee      	b.n	2338 <fatfs_get_substring+0x24>
        if (*path == expectedchar) levels++;
    235a:	3501      	adds	r5, #1
    for (i = 0; i<pathlen; i++)
    235c:	4284      	cmp	r4, r0
    235e:	d00e      	beq.n	237e <fatfs_get_substring+0x6a>
        if (*path == expectedchar) levels++;
    2360:	f814 3b01 	ldrb.w	r3, [r4], #1
    2364:	429e      	cmp	r6, r3
    2366:	d0f8      	beq.n	235a <fatfs_get_substring+0x46>
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1)))
    2368:	42af      	cmp	r7, r5
    236a:	d1f7      	bne.n	235c <fatfs_get_substring+0x48>
    236c:	428a      	cmp	r2, r1
            output[copypnt++] = *path;
    236e:	bfc3      	ittte	gt
    2370:	f808 3001 	strbgt.w	r3, [r8, r1]
    2374:	463d      	movgt	r5, r7
    2376:	3101      	addgt	r1, #1
    2378:	463d      	movle	r5, r7
    237a:	e7ef      	b.n	235c <fatfs_get_substring+0x48>
    int copypnt=0;
    237c:	2100      	movs	r1, #0
    output[copypnt] = '\0';
    237e:	2300      	movs	r3, #0
    2380:	f808 3001 	strb.w	r3, [r8, r1]
    if (output[0] != '\0')
    2384:	f898 0000 	ldrb.w	r0, [r8]
    2388:	fab0 f080 	clz	r0, r0
    238c:	0940      	lsrs	r0, r0, #5
    238e:	4240      	negs	r0, r0
    2390:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return -1;
    2394:	f04f 30ff 	mov.w	r0, #4294967295
    2398:	4770      	bx	lr
    239a:	f04f 30ff 	mov.w	r0, #4294967295
    239e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return -1;
    23a2:	f04f 30ff 	mov.w	r0, #4294967295
    23a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    23aa:	bf00      	nop
    23ac:	00003481 	.word	0x00003481

000023b0 <fatfs_split_path>:
{
    23b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    23b4:	4607      	mov	r7, r0
    23b6:	460e      	mov	r6, r1
    23b8:	4692      	mov	sl, r2
    23ba:	4699      	mov	r9, r3
    int levels = fatfs_total_path_levels(full_path);
    23bc:	4b16      	ldr	r3, [pc, #88]	; (2418 <fatfs_split_path+0x68>)
    23be:	4798      	blx	r3
    23c0:	4604      	mov	r4, r0
    if (levels == -1)
    23c2:	f1b0 3fff 	cmp.w	r0, #4294967295
    23c6:	d022      	beq.n	240e <fatfs_split_path+0x5e>
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
    23c8:	9b08      	ldr	r3, [sp, #32]
    23ca:	464a      	mov	r2, r9
    23cc:	4601      	mov	r1, r0
    23ce:	4638      	mov	r0, r7
    23d0:	4d12      	ldr	r5, [pc, #72]	; (241c <fatfs_split_path+0x6c>)
    23d2:	47a8      	blx	r5
    23d4:	4680      	mov	r8, r0
    23d6:	b9e0      	cbnz	r0, 2412 <fatfs_split_path+0x62>
    if (levels == 0)
    23d8:	b1ac      	cbz	r4, 2406 <fatfs_split_path+0x56>
        strindex = (int)strlen(full_path) - (int)strlen(filename);
    23da:	4638      	mov	r0, r7
    23dc:	4c10      	ldr	r4, [pc, #64]	; (2420 <fatfs_split_path+0x70>)
    23de:	47a0      	blx	r4
    23e0:	4605      	mov	r5, r0
    23e2:	4648      	mov	r0, r9
    23e4:	47a0      	blx	r4
    23e6:	1a2c      	subs	r4, r5, r0
        memcpy(path, full_path, strindex);
    23e8:	4554      	cmp	r4, sl
    23ea:	bfa8      	it	ge
    23ec:	4654      	movge	r4, sl
    23ee:	4622      	mov	r2, r4
    23f0:	4639      	mov	r1, r7
    23f2:	4630      	mov	r0, r6
    23f4:	4b0b      	ldr	r3, [pc, #44]	; (2424 <fatfs_split_path+0x74>)
    23f6:	4798      	blx	r3
        path[strindex-1] = '\0';
    23f8:	4434      	add	r4, r6
    23fa:	2300      	movs	r3, #0
    23fc:	f804 3c01 	strb.w	r3, [r4, #-1]
}
    2400:	4640      	mov	r0, r8
    2402:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        path[0] = '\0';
    2406:	2300      	movs	r3, #0
    2408:	7033      	strb	r3, [r6, #0]
    return 0;
    240a:	46a0      	mov	r8, r4
    240c:	e7f8      	b.n	2400 <fatfs_split_path+0x50>
        return -1;
    240e:	4680      	mov	r8, r0
    2410:	e7f6      	b.n	2400 <fatfs_split_path+0x50>
        return -1;
    2412:	f04f 38ff 	mov.w	r8, #4294967295
    2416:	e7f3      	b.n	2400 <fatfs_split_path+0x50>
    2418:	000022bf 	.word	0x000022bf
    241c:	00002315 	.word	0x00002315
    2420:	00003481 	.word	0x00003481
    2424:	000031d1 	.word	0x000031d1

00002428 <fatfs_compare_names>:
//-----------------------------------------------------------------------------
// fatfs_compare_names: Compare two filenames (without copying or changing origonals)
// Returns 1 if match, 0 if not
//-----------------------------------------------------------------------------
int fatfs_compare_names(char* strA, char* strB)
{
    2428:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    242c:	4607      	mov	r7, r0
    242e:	460e      	mov	r6, r1
    char *ext2 = NULL;
    int ext1Pos, ext2Pos;
    int file1Len, file2Len;

    // Get both files extension
    ext1Pos = FileString_GetExtension(strA);
    2430:	4d3a      	ldr	r5, [pc, #232]	; (251c <fatfs_compare_names+0xf4>)
    2432:	47a8      	blx	r5
    2434:	4604      	mov	r4, r0
    ext2Pos = FileString_GetExtension(strB);
    2436:	4630      	mov	r0, r6
    2438:	47a8      	blx	r5
    243a:	4605      	mov	r5, r0

    // NOTE: Extension position can be different for matching
    // filename if trailing space are present before it!
    // Check that if one has an extension, so does the other
    if ((ext1Pos==-1) && (ext2Pos!=-1))
    243c:	f1b4 3fff 	cmp.w	r4, #4294967295
    2440:	d015      	beq.n	246e <fatfs_compare_names+0x46>
        return 0;
    if ((ext2Pos==-1) && (ext1Pos!=-1))
    2442:	f1b0 3fff 	cmp.w	r0, #4294967295
    2446:	d04f      	beq.n	24e8 <fatfs_compare_names+0xc0>

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
    2448:	f104 0801 	add.w	r8, r4, #1
    244c:	44b8      	add	r8, r7
        ext2 = strB+ext2Pos+1;
    244e:	f105 0901 	add.w	r9, r5, #1
    2452:	44b1      	add	r9, r6

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
    2454:	4640      	mov	r0, r8
    2456:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 2524 <fatfs_compare_names+0xfc>
    245a:	47d0      	blx	sl
    245c:	4683      	mov	fp, r0
    245e:	4648      	mov	r0, r9
    2460:	47d0      	blx	sl
    2462:	4583      	cmp	fp, r0
    2464:	d008      	beq.n	2478 <fatfs_compare_names+0x50>
            return 0;
    2466:	2500      	movs	r5, #0
    // Compare main part of filenames
    if (FileString_StrCmpNoCase(strA, strB, file1Len)!=0)
        return 0;
    else
        return 1;
}
    2468:	4628      	mov	r0, r5
    246a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((ext1Pos==-1) && (ext2Pos!=-1))
    246e:	f1b0 3fff 	cmp.w	r0, #4294967295
    2472:	d009      	beq.n	2488 <fatfs_compare_names+0x60>
        return 0;
    2474:	2500      	movs	r5, #0
    2476:	e7f7      	b.n	2468 <fatfs_compare_names+0x40>
        if (FileString_StrCmpNoCase(ext1, ext2, (int)strlen(ext1))!=0)
    2478:	465a      	mov	r2, fp
    247a:	4649      	mov	r1, r9
    247c:	4640      	mov	r0, r8
    247e:	4b28      	ldr	r3, [pc, #160]	; (2520 <fatfs_compare_names+0xf8>)
    2480:	4798      	blx	r3
    2482:	b140      	cbz	r0, 2496 <fatfs_compare_names+0x6e>
            return 0;
    2484:	2500      	movs	r5, #0
    2486:	e7ef      	b.n	2468 <fatfs_compare_names+0x40>
        file1Len = (int)strlen(strA);
    2488:	4638      	mov	r0, r7
    248a:	4d26      	ldr	r5, [pc, #152]	; (2524 <fatfs_compare_names+0xfc>)
    248c:	47a8      	blx	r5
    248e:	4604      	mov	r4, r0
        file2Len = (int)strlen(strB);
    2490:	4630      	mov	r0, r6
    2492:	47a8      	blx	r5
    2494:	4605      	mov	r5, r0
    char *strSrc = str+strLen-1;
    2496:	1e62      	subs	r2, r4, #1
    2498:	18b9      	adds	r1, r7, r2
    while (strLen != 0)
    249a:	b33c      	cbz	r4, 24ec <fatfs_compare_names+0xc4>
        if (*strSrc == ' ')
    249c:	5cba      	ldrb	r2, [r7, r2]
    249e:	2a20      	cmp	r2, #32
    24a0:	d136      	bne.n	2510 <fatfs_compare_names+0xe8>
    24a2:	4608      	mov	r0, r1
    24a4:	f1c4 0301 	rsb	r3, r4, #1
    24a8:	4419      	add	r1, r3
    while (strLen != 0)
    24aa:	4288      	cmp	r0, r1
    24ac:	d006      	beq.n	24bc <fatfs_compare_names+0x94>
    24ae:	1e42      	subs	r2, r0, #1
        if (*strSrc == ' ')
    24b0:	f810 3c01 	ldrb.w	r3, [r0, #-1]
    24b4:	2b20      	cmp	r3, #32
    24b6:	d101      	bne.n	24bc <fatfs_compare_names+0x94>
    24b8:	4610      	mov	r0, r2
    24ba:	e7f6      	b.n	24aa <fatfs_compare_names+0x82>
            length = (int)(strSrc - str);
    24bc:	1bc4      	subs	r4, r0, r7
    char *strSrc = str+strLen-1;
    24be:	1e69      	subs	r1, r5, #1
    24c0:	4431      	add	r1, r6
    while (strLen != 0)
    24c2:	b16d      	cbz	r5, 24e0 <fatfs_compare_names+0xb8>
        if (*strSrc == ' ')
    24c4:	780b      	ldrb	r3, [r1, #0]
    24c6:	2b20      	cmp	r3, #32
    24c8:	d10a      	bne.n	24e0 <fatfs_compare_names+0xb8>
    24ca:	460b      	mov	r3, r1
    24cc:	f1c5 0501 	rsb	r5, r5, #1
    24d0:	4429      	add	r1, r5
    24d2:	1b9d      	subs	r5, r3, r6
    while (strLen != 0)
    24d4:	428b      	cmp	r3, r1
    24d6:	d003      	beq.n	24e0 <fatfs_compare_names+0xb8>
        if (*strSrc == ' ')
    24d8:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    24dc:	2a20      	cmp	r2, #32
    24de:	d0f8      	beq.n	24d2 <fatfs_compare_names+0xaa>
    if (file1Len!=file2Len)
    24e0:	42a5      	cmp	r5, r4
    24e2:	d00c      	beq.n	24fe <fatfs_compare_names+0xd6>
        return 0;
    24e4:	2500      	movs	r5, #0
    24e6:	e7bf      	b.n	2468 <fatfs_compare_names+0x40>
        return 0;
    24e8:	2500      	movs	r5, #0
    24ea:	e7bd      	b.n	2468 <fatfs_compare_names+0x40>
    char *strSrc = str+strLen-1;
    24ec:	1e6b      	subs	r3, r5, #1
    24ee:	18f1      	adds	r1, r6, r3
    while (strLen != 0)
    24f0:	b125      	cbz	r5, 24fc <fatfs_compare_names+0xd4>
        if (*strSrc == ' ')
    24f2:	5cf3      	ldrb	r3, [r6, r3]
    24f4:	2b20      	cmp	r3, #32
    24f6:	d0e8      	beq.n	24ca <fatfs_compare_names+0xa2>
        return 0;
    24f8:	4625      	mov	r5, r4
    24fa:	e7b5      	b.n	2468 <fatfs_compare_names+0x40>
    int length = strLen;
    24fc:	462c      	mov	r4, r5
    if (FileString_StrCmpNoCase(strA, strB, file1Len)!=0)
    24fe:	4622      	mov	r2, r4
    2500:	4631      	mov	r1, r6
    2502:	4638      	mov	r0, r7
    2504:	4b06      	ldr	r3, [pc, #24]	; (2520 <fatfs_compare_names+0xf8>)
    2506:	4798      	blx	r3
    2508:	fab0 f580 	clz	r5, r0
    250c:	096d      	lsrs	r5, r5, #5
    250e:	e7ab      	b.n	2468 <fatfs_compare_names+0x40>
    char *strSrc = str+strLen-1;
    2510:	1e69      	subs	r1, r5, #1
    2512:	4431      	add	r1, r6
    while (strLen != 0)
    2514:	2d00      	cmp	r5, #0
    2516:	d1d5      	bne.n	24c4 <fatfs_compare_names+0x9c>
    2518:	e7a6      	b.n	2468 <fatfs_compare_names+0x40>
    251a:	bf00      	nop
    251c:	0000229d 	.word	0x0000229d
    2520:	00002255 	.word	0x00002255
    2524:	00003481 	.word	0x00003481

00002528 <fatfs_fat_writeback>:
}
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    2528:	b538      	push	{r3, r4, r5, lr}
    if (pcur)
    252a:	b1d1      	cbz	r1, 2562 <fatfs_fat_writeback+0x3a>
    252c:	460c      	mov	r4, r1
    {
        // Writeback sector if changed
        if (pcur->dirty)
    252e:	f8d1 2204 	ldr.w	r2, [r1, #516]	; 0x204
    2532:	b1c2      	cbz	r2, 2566 <fatfs_fat_writeback+0x3e>
    2534:	4603      	mov	r3, r0
        {
            if (fs->disk_io.write_media)
    2536:	6b45      	ldr	r5, [r0, #52]	; 0x34
    2538:	b16d      	cbz	r5, 2556 <fatfs_fat_writeback+0x2e>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
    253a:	f8d1 0200 	ldr.w	r0, [r1, #512]	; 0x200
    253e:	695a      	ldr	r2, [r3, #20]
    2540:	1a81      	subs	r1, r0, r2

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
    2542:	6a1a      	ldr	r2, [r3, #32]
    2544:	1c4b      	adds	r3, r1, #1
    2546:	4293      	cmp	r3, r2
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
    2548:	bf8c      	ite	hi
    254a:	1a52      	subhi	r2, r2, r1
                    sectors = FAT_BUFFER_SECTORS;
    254c:	2201      	movls	r2, #1

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
    254e:	4621      	mov	r1, r4
    2550:	47a8      	blx	r5
    2552:	4603      	mov	r3, r0
    2554:	b118      	cbz	r0, 255e <fatfs_fat_writeback+0x36>
                    return 0;
            }

            pcur->dirty = 0;
    2556:	2300      	movs	r3, #0
    2558:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
        }

        return 1;
    255c:	2301      	movs	r3, #1
    }
    else
        return 0;
}
    255e:	4618      	mov	r0, r3
    2560:	bd38      	pop	{r3, r4, r5, pc}
        return 0;
    2562:	2300      	movs	r3, #0
    2564:	e7fb      	b.n	255e <fatfs_fat_writeback+0x36>
        return 1;
    2566:	2301      	movs	r3, #1
    2568:	e7f9      	b.n	255e <fatfs_fat_writeback+0x36>
	...

0000256c <fatfs_fat_read_sector>:
//-----------------------------------------------------------------------------
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    256c:	b570      	push	{r4, r5, r6, lr}
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
    256e:	f8d0 4250 	ldr.w	r4, [r0, #592]	; 0x250

    // Itterate through sector buffer list
    while (pcur)
    2572:	b1ec      	cbz	r4, 25b0 <fatfs_fat_read_sector+0x44>
    2574:	2200      	movs	r2, #0
            // Remove buffer from list
            if (last)
                last->next = NULL;
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
    2576:	4616      	mov	r6, r2
    2578:	e004      	b.n	2584 <fatfs_fat_read_sector+0x18>
        if (pcur->next == NULL)
    257a:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
    257e:	b183      	cbz	r3, 25a2 <fatfs_fat_read_sector+0x36>
    while (pcur)
    2580:	4622      	mov	r2, r4
    2582:	461c      	mov	r4, r3
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
    2584:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
    2588:	428b      	cmp	r3, r1
    258a:	d8f6      	bhi.n	257a <fatfs_fat_read_sector+0xe>
    258c:	1c5d      	adds	r5, r3, #1
    258e:	42a9      	cmp	r1, r5
    2590:	d2f3      	bcs.n	257a <fatfs_fat_read_sector+0xe>
        last = pcur;
        pcur = pcur->next;
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    2592:	b354      	cbz	r4, 25ea <fatfs_fat_read_sector+0x7e>
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
    2594:	1acb      	subs	r3, r1, r3
    2596:	eb04 2343 	add.w	r3, r4, r3, lsl #9
    259a:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
        return NULL;
    }

    pcur->ptr = pcur->sector;
    return pcur;
}
    259e:	4620      	mov	r0, r4
    25a0:	bd70      	pop	{r4, r5, r6, pc}
            if (last)
    25a2:	b1fa      	cbz	r2, 25e4 <fatfs_fat_read_sector+0x78>
                last->next = NULL;
    25a4:	f8c2 620c 	str.w	r6, [r2, #524]	; 0x20c
        pcur = pcur->next;
    25a8:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
    while (pcur)
    25ac:	2b00      	cmp	r3, #0
    25ae:	d1e7      	bne.n	2580 <fatfs_fat_read_sector+0x14>
    25b0:	460d      	mov	r5, r1
    25b2:	4606      	mov	r6, r0
    pcur->next = fs->fat_buffer_head;
    25b4:	f8d0 3250 	ldr.w	r3, [r0, #592]	; 0x250
    25b8:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
    fs->fat_buffer_head = pcur;
    25bc:	f8c0 4250 	str.w	r4, [r0, #592]	; 0x250
    if (pcur->dirty)
    25c0:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
    25c4:	b11b      	cbz	r3, 25ce <fatfs_fat_read_sector+0x62>
        if (!fatfs_fat_writeback(fs, pcur))
    25c6:	4621      	mov	r1, r4
    25c8:	4b0d      	ldr	r3, [pc, #52]	; (2600 <fatfs_fat_read_sector+0x94>)
    25ca:	4798      	blx	r3
    25cc:	b1a8      	cbz	r0, 25fa <fatfs_fat_read_sector+0x8e>
    pcur->address = sector;
    25ce:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    25d2:	6b33      	ldr	r3, [r6, #48]	; 0x30
    25d4:	2201      	movs	r2, #1
    25d6:	4621      	mov	r1, r4
    25d8:	4628      	mov	r0, r5
    25da:	4798      	blx	r3
    25dc:	b138      	cbz	r0, 25ee <fatfs_fat_read_sector+0x82>
    pcur->ptr = pcur->sector;
    25de:	f8c4 4208 	str.w	r4, [r4, #520]	; 0x208
    return pcur;
    25e2:	e7dc      	b.n	259e <fatfs_fat_read_sector+0x32>
                fs->fat_buffer_head = NULL;
    25e4:	f8c0 6250 	str.w	r6, [r0, #592]	; 0x250
    25e8:	e7de      	b.n	25a8 <fatfs_fat_read_sector+0x3c>
    25ea:	4614      	mov	r4, r2
    25ec:	e7e0      	b.n	25b0 <fatfs_fat_read_sector+0x44>
        pcur->address = FAT32_INVALID_CLUSTER;
    25ee:	f04f 33ff 	mov.w	r3, #4294967295
    25f2:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        return NULL;
    25f6:	2400      	movs	r4, #0
    25f8:	e7d1      	b.n	259e <fatfs_fat_read_sector+0x32>
            return 0;
    25fa:	2400      	movs	r4, #0
    25fc:	e7cf      	b.n	259e <fatfs_fat_read_sector+0x32>
    25fe:	bf00      	nop
    2600:	00002529 	.word	0x00002529

00002604 <fatfs_fat_init>:
{
    2604:	b570      	push	{r4, r5, r6, lr}
    2606:	4604      	mov	r4, r0
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
    2608:	f04f 33ff 	mov.w	r3, #4294967295
    260c:	f8c0 3454 	str.w	r3, [r0, #1108]	; 0x454
        fs->fat_buffers[i].dirty = 0;
    2610:	2500      	movs	r5, #0
    2612:	f8c0 5458 	str.w	r5, [r0, #1112]	; 0x458
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
    2616:	f500 7615 	add.w	r6, r0, #596	; 0x254
    261a:	f44f 7200 	mov.w	r2, #512	; 0x200
    261e:	4629      	mov	r1, r5
    2620:	4630      	mov	r0, r6
    2622:	4b04      	ldr	r3, [pc, #16]	; (2634 <fatfs_fat_init+0x30>)
    2624:	4798      	blx	r3
        fs->fat_buffers[i].ptr = NULL;
    2626:	f8c4 545c 	str.w	r5, [r4, #1116]	; 0x45c
        fs->fat_buffers[i].next = fs->fat_buffer_head;
    262a:	f8c4 5460 	str.w	r5, [r4, #1120]	; 0x460
        fs->fat_buffer_head = &fs->fat_buffers[i];
    262e:	f8c4 6250 	str.w	r6, [r4, #592]	; 0x250
    2632:	bd70      	pop	{r4, r5, r6, pc}
    2634:	00003305 	.word	0x00003305

00002638 <fatfs_fat_purge>:
//-----------------------------------------------------------------------------
// fatfs_fat_purge: Purge 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
int fatfs_fat_purge(struct fatfs *fs)
{
    2638:	b570      	push	{r4, r5, r6, lr}
    struct fat_buffer *pcur = fs->fat_buffer_head;
    263a:	f8d0 4250 	ldr.w	r4, [r0, #592]	; 0x250

    // Itterate through sector buffer list
    while (pcur)
    263e:	b19c      	cbz	r4, 2668 <fatfs_fat_purge+0x30>
    2640:	4605      	mov	r5, r0
    {
        // Writeback sector if changed
        if (pcur->dirty)
            if (!fatfs_fat_writeback(fs, pcur))
    2642:	4e0a      	ldr	r6, [pc, #40]	; (266c <fatfs_fat_purge+0x34>)
    2644:	e002      	b.n	264c <fatfs_fat_purge+0x14>
                return 0;

        pcur = pcur->next;
    2646:	f8d4 420c 	ldr.w	r4, [r4, #524]	; 0x20c
    while (pcur)
    264a:	b154      	cbz	r4, 2662 <fatfs_fat_purge+0x2a>
        if (pcur->dirty)
    264c:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
    2650:	2b00      	cmp	r3, #0
    2652:	d0f8      	beq.n	2646 <fatfs_fat_purge+0xe>
            if (!fatfs_fat_writeback(fs, pcur))
    2654:	4621      	mov	r1, r4
    2656:	4628      	mov	r0, r5
    2658:	47b0      	blx	r6
    265a:	4603      	mov	r3, r0
    265c:	2800      	cmp	r0, #0
    265e:	d1f2      	bne.n	2646 <fatfs_fat_purge+0xe>
    2660:	e000      	b.n	2664 <fatfs_fat_purge+0x2c>
    }

    return 1;
    2662:	2301      	movs	r3, #1
}
    2664:	4618      	mov	r0, r3
    2666:	bd70      	pop	{r4, r5, r6, pc}
    return 1;
    2668:	2301      	movs	r3, #1
    266a:	e7fb      	b.n	2664 <fatfs_fat_purge+0x2c>
    266c:	00002529 	.word	0x00002529

00002670 <fatfs_find_next_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_next_cluster: Return cluster number of next cluster in chain by
// reading FAT table and traversing it. Return 0xffffffff for end of chain.
//-----------------------------------------------------------------------------
uint32 fatfs_find_next_cluster(struct fatfs *fs, uint32 current_cluster)
{
    2670:	b570      	push	{r4, r5, r6, lr}
    2672:	4606      	mov	r6, r0
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0)
    2674:	1e0c      	subs	r4, r1, #0
        current_cluster = 2;
    2676:	bf08      	it	eq
    2678:	2402      	moveq	r4, #2

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
    267a:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    267e:	b9e3      	cbnz	r3, 26ba <fatfs_find_next_cluster+0x4a>
        fat_sector_offset = current_cluster / 256;
    2680:	0a25      	lsrs	r5, r4, #8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    2682:	6971      	ldr	r1, [r6, #20]
    2684:	4429      	add	r1, r5
    2686:	4630      	mov	r0, r6
    2688:	4b1c      	ldr	r3, [pc, #112]	; (26fc <fatfs_find_next_cluster+0x8c>)
    268a:	4798      	blx	r3
    if (!pbuf)
    268c:	b390      	cbz	r0, 26f4 <fatfs_find_next_cluster+0x84>
        return (FAT32_LAST_CLUSTER);

    if (fs->fat_type == FAT_TYPE_16)
    268e:	f896 202d 	ldrb.w	r2, [r6, #45]	; 0x2d
    2692:	b9a2      	cbnz	r2, 26be <fatfs_find_next_cluster+0x4e>
    {
        // Find 32 bit entry of current sector relating to cluster number
        position = (current_cluster - (fat_sector_offset * 256)) * 2;

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    2694:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
        position = (current_cluster - (fat_sector_offset * 256)) * 2;
    2698:	eba4 2405 	sub.w	r4, r4, r5, lsl #8
    269c:	0064      	lsls	r4, r4, #1
    269e:	b2a4      	uxth	r4, r4
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    26a0:	191a      	adds	r2, r3, r4
    26a2:	7852      	ldrb	r2, [r2, #1]
    26a4:	5d18      	ldrb	r0, [r3, r4]
    26a6:	eb00 2002 	add.w	r0, r0, r2, lsl #8

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF)
    26aa:	f5a0 437f 	sub.w	r3, r0, #65280	; 0xff00
    26ae:	3bf8      	subs	r3, #248	; 0xf8
            return (FAT32_LAST_CLUSTER);
    26b0:	2b07      	cmp	r3, #7
    26b2:	bf98      	it	ls
    26b4:	f04f 30ff 	movls.w	r0, #4294967295
    26b8:	bd70      	pop	{r4, r5, r6, pc}
        fat_sector_offset = current_cluster / 128;
    26ba:	09e5      	lsrs	r5, r4, #7
    26bc:	e7e1      	b.n	2682 <fatfs_find_next_cluster+0x12>
    {
        // Find 32 bit entry of current sector relating to cluster number
        position = (current_cluster - (fat_sector_offset * 128)) * 4;

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    26be:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
        position = (current_cluster - (fat_sector_offset * 128)) * 4;
    26c2:	eba4 14c5 	sub.w	r4, r4, r5, lsl #7
    26c6:	00a4      	lsls	r4, r4, #2
    26c8:	b2a4      	uxth	r4, r4
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    26ca:	1913      	adds	r3, r2, r4
    26cc:	78d9      	ldrb	r1, [r3, #3]
    26ce:	7898      	ldrb	r0, [r3, #2]
    26d0:	0400      	lsls	r0, r0, #16
    26d2:	eb00 6001 	add.w	r0, r0, r1, lsl #24
    26d6:	5d12      	ldrb	r2, [r2, r4]
    26d8:	4410      	add	r0, r2
    26da:	785b      	ldrb	r3, [r3, #1]
    26dc:	eb00 2003 	add.w	r0, r0, r3, lsl #8

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;
    26e0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF)
    26e4:	f100 4370 	add.w	r3, r0, #4026531840	; 0xf0000000
    26e8:	3308      	adds	r3, #8
            return (FAT32_LAST_CLUSTER);
    26ea:	2b07      	cmp	r3, #7
    26ec:	bf98      	it	ls
    26ee:	f04f 30ff 	movls.w	r0, #4294967295
    26f2:	bd70      	pop	{r4, r5, r6, pc}
        return (FAT32_LAST_CLUSTER);
    26f4:	f04f 30ff 	mov.w	r0, #4294967295
    }

    // Else return next cluster
    return (nextcluster);
}
    26f8:	bd70      	pop	{r4, r5, r6, pc}
    26fa:	bf00      	nop
    26fc:	0000256d 	.word	0x0000256d

00002700 <fatfs_set_fs_info_next_free_cluster>:
//-----------------------------------------------------------------------------
// fatfs_set_fs_info_next_free_cluster: Write the next free cluster to the FSINFO table
//-----------------------------------------------------------------------------
void fatfs_set_fs_info_next_free_cluster(struct fatfs *fs, uint32 newValue)
{
    if (fs->fat_type == FAT_TYPE_16)
    2700:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    2704:	b903      	cbnz	r3, 2708 <fatfs_set_fs_info_next_free_cluster+0x8>
    2706:	4770      	bx	lr
{
    2708:	b570      	push	{r4, r5, r6, lr}
    270a:	460e      	mov	r6, r1
    270c:	4605      	mov	r5, r0
        ;
    else
    {
        // Load sector to change it
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
    270e:	8b01      	ldrh	r1, [r0, #24]
    2710:	69c3      	ldr	r3, [r0, #28]
    2712:	4419      	add	r1, r3
    2714:	4b14      	ldr	r3, [pc, #80]	; (2768 <fatfs_set_fs_info_next_free_cluster+0x68>)
    2716:	4798      	blx	r3
        if (!pbuf)
    2718:	4604      	mov	r4, r0
    271a:	b320      	cbz	r0, 2766 <fatfs_set_fs_info_next_free_cluster+0x66>
            return ;

        // Change
        FAT32_SET_32BIT_WORD(pbuf, 492, newValue);
    271c:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    2720:	f883 61ec 	strb.w	r6, [r3, #492]	; 0x1ec
    2724:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    2728:	0a32      	lsrs	r2, r6, #8
    272a:	f883 21ed 	strb.w	r2, [r3, #493]	; 0x1ed
    272e:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    2732:	0c32      	lsrs	r2, r6, #16
    2734:	f883 21ee 	strb.w	r2, [r3, #494]	; 0x1ee
    2738:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    273c:	0e32      	lsrs	r2, r6, #24
    273e:	f883 21ef 	strb.w	r2, [r3, #495]	; 0x1ef
    2742:	2301      	movs	r3, #1
    2744:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
        fs->next_free_cluster = newValue;
    2748:	626e      	str	r6, [r5, #36]	; 0x24

        // Write back FSINFO sector to disk
        if (fs->disk_io.write_media)
    274a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    274c:	b123      	cbz	r3, 2758 <fatfs_set_fs_info_next_free_cluster+0x58>
            fs->disk_io.write_media(pbuf->address, pbuf->sector, 1);
    274e:	2201      	movs	r2, #1
    2750:	4601      	mov	r1, r0
    2752:	f8d0 0200 	ldr.w	r0, [r0, #512]	; 0x200
    2756:	4798      	blx	r3

        // Invalidate cache entry
        pbuf->address = FAT32_INVALID_CLUSTER;
    2758:	f04f 33ff 	mov.w	r3, #4294967295
    275c:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        pbuf->dirty = 0;
    2760:	2300      	movs	r3, #0
    2762:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
    2766:	bd70      	pop	{r4, r5, r6, pc}
    2768:	0000256d 	.word	0x0000256d

0000276c <fatfs_find_blank_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_blank_cluster: Find a free cluster entry by reading the FAT
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_find_blank_cluster(struct fatfs *fs, uint32 start_cluster, uint32 *free_cluster)
{
    276c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2770:	4605      	mov	r5, r0
    2772:	460e      	mov	r6, r1
    2774:	4690      	mov	r8, r2
            fat_sector_offset = current_cluster / 128;

        if ( fat_sector_offset < fs->fat_sectors)
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    2776:	4f1f      	ldr	r7, [pc, #124]	; (27f4 <fatfs_find_blank_cluster+0x88>)
        if (fs->fat_type == FAT_TYPE_16)
    2778:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
    277c:	b9cb      	cbnz	r3, 27b2 <fatfs_find_blank_cluster+0x46>
            fat_sector_offset = current_cluster / 256;
    277e:	0a34      	lsrs	r4, r6, #8
        if ( fat_sector_offset < fs->fat_sectors)
    2780:	6a2b      	ldr	r3, [r5, #32]
    2782:	429c      	cmp	r4, r3
    2784:	d22b      	bcs.n	27de <fatfs_find_blank_cluster+0x72>
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    2786:	6969      	ldr	r1, [r5, #20]
    2788:	4421      	add	r1, r4
    278a:	4628      	mov	r0, r5
    278c:	47b8      	blx	r7
            if (!pbuf)
    278e:	b348      	cbz	r0, 27e4 <fatfs_find_blank_cluster+0x78>
                return 0;

            if (fs->fat_type == FAT_TYPE_16)
    2790:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    2794:	b97a      	cbnz	r2, 27b6 <fatfs_find_blank_cluster+0x4a>
            {
                // Find 32 bit entry of current sector relating to cluster number
                position = (current_cluster - (fat_sector_offset * 256)) * 2;

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    2796:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
                position = (current_cluster - (fat_sector_offset * 256)) * 2;
    279a:	eba6 2404 	sub.w	r4, r6, r4, lsl #8
    279e:	0064      	lsls	r4, r4, #1
    27a0:	b2a4      	uxth	r4, r4
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    27a2:	1913      	adds	r3, r2, r4
    27a4:	7859      	ldrb	r1, [r3, #1]
    27a6:	5d13      	ldrb	r3, [r2, r4]
    27a8:	eb03 2301 	add.w	r3, r3, r1, lsl #8

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;
            }

            if (nextcluster !=0 )
    27ac:	b1eb      	cbz	r3, 27ea <fatfs_find_blank_cluster+0x7e>
                current_cluster++;
    27ae:	3601      	adds	r6, #1
    27b0:	e7e2      	b.n	2778 <fatfs_find_blank_cluster+0xc>
            fat_sector_offset = current_cluster / 128;
    27b2:	09f4      	lsrs	r4, r6, #7
    27b4:	e7e4      	b.n	2780 <fatfs_find_blank_cluster+0x14>
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    27b6:	f8d0 1208 	ldr.w	r1, [r0, #520]	; 0x208
                position = (current_cluster - (fat_sector_offset * 128)) * 4;
    27ba:	eba6 14c4 	sub.w	r4, r6, r4, lsl #7
    27be:	00a4      	lsls	r4, r4, #2
    27c0:	b2a4      	uxth	r4, r4
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    27c2:	190a      	adds	r2, r1, r4
    27c4:	78d0      	ldrb	r0, [r2, #3]
    27c6:	7893      	ldrb	r3, [r2, #2]
    27c8:	041b      	lsls	r3, r3, #16
    27ca:	eb03 6300 	add.w	r3, r3, r0, lsl #24
    27ce:	5d09      	ldrb	r1, [r1, r4]
    27d0:	440b      	add	r3, r1
    27d2:	7852      	ldrb	r2, [r2, #1]
    27d4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
                nextcluster = nextcluster & 0x0FFFFFFF;
    27d8:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    27dc:	e7e6      	b.n	27ac <fatfs_find_blank_cluster+0x40>
        }
        else
            // Otherwise, run out of FAT sectors to check...
            return 0;
    27de:	2000      	movs	r0, #0
    27e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                return 0;
    27e4:	2000      	movs	r0, #0
    27e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    while (nextcluster != 0x0);

    // Found blank entry
    *free_cluster = current_cluster;
    27ea:	f8c8 6000 	str.w	r6, [r8]
    return 1;
    27ee:	2001      	movs	r0, #1
}
    27f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    27f4:	0000256d 	.word	0x0000256d

000027f8 <fatfs_fat_set_cluster>:
// fatfs_fat_set_cluster: Set a cluster link in the chain. NOTE: Immediate
// write (slow).
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_fat_set_cluster(struct fatfs *fs, uint32 cluster, uint32 next_cluster)
{
    27f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    27fa:	4607      	mov	r7, r0
    27fc:	460c      	mov	r4, r1
    27fe:	4615      	mov	r5, r2
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
    2800:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    2804:	bb23      	cbnz	r3, 2850 <fatfs_fat_set_cluster+0x58>
        fat_sector_offset = cluster / 256;
    2806:	0a0e      	lsrs	r6, r1, #8
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    2808:	6979      	ldr	r1, [r7, #20]
    280a:	4431      	add	r1, r6
    280c:	4638      	mov	r0, r7
    280e:	4b1b      	ldr	r3, [pc, #108]	; (287c <fatfs_fat_set_cluster+0x84>)
    2810:	4798      	blx	r3
    if (!pbuf)
    2812:	4603      	mov	r3, r0
    2814:	b378      	cbz	r0, 2876 <fatfs_fat_set_cluster+0x7e>
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
    2816:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
    281a:	b1da      	cbz	r2, 2854 <fatfs_fat_set_cluster+0x5c>
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));
    }
    else
    {
        // Find 32 bit entry of current sector relating to cluster number
        position = (cluster - (fat_sector_offset * 128)) * 4;
    281c:	eba4 14c6 	sub.w	r4, r4, r6, lsl #7
    2820:	00a4      	lsls	r4, r4, #2
    2822:	b2a4      	uxth	r4, r4

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);
    2824:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    2828:	5515      	strb	r5, [r2, r4]
    282a:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    282e:	4422      	add	r2, r4
    2830:	0a29      	lsrs	r1, r5, #8
    2832:	7051      	strb	r1, [r2, #1]
    2834:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    2838:	4422      	add	r2, r4
    283a:	0c29      	lsrs	r1, r5, #16
    283c:	7091      	strb	r1, [r2, #2]
    283e:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    2842:	4414      	add	r4, r2
    2844:	0e2d      	lsrs	r5, r5, #24
    2846:	70e5      	strb	r5, [r4, #3]
    2848:	2001      	movs	r0, #1
    284a:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
    284e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        fat_sector_offset = cluster / 128;
    2850:	09ce      	lsrs	r6, r1, #7
    2852:	e7d9      	b.n	2808 <fatfs_fat_set_cluster+0x10>
        position = (cluster - (fat_sector_offset * 256)) * 2;
    2854:	eba4 2406 	sub.w	r4, r4, r6, lsl #8
    2858:	0064      	lsls	r4, r4, #1
    285a:	b2a4      	uxth	r4, r4
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));
    285c:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    2860:	5515      	strb	r5, [r2, r4]
    2862:	f8d0 6208 	ldr.w	r6, [r0, #520]	; 0x208
    2866:	4434      	add	r4, r6
    2868:	f3c5 2507 	ubfx	r5, r5, #8, #8
    286c:	7065      	strb	r5, [r4, #1]
    286e:	2001      	movs	r0, #1
    2870:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
    2874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
    2876:	2000      	movs	r0, #0
    }

    return 1;
}
    2878:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    287a:	bf00      	nop
    287c:	0000256d 	.word	0x0000256d

00002880 <fatfs_free_cluster_chain>:
//-----------------------------------------------------------------------------
// fatfs_free_cluster_chain: Follow a chain marking each element as free
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_free_cluster_chain(struct fatfs *fs, uint32 start_cluster)
{
    2880:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;

    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
    2884:	1e4b      	subs	r3, r1, #1
    2886:	f113 0f03 	cmn.w	r3, #3
    288a:	d812      	bhi.n	28b2 <fatfs_free_cluster_chain+0x32>
    288c:	4681      	mov	r9, r0
    288e:	460d      	mov	r5, r1
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    2890:	4e09      	ldr	r6, [pc, #36]	; (28b8 <fatfs_free_cluster_chain+0x38>)

        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
    2892:	f04f 0800 	mov.w	r8, #0
    2896:	4f09      	ldr	r7, [pc, #36]	; (28bc <fatfs_free_cluster_chain+0x3c>)
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    2898:	4629      	mov	r1, r5
    289a:	4648      	mov	r0, r9
    289c:	47b0      	blx	r6
    289e:	4604      	mov	r4, r0
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
    28a0:	4642      	mov	r2, r8
    28a2:	4629      	mov	r1, r5
    28a4:	4648      	mov	r0, r9
    28a6:	47b8      	blx	r7
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    28a8:	4625      	mov	r5, r4
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
    28aa:	3c01      	subs	r4, #1
    28ac:	f114 0f03 	cmn.w	r4, #3
    28b0:	d9f2      	bls.n	2898 <fatfs_free_cluster_chain+0x18>
    }

    return 1;
}
    28b2:	2001      	movs	r0, #1
    28b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    28b8:	00002671 	.word	0x00002671
    28bc:	000027f9 	.word	0x000027f9

000028c0 <fatfs_fat_add_cluster_to_chain>:
int fatfs_fat_add_cluster_to_chain(struct fatfs *fs, uint32 start_cluster, uint32 newEntry)
{
    uint32 last_cluster = FAT32_LAST_CLUSTER;
    uint32 next_cluster = start_cluster;

    if (start_cluster == FAT32_LAST_CLUSTER)
    28c0:	f1b1 3fff 	cmp.w	r1, #4294967295
    28c4:	d01a      	beq.n	28fc <fatfs_fat_add_cluster_to_chain+0x3c>
{
    28c6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    28c8:	4605      	mov	r5, r0
    28ca:	460c      	mov	r4, r1
    28cc:	4617      	mov	r7, r2
    while ( next_cluster != FAT32_LAST_CLUSTER )
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    28ce:	4e0d      	ldr	r6, [pc, #52]	; (2904 <fatfs_fat_add_cluster_to_chain+0x44>)
    28d0:	e000      	b.n	28d4 <fatfs_fat_add_cluster_to_chain+0x14>
    28d2:	461c      	mov	r4, r3
    28d4:	4621      	mov	r1, r4
    28d6:	4628      	mov	r0, r5
    28d8:	47b0      	blx	r6
        if (!next_cluster)
    28da:	4603      	mov	r3, r0
    28dc:	b180      	cbz	r0, 2900 <fatfs_fat_add_cluster_to_chain+0x40>
    while ( next_cluster != FAT32_LAST_CLUSTER )
    28de:	f1b0 3fff 	cmp.w	r0, #4294967295
    28e2:	d1f6      	bne.n	28d2 <fatfs_fat_add_cluster_to_chain+0x12>
            return 0;
    }

    // Add link in for new cluster
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);
    28e4:	463a      	mov	r2, r7
    28e6:	4621      	mov	r1, r4
    28e8:	4628      	mov	r0, r5
    28ea:	4c07      	ldr	r4, [pc, #28]	; (2908 <fatfs_fat_add_cluster_to_chain+0x48>)
    28ec:	47a0      	blx	r4

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);
    28ee:	f04f 32ff 	mov.w	r2, #4294967295
    28f2:	4639      	mov	r1, r7
    28f4:	4628      	mov	r0, r5
    28f6:	47a0      	blx	r4

    return 1;
    28f8:	2001      	movs	r0, #1
    28fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
    28fc:	2000      	movs	r0, #0
    28fe:	4770      	bx	lr
            return 0;
    2900:	2000      	movs	r0, #0
}
    2902:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2904:	00002671 	.word	0x00002671
    2908:	000027f9 	.word	0x000027f9

0000290c <fatfs_add_free_space>:
//-----------------------------------------------------------------------------
// fatfs_add_free_space: Allocate another cluster of free space to the end
// of a files cluster chain.
//-----------------------------------------------------------------------------
int fatfs_add_free_space(struct fatfs *fs, uint32 *startCluster, uint32 clusters)
{
    290c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2910:	b082      	sub	sp, #8
    2912:	4604      	mov	r4, r0
    2914:	468a      	mov	sl, r1
    2916:	4690      	mov	r8, r2
    uint32 i;
    uint32 nextcluster;
    uint32 start = *startCluster;
    2918:	680e      	ldr	r6, [r1, #0]

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
    291a:	6a43      	ldr	r3, [r0, #36]	; 0x24
    291c:	f1b3 3fff 	cmp.w	r3, #4294967295
    2920:	d003      	beq.n	292a <fatfs_add_free_space+0x1e>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER);
    2922:	f04f 31ff 	mov.w	r1, #4294967295
    2926:	4b13      	ldr	r3, [pc, #76]	; (2974 <fatfs_add_free_space+0x68>)
    2928:	4798      	blx	r3

    for (i=0;i<clusters;i++)
    292a:	f1b8 0f00 	cmp.w	r8, #0
    292e:	d01f      	beq.n	2970 <fatfs_add_free_space+0x64>
    2930:	2500      	movs	r5, #0
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
    2932:	f8df 9048 	ldr.w	r9, [pc, #72]	; 297c <fatfs_add_free_space+0x70>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
    2936:	4f10      	ldr	r7, [pc, #64]	; (2978 <fatfs_add_free_space+0x6c>)
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
    2938:	aa01      	add	r2, sp, #4
    293a:	68a1      	ldr	r1, [r4, #8]
    293c:	4620      	mov	r0, r4
    293e:	47c8      	blx	r9
    2940:	4603      	mov	r3, r0
    2942:	b170      	cbz	r0, 2962 <fatfs_add_free_space+0x56>
            fatfs_fat_set_cluster(fs, start, nextcluster);
    2944:	9a01      	ldr	r2, [sp, #4]
    2946:	4631      	mov	r1, r6
    2948:	4620      	mov	r0, r4
    294a:	47b8      	blx	r7

            // Point this to end of file
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
    294c:	f04f 32ff 	mov.w	r2, #4294967295
    2950:	9901      	ldr	r1, [sp, #4]
    2952:	4620      	mov	r0, r4
    2954:	47b8      	blx	r7

            // Adjust argument reference
            start = nextcluster;
    2956:	9e01      	ldr	r6, [sp, #4]
            if (i == 0)
    2958:	b13d      	cbz	r5, 296a <fatfs_add_free_space+0x5e>
    for (i=0;i<clusters;i++)
    295a:	3501      	adds	r5, #1
    295c:	45a8      	cmp	r8, r5
    295e:	d1eb      	bne.n	2938 <fatfs_add_free_space+0x2c>
        }
        else
            return 0;
    }

    return 1;
    2960:	2301      	movs	r3, #1
}
    2962:	4618      	mov	r0, r3
    2964:	b002      	add	sp, #8
    2966:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                *startCluster = nextcluster;
    296a:	f8ca 6000 	str.w	r6, [sl]
    296e:	e7f4      	b.n	295a <fatfs_add_free_space+0x4e>
    return 1;
    2970:	2301      	movs	r3, #1
    2972:	e7f6      	b.n	2962 <fatfs_add_free_space+0x56>
    2974:	00002701 	.word	0x00002701
    2978:	000027f9 	.word	0x000027f9
    297c:	0000276d 	.word	0x0000276d

00002980 <fatfs_allocate_free_space>:
{
    uint32 clusterSize;
    uint32 clusterCount;
    uint32 nextcluster;

    if (size==0)
    2980:	2b00      	cmp	r3, #0
    2982:	d03c      	beq.n	29fe <fatfs_allocate_free_space+0x7e>
{
    2984:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2988:	b082      	sub	sp, #8
    298a:	461d      	mov	r5, r3
    298c:	4690      	mov	r8, r2
    298e:	460e      	mov	r6, r1
    2990:	4604      	mov	r4, r0
        return 0;

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
    2992:	6a43      	ldr	r3, [r0, #36]	; 0x24
    2994:	f1b3 3fff 	cmp.w	r3, #4294967295
    2998:	d003      	beq.n	29a2 <fatfs_allocate_free_space+0x22>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER);
    299a:	f04f 31ff 	mov.w	r1, #4294967295
    299e:	4b19      	ldr	r3, [pc, #100]	; (2a04 <fatfs_allocate_free_space+0x84>)
    29a0:	4798      	blx	r3

    // Work out size and clusters
    clusterSize = fs->sectors_per_cluster * FAT_SECTOR_SIZE;
    29a2:	7820      	ldrb	r0, [r4, #0]
    29a4:	0240      	lsls	r0, r0, #9
    clusterCount = (size / clusterSize);
    29a6:	fbb5 f7f0 	udiv	r7, r5, r0

    // If any left over
    if (size-(clusterSize*clusterCount))
    29aa:	fb07 f000 	mul.w	r0, r7, r0
    29ae:	4285      	cmp	r5, r0
        clusterCount++;
    29b0:	bf18      	it	ne
    29b2:	3701      	addne	r7, #1

    // Allocated first link in the chain if a new file
    if (newFile)
    29b4:	b976      	cbnz	r6, 29d4 <fatfs_allocate_free_space+0x54>
            return 1;
        }
    }
    // Allocate from end of current chain (startCluster is end of chain)
    else
        nextcluster = *startCluster;
    29b6:	f8d8 3000 	ldr.w	r3, [r8]
    29ba:	9301      	str	r3, [sp, #4]

    if (!fatfs_add_free_space(fs, &nextcluster, clusterCount))
    29bc:	463a      	mov	r2, r7
    29be:	a901      	add	r1, sp, #4
    29c0:	4620      	mov	r0, r4
    29c2:	4b11      	ldr	r3, [pc, #68]	; (2a08 <fatfs_allocate_free_space+0x88>)
    29c4:	4798      	blx	r3
    29c6:	1c03      	adds	r3, r0, #0
    29c8:	bf18      	it	ne
    29ca:	2301      	movne	r3, #1
            return 0;

    return 1;
}
    29cc:	4618      	mov	r0, r3
    29ce:	b002      	add	sp, #8
    29d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
    29d4:	aa01      	add	r2, sp, #4
    29d6:	68a1      	ldr	r1, [r4, #8]
    29d8:	4620      	mov	r0, r4
    29da:	4b0c      	ldr	r3, [pc, #48]	; (2a0c <fatfs_allocate_free_space+0x8c>)
    29dc:	4798      	blx	r3
    29de:	4603      	mov	r3, r0
    29e0:	2800      	cmp	r0, #0
    29e2:	d0f3      	beq.n	29cc <fatfs_allocate_free_space+0x4c>
        if (clusterCount==1)
    29e4:	2f01      	cmp	r7, #1
    29e6:	d1e9      	bne.n	29bc <fatfs_allocate_free_space+0x3c>
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
    29e8:	f04f 32ff 	mov.w	r2, #4294967295
    29ec:	9901      	ldr	r1, [sp, #4]
    29ee:	4620      	mov	r0, r4
    29f0:	4b07      	ldr	r3, [pc, #28]	; (2a10 <fatfs_allocate_free_space+0x90>)
    29f2:	4798      	blx	r3
            *startCluster = nextcluster;
    29f4:	9b01      	ldr	r3, [sp, #4]
    29f6:	f8c8 3000 	str.w	r3, [r8]
            return 1;
    29fa:	2301      	movs	r3, #1
    29fc:	e7e6      	b.n	29cc <fatfs_allocate_free_space+0x4c>
        return 0;
    29fe:	2300      	movs	r3, #0
}
    2a00:	4618      	mov	r0, r3
    2a02:	4770      	bx	lr
    2a04:	00002701 	.word	0x00002701
    2a08:	0000290d 	.word	0x0000290d
    2a0c:	0000276d 	.word	0x0000276d
    2a10:	000027f9 	.word	0x000027f9

00002a14 <fatfs_add_file_entry>:
}
//-----------------------------------------------------------------------------
// fatfs_add_file_entry: Add a directory entry to a location found by FindFreeOffset
//-----------------------------------------------------------------------------
int fatfs_add_file_entry(struct fatfs *fs, uint32 dirCluster, char *filename, char *shortfilename, uint32 startCluster, uint32 size, int dir)
{
    2a14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2a18:	b097      	sub	sp, #92	; 0x5c

    uint8 checksum;
    uint8 *pSname;

    // No write access?
    if (!fs->disk_io.write_media)
    2a1a:	6b44      	ldr	r4, [r0, #52]	; 0x34
    2a1c:	2c00      	cmp	r4, #0
    2a1e:	f000 80d3 	beq.w	2bc8 <fatfs_add_file_entry+0x1b4>
    2a22:	930a      	str	r3, [sp, #40]	; 0x28
    2a24:	9207      	str	r2, [sp, #28]
    2a26:	9109      	str	r1, [sp, #36]	; 0x24
    2a28:	9008      	str	r0, [sp, #32]
        return 0;

#if FATFS_INC_LFN_SUPPORT
    // How many LFN entries are required?
    // NOTE: We always request one LFN even if it would fit in a SFN!
    entryCount = fatfs_lfn_entries_required(filename);
    2a2a:	4610      	mov	r0, r2
    2a2c:	4b89      	ldr	r3, [pc, #548]	; (2c54 <fatfs_add_file_entry+0x240>)
    2a2e:	4798      	blx	r3
    if (!entryCount)
    2a30:	4607      	mov	r7, r0
    2a32:	b918      	cbnz	r0, 2a3c <fatfs_add_file_entry+0x28>
        else
            return 0;
    } // End of while loop

    return 0;
}
    2a34:	4638      	mov	r0, r7
    2a36:	b017      	add	sp, #92	; 0x5c
    2a38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (entryCount == 0)
    2a3c:	f110 0b01 	adds.w	fp, r0, #1
    2a40:	f000 80c4 	beq.w	2bcc <fatfs_add_file_entry+0x1b8>
    2a44:	2300      	movs	r3, #0
    2a46:	9305      	str	r3, [sp, #20]
    2a48:	9303      	str	r3, [sp, #12]
    2a4a:	461e      	mov	r6, r3
                if (fatfs_entry_lfn_text(directoryEntry))
    2a4c:	f8df 9220 	ldr.w	r9, [pc, #544]	; 2c70 <fatfs_add_file_entry+0x25c>
    2a50:	4698      	mov	r8, r3
    2a52:	9306      	str	r3, [sp, #24]
    2a54:	900b      	str	r0, [sp, #44]	; 0x2c
    2a56:	e04e      	b.n	2af6 <fatfs_add_file_entry+0xe2>
                    possible_spaces++;
    2a58:	3601      	adds	r6, #1
    2a5a:	3401      	adds	r4, #1
    2a5c:	3520      	adds	r5, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    2a5e:	2c10      	cmp	r4, #16
    2a60:	d047      	beq.n	2af2 <fatfs_add_file_entry+0xde>
    2a62:	b2e7      	uxtb	r7, r4
                if (fatfs_entry_lfn_text(directoryEntry))
    2a64:	4628      	mov	r0, r5
    2a66:	47c8      	blx	r9
    2a68:	b138      	cbz	r0, 2a7a <fatfs_add_file_entry+0x66>
                    if (possible_spaces == 0)
    2a6a:	2e00      	cmp	r6, #0
    2a6c:	d1f4      	bne.n	2a58 <fatfs_add_file_entry+0x44>
    2a6e:	9705      	str	r7, [sp, #20]
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2a70:	9b04      	ldr	r3, [sp, #16]
    2a72:	9306      	str	r3, [sp, #24]
                        start_recorded = 1;
    2a74:	f8cd a00c 	str.w	sl, [sp, #12]
    2a78:	e7ee      	b.n	2a58 <fatfs_add_file_entry+0x44>
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
    2a7a:	782a      	ldrb	r2, [r5, #0]
    2a7c:	2ae5      	cmp	r2, #229	; 0xe5
    2a7e:	d028      	beq.n	2ad2 <fatfs_add_file_entry+0xbe>
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
    2a80:	bba2      	cbnz	r2, 2aec <fatfs_add_file_entry+0xd8>
                        if (possible_spaces == 0)
    2a82:	b926      	cbnz	r6, 2a8e <fatfs_add_file_entry+0x7a>
    2a84:	9705      	str	r7, [sp, #20]
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2a86:	9b04      	ldr	r3, [sp, #16]
    2a88:	9306      	str	r3, [sp, #24]
                            start_recorded = 1;
    2a8a:	f8cd a00c 	str.w	sl, [sp, #12]
                        possible_spaces++;
    2a8e:	3601      	adds	r6, #1
                        if (possible_spaces >= entryCount)
    2a90:	45b3      	cmp	fp, r6
    2a92:	dce2      	bgt.n	2a5a <fatfs_add_file_entry+0x46>
    2a94:	f8dd a018 	ldr.w	sl, [sp, #24]
    2a98:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    2a9a:	990a      	ldr	r1, [sp, #40]	; 0x28
    2a9c:	f101 000b 	add.w	r0, r1, #11
            for (i=0;i<fs->sectors_per_cluster;i++)
    2aa0:	2500      	movs	r5, #0
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
    2aa2:	f005 0201 	and.w	r2, r5, #1
    2aa6:	f811 3b01 	ldrb.w	r3, [r1], #1
    2aaa:	eb03 0355 	add.w	r3, r3, r5, lsr #1
    2aae:	eb03 13c2 	add.w	r3, r3, r2, lsl #7
    2ab2:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    2ab6:	4281      	cmp	r1, r0
    2ab8:	d1f3      	bne.n	2aa2 <fatfs_add_file_entry+0x8e>
    2aba:	46d1      	mov	r9, sl
    2abc:	f04f 0800 	mov.w	r8, #0
    2ac0:	f8cd 800c 	str.w	r8, [sp, #12]
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum);
    2ac4:	f8df b1ac 	ldr.w	fp, [pc, #428]	; 2c74 <fatfs_add_file_entry+0x260>
    2ac8:	9506      	str	r5, [sp, #24]
    2aca:	4646      	mov	r6, r8
    2acc:	f8dd 8014 	ldr.w	r8, [sp, #20]
    2ad0:	e05f      	b.n	2b92 <fatfs_add_file_entry+0x17e>
                        if (possible_spaces == 0)
    2ad2:	b926      	cbnz	r6, 2ade <fatfs_add_file_entry+0xca>
    2ad4:	9705      	str	r7, [sp, #20]
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2ad6:	9b04      	ldr	r3, [sp, #16]
    2ad8:	9306      	str	r3, [sp, #24]
                            start_recorded = 1;
    2ada:	f8cd a00c 	str.w	sl, [sp, #12]
                        possible_spaces++;
    2ade:	3601      	adds	r6, #1
                        if (possible_spaces >= entryCount)
    2ae0:	45b3      	cmp	fp, r6
    2ae2:	dcba      	bgt.n	2a5a <fatfs_add_file_entry+0x46>
    2ae4:	f8dd a018 	ldr.w	sl, [sp, #24]
    2ae8:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    2aea:	e7d6      	b.n	2a9a <fatfs_add_file_entry+0x86>
                        start_recorded = 0;
    2aec:	9003      	str	r0, [sp, #12]
                        possible_spaces = 0;
    2aee:	4606      	mov	r6, r0
    2af0:	e7b3      	b.n	2a5a <fatfs_add_file_entry+0x46>
    2af2:	f108 0801 	add.w	r8, r8, #1
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2af6:	f8cd 8010 	str.w	r8, [sp, #16]
    2afa:	2300      	movs	r3, #0
    2afc:	4642      	mov	r2, r8
    2afe:	9909      	ldr	r1, [sp, #36]	; 0x24
    2b00:	9d08      	ldr	r5, [sp, #32]
    2b02:	4628      	mov	r0, r5
    2b04:	4c54      	ldr	r4, [pc, #336]	; (2c58 <fatfs_add_file_entry+0x244>)
    2b06:	47a0      	blx	r4
    2b08:	4604      	mov	r4, r0
    2b0a:	b120      	cbz	r0, 2b16 <fatfs_add_file_entry+0x102>
    2b0c:	3540      	adds	r5, #64	; 0x40
    2b0e:	2400      	movs	r4, #0
                            start_recorded = 1;
    2b10:	f04f 0a01 	mov.w	sl, #1
    2b14:	e7a5      	b.n	2a62 <fatfs_add_file_entry+0x4e>
    2b16:	f8dd a018 	ldr.w	sl, [sp, #24]
    2b1a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
            if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &newCluster))
    2b1c:	aa0d      	add	r2, sp, #52	; 0x34
    2b1e:	9808      	ldr	r0, [sp, #32]
    2b20:	6881      	ldr	r1, [r0, #8]
    2b22:	4b4e      	ldr	r3, [pc, #312]	; (2c5c <fatfs_add_file_entry+0x248>)
    2b24:	4798      	blx	r3
    2b26:	b908      	cbnz	r0, 2b2c <fatfs_add_file_entry+0x118>
        return 0;
    2b28:	4627      	mov	r7, r4
    2b2a:	e783      	b.n	2a34 <fatfs_add_file_entry+0x20>
            if (!fatfs_fat_add_cluster_to_chain(fs, dirCluster, newCluster))
    2b2c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    2b2e:	9909      	ldr	r1, [sp, #36]	; 0x24
    2b30:	9808      	ldr	r0, [sp, #32]
    2b32:	4b4b      	ldr	r3, [pc, #300]	; (2c60 <fatfs_add_file_entry+0x24c>)
    2b34:	4798      	blx	r3
    2b36:	2800      	cmp	r0, #0
    2b38:	d0f6      	beq.n	2b28 <fatfs_add_file_entry+0x114>
            memset(fs->currentsector.sector, 0x00, FAT_SECTOR_SIZE);
    2b3a:	f44f 7200 	mov.w	r2, #512	; 0x200
    2b3e:	2100      	movs	r1, #0
    2b40:	9d08      	ldr	r5, [sp, #32]
    2b42:	f105 0040 	add.w	r0, r5, #64	; 0x40
    2b46:	4b47      	ldr	r3, [pc, #284]	; (2c64 <fatfs_add_file_entry+0x250>)
    2b48:	4798      	blx	r3
            for (i=0;i<fs->sectors_per_cluster;i++)
    2b4a:	782b      	ldrb	r3, [r5, #0]
    2b4c:	b18b      	cbz	r3, 2b72 <fatfs_add_file_entry+0x15e>
    2b4e:	2500      	movs	r5, #0
                if (!fatfs_write_sector(fs, newCluster, i, 0))
    2b50:	46a8      	mov	r8, r5
    2b52:	4e45      	ldr	r6, [pc, #276]	; (2c68 <fatfs_add_file_entry+0x254>)
    2b54:	4643      	mov	r3, r8
    2b56:	462a      	mov	r2, r5
    2b58:	990d      	ldr	r1, [sp, #52]	; 0x34
    2b5a:	f8dd 9020 	ldr.w	r9, [sp, #32]
    2b5e:	4648      	mov	r0, r9
    2b60:	47b0      	blx	r6
    2b62:	2800      	cmp	r0, #0
    2b64:	d0e0      	beq.n	2b28 <fatfs_add_file_entry+0x114>
            for (i=0;i<fs->sectors_per_cluster;i++)
    2b66:	3501      	adds	r5, #1
    2b68:	b2ed      	uxtb	r5, r5
    2b6a:	f899 3000 	ldrb.w	r3, [r9]
    2b6e:	42ab      	cmp	r3, r5
    2b70:	d8f0      	bhi.n	2b54 <fatfs_add_file_entry+0x140>
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2b72:	9b04      	ldr	r3, [sp, #16]
    2b74:	4619      	mov	r1, r3
    2b76:	9a03      	ldr	r2, [sp, #12]
    2b78:	2a00      	cmp	r2, #0
    2b7a:	bf08      	it	eq
    2b7c:	468a      	moveq	sl, r1
    2b7e:	2a00      	cmp	r2, #0
    2b80:	9b05      	ldr	r3, [sp, #20]
    2b82:	bf08      	it	eq
    2b84:	2300      	moveq	r3, #0
    2b86:	9305      	str	r3, [sp, #20]
    2b88:	e787      	b.n	2a9a <fatfs_add_file_entry+0x86>
            if (dirtySector)
    2b8a:	9b03      	ldr	r3, [sp, #12]
    2b8c:	b973      	cbnz	r3, 2bac <fatfs_add_file_entry+0x198>
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2b8e:	f109 0901 	add.w	r9, r9, #1
    2b92:	2300      	movs	r3, #0
    2b94:	464a      	mov	r2, r9
    2b96:	9909      	ldr	r1, [sp, #36]	; 0x24
    2b98:	9d08      	ldr	r5, [sp, #32]
    2b9a:	4628      	mov	r0, r5
    2b9c:	4c2e      	ldr	r4, [pc, #184]	; (2c58 <fatfs_add_file_entry+0x244>)
    2b9e:	47a0      	blx	r4
    2ba0:	b1b0      	cbz	r0, 2bd0 <fatfs_add_file_entry+0x1bc>
    2ba2:	3540      	adds	r5, #64	; 0x40
    2ba4:	2400      	movs	r4, #0
                        dirtySector = 1;
    2ba6:	2301      	movs	r3, #1
    2ba8:	9304      	str	r3, [sp, #16]
    2baa:	e023      	b.n	2bf4 <fatfs_add_file_entry+0x1e0>
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
    2bac:	9808      	ldr	r0, [sp, #32]
    2bae:	6b43      	ldr	r3, [r0, #52]	; 0x34
    2bb0:	2201      	movs	r2, #1
    2bb2:	4601      	mov	r1, r0
    2bb4:	3140      	adds	r1, #64	; 0x40
    2bb6:	f8d0 0240 	ldr.w	r0, [r0, #576]	; 0x240
    2bba:	4798      	blx	r3
    2bbc:	b110      	cbz	r0, 2bc4 <fatfs_add_file_entry+0x1b0>
                dirtySector = 0;
    2bbe:	2300      	movs	r3, #0
    2bc0:	9303      	str	r3, [sp, #12]
    2bc2:	e7e4      	b.n	2b8e <fatfs_add_file_entry+0x17a>
                    return 0;
    2bc4:	4607      	mov	r7, r0
    2bc6:	e735      	b.n	2a34 <fatfs_add_file_entry+0x20>
        return 0;
    2bc8:	2700      	movs	r7, #0
    2bca:	e733      	b.n	2a34 <fatfs_add_file_entry+0x20>
        return 0;
    2bcc:	465f      	mov	r7, fp
    2bce:	e731      	b.n	2a34 <fatfs_add_file_entry+0x20>
            return 0;
    2bd0:	4607      	mov	r7, r0
    2bd2:	e72f      	b.n	2a34 <fatfs_add_file_entry+0x20>
    2bd4:	0163      	lsls	r3, r4, #5
    2bd6:	b29b      	uxth	r3, r3
                    if (entryCount==0)
    2bd8:	b1a7      	cbz	r7, 2c04 <fatfs_add_file_entry+0x1f0>
                        entryCount--;
    2bda:	3f01      	subs	r7, #1
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum);
    2bdc:	9b06      	ldr	r3, [sp, #24]
    2bde:	463a      	mov	r2, r7
    2be0:	4629      	mov	r1, r5
    2be2:	9807      	ldr	r0, [sp, #28]
    2be4:	47d8      	blx	fp
    2be6:	2601      	movs	r6, #1
                        dirtySector = 1;
    2be8:	9b04      	ldr	r3, [sp, #16]
    2bea:	9303      	str	r3, [sp, #12]
    2bec:	3401      	adds	r4, #1
    2bee:	3520      	adds	r5, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    2bf0:	2c10      	cmp	r4, #16
    2bf2:	d0ca      	beq.n	2b8a <fatfs_add_file_entry+0x176>
                if (foundEnd==0)
    2bf4:	2e00      	cmp	r6, #0
    2bf6:	d1ed      	bne.n	2bd4 <fatfs_add_file_entry+0x1c0>
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
    2bf8:	45d1      	cmp	r9, sl
    2bfa:	d1f7      	bne.n	2bec <fatfs_add_file_entry+0x1d8>
    2bfc:	b2e3      	uxtb	r3, r4
    2bfe:	4598      	cmp	r8, r3
    2c00:	d1f4      	bne.n	2bec <fatfs_add_file_entry+0x1d8>
    2c02:	e7e7      	b.n	2bd4 <fatfs_add_file_entry+0x1c0>
    2c04:	4698      	mov	r8, r3
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
    2c06:	9b22      	ldr	r3, [sp, #136]	; 0x88
    2c08:	9300      	str	r3, [sp, #0]
    2c0a:	ab0e      	add	r3, sp, #56	; 0x38
    2c0c:	9a20      	ldr	r2, [sp, #128]	; 0x80
    2c0e:	9921      	ldr	r1, [sp, #132]	; 0x84
    2c10:	980a      	ldr	r0, [sp, #40]	; 0x28
    2c12:	4c16      	ldr	r4, [pc, #88]	; (2c6c <fatfs_add_file_entry+0x258>)
    2c14:	47a0      	blx	r4
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));
    2c16:	9e08      	ldr	r6, [sp, #32]
    2c18:	44b0      	add	r8, r6
    2c1a:	ac0e      	add	r4, sp, #56	; 0x38
    2c1c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    2c1e:	f8c8 0040 	str.w	r0, [r8, #64]	; 0x40
    2c22:	f8c8 1044 	str.w	r1, [r8, #68]	; 0x44
    2c26:	f8c8 2048 	str.w	r2, [r8, #72]	; 0x48
    2c2a:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
    2c2e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    2c30:	f8c8 0050 	str.w	r0, [r8, #80]	; 0x50
    2c34:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
    2c38:	f8c8 2058 	str.w	r2, [r8, #88]	; 0x58
    2c3c:	f8c8 305c 	str.w	r3, [r8, #92]	; 0x5c
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
    2c40:	6b73      	ldr	r3, [r6, #52]	; 0x34
    2c42:	2201      	movs	r2, #1
    2c44:	4631      	mov	r1, r6
    2c46:	3140      	adds	r1, #64	; 0x40
    2c48:	f8d6 0240 	ldr.w	r0, [r6, #576]	; 0x240
    2c4c:	4798      	blx	r3
    2c4e:	4607      	mov	r7, r0
    2c50:	e6f0      	b.n	2a34 <fatfs_add_file_entry+0x20>
    2c52:	bf00      	nop
    2c54:	00001f99 	.word	0x00001f99
    2c58:	00000d11 	.word	0x00000d11
    2c5c:	0000276d 	.word	0x0000276d
    2c60:	000028c1 	.word	0x000028c1
    2c64:	00003305 	.word	0x00003305
    2c68:	00000da1 	.word	0x00000da1
    2c6c:	00002071 	.word	0x00002071
    2c70:	00001eed 	.word	0x00001eed
    2c74:	00001fbd 	.word	0x00001fbd

00002c78 <media_read>:
uint32_t Rx = GPIO_PC26;
uint32_t Tx = GPIO_PC27;

int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
	unsigned long i;
	for (i=0;i<sector_count;i++){
    2c78:	b17a      	cbz	r2, 2c9a <media_read+0x22>
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
    2c7a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2c7c:	4604      	mov	r4, r0
    2c7e:	460d      	mov	r5, r1
    2c80:	4616      	mov	r6, r2
    2c82:	4406      	add	r6, r0
		SD_read_single_block(sector, buffer);
    2c84:	4f06      	ldr	r7, [pc, #24]	; (2ca0 <media_read+0x28>)
    2c86:	4629      	mov	r1, r5
    2c88:	4620      	mov	r0, r4
    2c8a:	47b8      	blx	r7
		sector ++;
    2c8c:	3401      	adds	r4, #1
		buffer += 512;
    2c8e:	f505 7500 	add.w	r5, r5, #512	; 0x200
	for (i=0;i<sector_count;i++){
    2c92:	42a6      	cmp	r6, r4
    2c94:	d1f7      	bne.n	2c86 <media_read+0xe>
	}
	return 1;
}
    2c96:	2001      	movs	r0, #1
    2c98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2c9a:	2001      	movs	r0, #1
    2c9c:	4770      	bx	lr
    2c9e:	bf00      	nop
    2ca0:	000004bd 	.word	0x000004bd

00002ca4 <media_write>:

int media_write(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
	unsigned long i;
	for (i=0;i<sector_count;i++){
    2ca4:	b17a      	cbz	r2, 2cc6 <media_write+0x22>
int media_write(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
    2ca6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ca8:	4604      	mov	r4, r0
    2caa:	460d      	mov	r5, r1
    2cac:	4616      	mov	r6, r2
    2cae:	4406      	add	r6, r0
		SD_write_single_block(sector, buffer);
    2cb0:	4f06      	ldr	r7, [pc, #24]	; (2ccc <media_write+0x28>)
    2cb2:	4629      	mov	r1, r5
    2cb4:	4620      	mov	r0, r4
    2cb6:	47b8      	blx	r7
		sector ++;
    2cb8:	3401      	adds	r4, #1
		buffer += 512;
    2cba:	f505 7500 	add.w	r5, r5, #512	; 0x200
	for (i=0;i<sector_count;i++){
    2cbe:	42a6      	cmp	r6, r4
    2cc0:	d1f7      	bne.n	2cb2 <media_write+0xe>
	}
	return 1;
}
    2cc2:	2001      	movs	r0, #1
    2cc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2cc6:	2001      	movs	r0, #1
    2cc8:	4770      	bx	lr
    2cca:	bf00      	nop
    2ccc:	00000459 	.word	0x00000459

00002cd0 <print_file>:
	fl_shutdown();
	throw_error();
}

#ifdef _debug_
void print_file(FL_FILE *file){
    2cd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2cd4:	af00      	add	r7, sp, #0
    2cd6:	4605      	mov	r5, r0
	char read_data[file->filelength] ;
    2cd8:	68c2      	ldr	r2, [r0, #12]
    2cda:	1dd3      	adds	r3, r2, #7
    2cdc:	f023 0307 	bic.w	r3, r3, #7
    2ce0:	ebad 0d03 	sub.w	sp, sp, r3
	fl_fread(read_data, 1, file->filelength, file);
    2ce4:	4603      	mov	r3, r0
    2ce6:	2101      	movs	r1, #1
    2ce8:	4668      	mov	r0, sp
    2cea:	4c0b      	ldr	r4, [pc, #44]	; (2d18 <print_file+0x48>)
    2cec:	47a0      	blx	r4
	USART_newline();
    2cee:	4b0b      	ldr	r3, [pc, #44]	; (2d1c <print_file+0x4c>)
    2cf0:	4798      	blx	r3
	for (uint8_t i = 0; i < file->filelength; i++){
    2cf2:	68eb      	ldr	r3, [r5, #12]
    2cf4:	b16b      	cbz	r3, 2d12 <print_file+0x42>
    2cf6:	466e      	mov	r6, sp
    2cf8:	2400      	movs	r4, #0
		USART_printf("%c",read_data[i]);
    2cfa:	f8df 9024 	ldr.w	r9, [pc, #36]	; 2d20 <print_file+0x50>
    2cfe:	f8df 8024 	ldr.w	r8, [pc, #36]	; 2d24 <print_file+0x54>
    2d02:	5d31      	ldrb	r1, [r6, r4]
    2d04:	4648      	mov	r0, r9
    2d06:	47c0      	blx	r8
	for (uint8_t i = 0; i < file->filelength; i++){
    2d08:	3401      	adds	r4, #1
    2d0a:	b2e4      	uxtb	r4, r4
    2d0c:	68eb      	ldr	r3, [r5, #12]
    2d0e:	429c      	cmp	r4, r3
    2d10:	d3f7      	bcc.n	2d02 <print_file+0x32>
	}
}
    2d12:	46bd      	mov	sp, r7
    2d14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2d18:	00001b69 	.word	0x00001b69
    2d1c:	000006a9 	.word	0x000006a9
    2d20:	000037e8 	.word	0x000037e8
    2d24:	00000771 	.word	0x00000771

00002d28 <main>:
{
    2d28:	b530      	push	{r4, r5, lr}
    2d2a:	b09d      	sub	sp, #116	; 0x74
	SystemInit();
    2d2c:	4b27      	ldr	r3, [pc, #156]	; (2dcc <main+0xa4>)
    2d2e:	4798      	blx	r3
	RCFAST_init();
    2d30:	4b27      	ldr	r3, [pc, #156]	; (2dd0 <main+0xa8>)
    2d32:	4798      	blx	r3
	SPI_init();
    2d34:	4b27      	ldr	r3, [pc, #156]	; (2dd4 <main+0xac>)
    2d36:	4798      	blx	r3
	USART_init(Tx, Rx);
    2d38:	4b27      	ldr	r3, [pc, #156]	; (2dd8 <main+0xb0>)
    2d3a:	6819      	ldr	r1, [r3, #0]
    2d3c:	6858      	ldr	r0, [r3, #4]
    2d3e:	4b27      	ldr	r3, [pc, #156]	; (2ddc <main+0xb4>)
    2d40:	4798      	blx	r3
	USART_newline();
    2d42:	4c27      	ldr	r4, [pc, #156]	; (2de0 <main+0xb8>)
    2d44:	47a0      	blx	r4
	USART_printf("System init begin");
    2d46:	4827      	ldr	r0, [pc, #156]	; (2de4 <main+0xbc>)
    2d48:	4b27      	ldr	r3, [pc, #156]	; (2de8 <main+0xc0>)
    2d4a:	4798      	blx	r3
	USART_newline();
    2d4c:	47a0      	blx	r4
	SD_init();
    2d4e:	4b27      	ldr	r3, [pc, #156]	; (2dec <main+0xc4>)
    2d50:	4798      	blx	r3
	fl_init();
    2d52:	4b27      	ldr	r3, [pc, #156]	; (2df0 <main+0xc8>)
    2d54:	4798      	blx	r3
	if (fl_attach_media(media_read, media_write) != FAT_INIT_OK)
    2d56:	4927      	ldr	r1, [pc, #156]	; (2df4 <main+0xcc>)
    2d58:	4827      	ldr	r0, [pc, #156]	; (2df8 <main+0xd0>)
    2d5a:	4b28      	ldr	r3, [pc, #160]	; (2dfc <main+0xd4>)
    2d5c:	4798      	blx	r3
    2d5e:	2800      	cmp	r0, #0
    2d60:	d128      	bne.n	2db4 <main+0x8c>
	file = fl_fopen("/test.txt", "w");
    2d62:	4927      	ldr	r1, [pc, #156]	; (2e00 <main+0xd8>)
    2d64:	4827      	ldr	r0, [pc, #156]	; (2e04 <main+0xdc>)
    2d66:	4b28      	ldr	r3, [pc, #160]	; (2e08 <main+0xe0>)
    2d68:	4798      	blx	r3
	if (file){
    2d6a:	4604      	mov	r4, r0
    2d6c:	2800      	cmp	r0, #0
    2d6e:	d025      	beq.n	2dbc <main+0x94>
		volatile char data[] = "Once upon a time there was a small file that lived on a SD card. This file was composed of two sentences.";
    2d70:	256a      	movs	r5, #106	; 0x6a
    2d72:	462a      	mov	r2, r5
    2d74:	4925      	ldr	r1, [pc, #148]	; (2e0c <main+0xe4>)
    2d76:	a801      	add	r0, sp, #4
    2d78:	4b25      	ldr	r3, [pc, #148]	; (2e10 <main+0xe8>)
    2d7a:	4798      	blx	r3
		if (fl_fwrite(data, 1, sizeof(data), file) != sizeof(data)){
    2d7c:	4623      	mov	r3, r4
    2d7e:	462a      	mov	r2, r5
    2d80:	2101      	movs	r1, #1
    2d82:	a801      	add	r0, sp, #4
    2d84:	4d23      	ldr	r5, [pc, #140]	; (2e14 <main+0xec>)
    2d86:	47a8      	blx	r5
    2d88:	286a      	cmp	r0, #106	; 0x6a
    2d8a:	d002      	beq.n	2d92 <main+0x6a>
			USART_printf("ERROR: Write file failed\n");
    2d8c:	4822      	ldr	r0, [pc, #136]	; (2e18 <main+0xf0>)
    2d8e:	4b16      	ldr	r3, [pc, #88]	; (2de8 <main+0xc0>)
    2d90:	4798      	blx	r3
	fl_fclose(file);
    2d92:	4620      	mov	r0, r4
    2d94:	4b21      	ldr	r3, [pc, #132]	; (2e1c <main+0xf4>)
    2d96:	4798      	blx	r3
	file2 = fl_fopen("/test.txt", "r");
    2d98:	4921      	ldr	r1, [pc, #132]	; (2e20 <main+0xf8>)
    2d9a:	481a      	ldr	r0, [pc, #104]	; (2e04 <main+0xdc>)
    2d9c:	4b1a      	ldr	r3, [pc, #104]	; (2e08 <main+0xe0>)
    2d9e:	4798      	blx	r3
	if (file2){
    2da0:	b180      	cbz	r0, 2dc4 <main+0x9c>
		print_file(file2); //only in debug mode
    2da2:	4b20      	ldr	r3, [pc, #128]	; (2e24 <main+0xfc>)
    2da4:	4798      	blx	r3
	fl_shutdown();
    2da6:	4b20      	ldr	r3, [pc, #128]	; (2e28 <main+0x100>)
    2da8:	4798      	blx	r3
	throw_error();
    2daa:	4b20      	ldr	r3, [pc, #128]	; (2e2c <main+0x104>)
    2dac:	4798      	blx	r3
}
    2dae:	2000      	movs	r0, #0
    2db0:	b01d      	add	sp, #116	; 0x74
    2db2:	bd30      	pop	{r4, r5, pc}
        USART_printf("ERROR: Media attach failed\n");
    2db4:	481e      	ldr	r0, [pc, #120]	; (2e30 <main+0x108>)
    2db6:	4b0c      	ldr	r3, [pc, #48]	; (2de8 <main+0xc0>)
    2db8:	4798      	blx	r3
    2dba:	e7d2      	b.n	2d62 <main+0x3a>
		USART_printf("ERROR: Create file failed\n");
    2dbc:	481d      	ldr	r0, [pc, #116]	; (2e34 <main+0x10c>)
    2dbe:	4b0a      	ldr	r3, [pc, #40]	; (2de8 <main+0xc0>)
    2dc0:	4798      	blx	r3
    2dc2:	e7e6      	b.n	2d92 <main+0x6a>
		USART_printf("ERROR: open file failed\n");
    2dc4:	481c      	ldr	r0, [pc, #112]	; (2e38 <main+0x110>)
    2dc6:	4b08      	ldr	r3, [pc, #32]	; (2de8 <main+0xc0>)
    2dc8:	4798      	blx	r3
    2dca:	e7ec      	b.n	2da6 <main+0x7e>
    2dcc:	00000a3d 	.word	0x00000a3d
    2dd0:	00000981 	.word	0x00000981
    2dd4:	000001ed 	.word	0x000001ed
    2dd8:	20000010 	.word	0x20000010
    2ddc:	00000709 	.word	0x00000709
    2de0:	000006a9 	.word	0x000006a9
    2de4:	000037ec 	.word	0x000037ec
    2de8:	00000771 	.word	0x00000771
    2dec:	000005a5 	.word	0x000005a5
    2df0:	000015a9 	.word	0x000015a9
    2df4:	00002ca5 	.word	0x00002ca5
    2df8:	00002c79 	.word	0x00002c79
    2dfc:	000015d9 	.word	0x000015d9
    2e00:	0000381c 	.word	0x0000381c
    2e04:	00003820 	.word	0x00003820
    2e08:	0000164d 	.word	0x0000164d
    2e0c:	00003884 	.word	0x00003884
    2e10:	000031d1 	.word	0x000031d1
    2e14:	00001c89 	.word	0x00001c89
    2e18:	0000382c 	.word	0x0000382c
    2e1c:	00001ae9 	.word	0x00001ae9
    2e20:	00003864 	.word	0x00003864
    2e24:	00002cd1 	.word	0x00002cd1
    2e28:	00001615 	.word	0x00001615
    2e2c:	00000841 	.word	0x00000841
    2e30:	00003800 	.word	0x00003800
    2e34:	00003848 	.word	0x00003848
    2e38:	00003868 	.word	0x00003868

00002e3c <__aeabi_uldivmod>:
    2e3c:	b953      	cbnz	r3, 2e54 <__aeabi_uldivmod+0x18>
    2e3e:	b94a      	cbnz	r2, 2e54 <__aeabi_uldivmod+0x18>
    2e40:	2900      	cmp	r1, #0
    2e42:	bf08      	it	eq
    2e44:	2800      	cmpeq	r0, #0
    2e46:	bf1c      	itt	ne
    2e48:	f04f 31ff 	movne.w	r1, #4294967295
    2e4c:	f04f 30ff 	movne.w	r0, #4294967295
    2e50:	f000 b97a 	b.w	3148 <__aeabi_idiv0>
    2e54:	f1ad 0c08 	sub.w	ip, sp, #8
    2e58:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    2e5c:	f000 f806 	bl	2e6c <__udivmoddi4>
    2e60:	f8dd e004 	ldr.w	lr, [sp, #4]
    2e64:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    2e68:	b004      	add	sp, #16
    2e6a:	4770      	bx	lr

00002e6c <__udivmoddi4>:
    2e6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2e70:	468c      	mov	ip, r1
    2e72:	460d      	mov	r5, r1
    2e74:	4604      	mov	r4, r0
    2e76:	9e08      	ldr	r6, [sp, #32]
    2e78:	2b00      	cmp	r3, #0
    2e7a:	d151      	bne.n	2f20 <__udivmoddi4+0xb4>
    2e7c:	428a      	cmp	r2, r1
    2e7e:	4617      	mov	r7, r2
    2e80:	d96d      	bls.n	2f5e <__udivmoddi4+0xf2>
    2e82:	fab2 fe82 	clz	lr, r2
    2e86:	f1be 0f00 	cmp.w	lr, #0
    2e8a:	d00b      	beq.n	2ea4 <__udivmoddi4+0x38>
    2e8c:	f1ce 0c20 	rsb	ip, lr, #32
    2e90:	fa01 f50e 	lsl.w	r5, r1, lr
    2e94:	fa20 fc0c 	lsr.w	ip, r0, ip
    2e98:	fa02 f70e 	lsl.w	r7, r2, lr
    2e9c:	ea4c 0c05 	orr.w	ip, ip, r5
    2ea0:	fa00 f40e 	lsl.w	r4, r0, lr
    2ea4:	ea4f 4a17 	mov.w	sl, r7, lsr #16
    2ea8:	0c25      	lsrs	r5, r4, #16
    2eaa:	fbbc f8fa 	udiv	r8, ip, sl
    2eae:	fa1f f987 	uxth.w	r9, r7
    2eb2:	fb0a cc18 	mls	ip, sl, r8, ip
    2eb6:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
    2eba:	fb08 f309 	mul.w	r3, r8, r9
    2ebe:	42ab      	cmp	r3, r5
    2ec0:	d90a      	bls.n	2ed8 <__udivmoddi4+0x6c>
    2ec2:	19ed      	adds	r5, r5, r7
    2ec4:	f108 32ff 	add.w	r2, r8, #4294967295
    2ec8:	f080 8123 	bcs.w	3112 <__udivmoddi4+0x2a6>
    2ecc:	42ab      	cmp	r3, r5
    2ece:	f240 8120 	bls.w	3112 <__udivmoddi4+0x2a6>
    2ed2:	f1a8 0802 	sub.w	r8, r8, #2
    2ed6:	443d      	add	r5, r7
    2ed8:	1aed      	subs	r5, r5, r3
    2eda:	b2a4      	uxth	r4, r4
    2edc:	fbb5 f0fa 	udiv	r0, r5, sl
    2ee0:	fb0a 5510 	mls	r5, sl, r0, r5
    2ee4:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    2ee8:	fb00 f909 	mul.w	r9, r0, r9
    2eec:	45a1      	cmp	r9, r4
    2eee:	d909      	bls.n	2f04 <__udivmoddi4+0x98>
    2ef0:	19e4      	adds	r4, r4, r7
    2ef2:	f100 33ff 	add.w	r3, r0, #4294967295
    2ef6:	f080 810a 	bcs.w	310e <__udivmoddi4+0x2a2>
    2efa:	45a1      	cmp	r9, r4
    2efc:	f240 8107 	bls.w	310e <__udivmoddi4+0x2a2>
    2f00:	3802      	subs	r0, #2
    2f02:	443c      	add	r4, r7
    2f04:	eba4 0409 	sub.w	r4, r4, r9
    2f08:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    2f0c:	2100      	movs	r1, #0
    2f0e:	2e00      	cmp	r6, #0
    2f10:	d061      	beq.n	2fd6 <__udivmoddi4+0x16a>
    2f12:	fa24 f40e 	lsr.w	r4, r4, lr
    2f16:	2300      	movs	r3, #0
    2f18:	6034      	str	r4, [r6, #0]
    2f1a:	6073      	str	r3, [r6, #4]
    2f1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2f20:	428b      	cmp	r3, r1
    2f22:	d907      	bls.n	2f34 <__udivmoddi4+0xc8>
    2f24:	2e00      	cmp	r6, #0
    2f26:	d054      	beq.n	2fd2 <__udivmoddi4+0x166>
    2f28:	2100      	movs	r1, #0
    2f2a:	e886 0021 	stmia.w	r6, {r0, r5}
    2f2e:	4608      	mov	r0, r1
    2f30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2f34:	fab3 f183 	clz	r1, r3
    2f38:	2900      	cmp	r1, #0
    2f3a:	f040 808e 	bne.w	305a <__udivmoddi4+0x1ee>
    2f3e:	42ab      	cmp	r3, r5
    2f40:	d302      	bcc.n	2f48 <__udivmoddi4+0xdc>
    2f42:	4282      	cmp	r2, r0
    2f44:	f200 80fa 	bhi.w	313c <__udivmoddi4+0x2d0>
    2f48:	1a84      	subs	r4, r0, r2
    2f4a:	eb65 0503 	sbc.w	r5, r5, r3
    2f4e:	2001      	movs	r0, #1
    2f50:	46ac      	mov	ip, r5
    2f52:	2e00      	cmp	r6, #0
    2f54:	d03f      	beq.n	2fd6 <__udivmoddi4+0x16a>
    2f56:	e886 1010 	stmia.w	r6, {r4, ip}
    2f5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2f5e:	b912      	cbnz	r2, 2f66 <__udivmoddi4+0xfa>
    2f60:	2701      	movs	r7, #1
    2f62:	fbb7 f7f2 	udiv	r7, r7, r2
    2f66:	fab7 fe87 	clz	lr, r7
    2f6a:	f1be 0f00 	cmp.w	lr, #0
    2f6e:	d134      	bne.n	2fda <__udivmoddi4+0x16e>
    2f70:	1beb      	subs	r3, r5, r7
    2f72:	0c3a      	lsrs	r2, r7, #16
    2f74:	fa1f fc87 	uxth.w	ip, r7
    2f78:	2101      	movs	r1, #1
    2f7a:	fbb3 f8f2 	udiv	r8, r3, r2
    2f7e:	0c25      	lsrs	r5, r4, #16
    2f80:	fb02 3318 	mls	r3, r2, r8, r3
    2f84:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    2f88:	fb0c f308 	mul.w	r3, ip, r8
    2f8c:	42ab      	cmp	r3, r5
    2f8e:	d907      	bls.n	2fa0 <__udivmoddi4+0x134>
    2f90:	19ed      	adds	r5, r5, r7
    2f92:	f108 30ff 	add.w	r0, r8, #4294967295
    2f96:	d202      	bcs.n	2f9e <__udivmoddi4+0x132>
    2f98:	42ab      	cmp	r3, r5
    2f9a:	f200 80d1 	bhi.w	3140 <__udivmoddi4+0x2d4>
    2f9e:	4680      	mov	r8, r0
    2fa0:	1aed      	subs	r5, r5, r3
    2fa2:	b2a3      	uxth	r3, r4
    2fa4:	fbb5 f0f2 	udiv	r0, r5, r2
    2fa8:	fb02 5510 	mls	r5, r2, r0, r5
    2fac:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
    2fb0:	fb0c fc00 	mul.w	ip, ip, r0
    2fb4:	45a4      	cmp	ip, r4
    2fb6:	d907      	bls.n	2fc8 <__udivmoddi4+0x15c>
    2fb8:	19e4      	adds	r4, r4, r7
    2fba:	f100 33ff 	add.w	r3, r0, #4294967295
    2fbe:	d202      	bcs.n	2fc6 <__udivmoddi4+0x15a>
    2fc0:	45a4      	cmp	ip, r4
    2fc2:	f200 80b8 	bhi.w	3136 <__udivmoddi4+0x2ca>
    2fc6:	4618      	mov	r0, r3
    2fc8:	eba4 040c 	sub.w	r4, r4, ip
    2fcc:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    2fd0:	e79d      	b.n	2f0e <__udivmoddi4+0xa2>
    2fd2:	4631      	mov	r1, r6
    2fd4:	4630      	mov	r0, r6
    2fd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2fda:	f1ce 0420 	rsb	r4, lr, #32
    2fde:	fa05 f30e 	lsl.w	r3, r5, lr
    2fe2:	fa07 f70e 	lsl.w	r7, r7, lr
    2fe6:	fa20 f804 	lsr.w	r8, r0, r4
    2fea:	0c3a      	lsrs	r2, r7, #16
    2fec:	fa25 f404 	lsr.w	r4, r5, r4
    2ff0:	ea48 0803 	orr.w	r8, r8, r3
    2ff4:	fbb4 f1f2 	udiv	r1, r4, r2
    2ff8:	ea4f 4518 	mov.w	r5, r8, lsr #16
    2ffc:	fb02 4411 	mls	r4, r2, r1, r4
    3000:	fa1f fc87 	uxth.w	ip, r7
    3004:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
    3008:	fb01 f30c 	mul.w	r3, r1, ip
    300c:	42ab      	cmp	r3, r5
    300e:	fa00 f40e 	lsl.w	r4, r0, lr
    3012:	d909      	bls.n	3028 <__udivmoddi4+0x1bc>
    3014:	19ed      	adds	r5, r5, r7
    3016:	f101 30ff 	add.w	r0, r1, #4294967295
    301a:	f080 808a 	bcs.w	3132 <__udivmoddi4+0x2c6>
    301e:	42ab      	cmp	r3, r5
    3020:	f240 8087 	bls.w	3132 <__udivmoddi4+0x2c6>
    3024:	3902      	subs	r1, #2
    3026:	443d      	add	r5, r7
    3028:	1aeb      	subs	r3, r5, r3
    302a:	fa1f f588 	uxth.w	r5, r8
    302e:	fbb3 f0f2 	udiv	r0, r3, r2
    3032:	fb02 3310 	mls	r3, r2, r0, r3
    3036:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    303a:	fb00 f30c 	mul.w	r3, r0, ip
    303e:	42ab      	cmp	r3, r5
    3040:	d907      	bls.n	3052 <__udivmoddi4+0x1e6>
    3042:	19ed      	adds	r5, r5, r7
    3044:	f100 38ff 	add.w	r8, r0, #4294967295
    3048:	d26f      	bcs.n	312a <__udivmoddi4+0x2be>
    304a:	42ab      	cmp	r3, r5
    304c:	d96d      	bls.n	312a <__udivmoddi4+0x2be>
    304e:	3802      	subs	r0, #2
    3050:	443d      	add	r5, r7
    3052:	1aeb      	subs	r3, r5, r3
    3054:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    3058:	e78f      	b.n	2f7a <__udivmoddi4+0x10e>
    305a:	f1c1 0720 	rsb	r7, r1, #32
    305e:	fa22 f807 	lsr.w	r8, r2, r7
    3062:	408b      	lsls	r3, r1
    3064:	fa05 f401 	lsl.w	r4, r5, r1
    3068:	ea48 0303 	orr.w	r3, r8, r3
    306c:	fa20 fe07 	lsr.w	lr, r0, r7
    3070:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    3074:	40fd      	lsrs	r5, r7
    3076:	ea4e 0e04 	orr.w	lr, lr, r4
    307a:	fbb5 f9fc 	udiv	r9, r5, ip
    307e:	ea4f 441e 	mov.w	r4, lr, lsr #16
    3082:	fb0c 5519 	mls	r5, ip, r9, r5
    3086:	fa1f f883 	uxth.w	r8, r3
    308a:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
    308e:	fb09 f408 	mul.w	r4, r9, r8
    3092:	42ac      	cmp	r4, r5
    3094:	fa02 f201 	lsl.w	r2, r2, r1
    3098:	fa00 fa01 	lsl.w	sl, r0, r1
    309c:	d908      	bls.n	30b0 <__udivmoddi4+0x244>
    309e:	18ed      	adds	r5, r5, r3
    30a0:	f109 30ff 	add.w	r0, r9, #4294967295
    30a4:	d243      	bcs.n	312e <__udivmoddi4+0x2c2>
    30a6:	42ac      	cmp	r4, r5
    30a8:	d941      	bls.n	312e <__udivmoddi4+0x2c2>
    30aa:	f1a9 0902 	sub.w	r9, r9, #2
    30ae:	441d      	add	r5, r3
    30b0:	1b2d      	subs	r5, r5, r4
    30b2:	fa1f fe8e 	uxth.w	lr, lr
    30b6:	fbb5 f0fc 	udiv	r0, r5, ip
    30ba:	fb0c 5510 	mls	r5, ip, r0, r5
    30be:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
    30c2:	fb00 f808 	mul.w	r8, r0, r8
    30c6:	45a0      	cmp	r8, r4
    30c8:	d907      	bls.n	30da <__udivmoddi4+0x26e>
    30ca:	18e4      	adds	r4, r4, r3
    30cc:	f100 35ff 	add.w	r5, r0, #4294967295
    30d0:	d229      	bcs.n	3126 <__udivmoddi4+0x2ba>
    30d2:	45a0      	cmp	r8, r4
    30d4:	d927      	bls.n	3126 <__udivmoddi4+0x2ba>
    30d6:	3802      	subs	r0, #2
    30d8:	441c      	add	r4, r3
    30da:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    30de:	eba4 0408 	sub.w	r4, r4, r8
    30e2:	fba0 8902 	umull	r8, r9, r0, r2
    30e6:	454c      	cmp	r4, r9
    30e8:	46c6      	mov	lr, r8
    30ea:	464d      	mov	r5, r9
    30ec:	d315      	bcc.n	311a <__udivmoddi4+0x2ae>
    30ee:	d012      	beq.n	3116 <__udivmoddi4+0x2aa>
    30f0:	b156      	cbz	r6, 3108 <__udivmoddi4+0x29c>
    30f2:	ebba 030e 	subs.w	r3, sl, lr
    30f6:	eb64 0405 	sbc.w	r4, r4, r5
    30fa:	fa04 f707 	lsl.w	r7, r4, r7
    30fe:	40cb      	lsrs	r3, r1
    3100:	431f      	orrs	r7, r3
    3102:	40cc      	lsrs	r4, r1
    3104:	6037      	str	r7, [r6, #0]
    3106:	6074      	str	r4, [r6, #4]
    3108:	2100      	movs	r1, #0
    310a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    310e:	4618      	mov	r0, r3
    3110:	e6f8      	b.n	2f04 <__udivmoddi4+0x98>
    3112:	4690      	mov	r8, r2
    3114:	e6e0      	b.n	2ed8 <__udivmoddi4+0x6c>
    3116:	45c2      	cmp	sl, r8
    3118:	d2ea      	bcs.n	30f0 <__udivmoddi4+0x284>
    311a:	ebb8 0e02 	subs.w	lr, r8, r2
    311e:	eb69 0503 	sbc.w	r5, r9, r3
    3122:	3801      	subs	r0, #1
    3124:	e7e4      	b.n	30f0 <__udivmoddi4+0x284>
    3126:	4628      	mov	r0, r5
    3128:	e7d7      	b.n	30da <__udivmoddi4+0x26e>
    312a:	4640      	mov	r0, r8
    312c:	e791      	b.n	3052 <__udivmoddi4+0x1e6>
    312e:	4681      	mov	r9, r0
    3130:	e7be      	b.n	30b0 <__udivmoddi4+0x244>
    3132:	4601      	mov	r1, r0
    3134:	e778      	b.n	3028 <__udivmoddi4+0x1bc>
    3136:	3802      	subs	r0, #2
    3138:	443c      	add	r4, r7
    313a:	e745      	b.n	2fc8 <__udivmoddi4+0x15c>
    313c:	4608      	mov	r0, r1
    313e:	e708      	b.n	2f52 <__udivmoddi4+0xe6>
    3140:	f1a8 0802 	sub.w	r8, r8, #2
    3144:	443d      	add	r5, r7
    3146:	e72b      	b.n	2fa0 <__udivmoddi4+0x134>

00003148 <__aeabi_idiv0>:
    3148:	4770      	bx	lr
    314a:	bf00      	nop

0000314c <__libc_init_array>:
    314c:	b570      	push	{r4, r5, r6, lr}
    314e:	4e0f      	ldr	r6, [pc, #60]	; (318c <__libc_init_array+0x40>)
    3150:	4d0f      	ldr	r5, [pc, #60]	; (3190 <__libc_init_array+0x44>)
    3152:	1b76      	subs	r6, r6, r5
    3154:	10b6      	asrs	r6, r6, #2
    3156:	bf18      	it	ne
    3158:	2400      	movne	r4, #0
    315a:	d005      	beq.n	3168 <__libc_init_array+0x1c>
    315c:	3401      	adds	r4, #1
    315e:	f855 3b04 	ldr.w	r3, [r5], #4
    3162:	4798      	blx	r3
    3164:	42a6      	cmp	r6, r4
    3166:	d1f9      	bne.n	315c <__libc_init_array+0x10>
    3168:	4e0a      	ldr	r6, [pc, #40]	; (3194 <__libc_init_array+0x48>)
    316a:	4d0b      	ldr	r5, [pc, #44]	; (3198 <__libc_init_array+0x4c>)
    316c:	1b76      	subs	r6, r6, r5
    316e:	f000 fbd5 	bl	391c <_init>
    3172:	10b6      	asrs	r6, r6, #2
    3174:	bf18      	it	ne
    3176:	2400      	movne	r4, #0
    3178:	d006      	beq.n	3188 <__libc_init_array+0x3c>
    317a:	3401      	adds	r4, #1
    317c:	f855 3b04 	ldr.w	r3, [r5], #4
    3180:	4798      	blx	r3
    3182:	42a6      	cmp	r6, r4
    3184:	d1f9      	bne.n	317a <__libc_init_array+0x2e>
    3186:	bd70      	pop	{r4, r5, r6, pc}
    3188:	bd70      	pop	{r4, r5, r6, pc}
    318a:	bf00      	nop
    318c:	00003928 	.word	0x00003928
    3190:	00003928 	.word	0x00003928
    3194:	00003930 	.word	0x00003930
    3198:	00003928 	.word	0x00003928

0000319c <__itoa>:
    319c:	1e93      	subs	r3, r2, #2
    319e:	2b22      	cmp	r3, #34	; 0x22
    31a0:	d810      	bhi.n	31c4 <__itoa+0x28>
    31a2:	2a0a      	cmp	r2, #10
    31a4:	b510      	push	{r4, lr}
    31a6:	d006      	beq.n	31b6 <__itoa+0x1a>
    31a8:	2300      	movs	r3, #0
    31aa:	460c      	mov	r4, r1
    31ac:	4419      	add	r1, r3
    31ae:	f000 fa27 	bl	3600 <__utoa>
    31b2:	4620      	mov	r0, r4
    31b4:	bd10      	pop	{r4, pc}
    31b6:	2800      	cmp	r0, #0
    31b8:	daf6      	bge.n	31a8 <__itoa+0xc>
    31ba:	232d      	movs	r3, #45	; 0x2d
    31bc:	700b      	strb	r3, [r1, #0]
    31be:	4240      	negs	r0, r0
    31c0:	2301      	movs	r3, #1
    31c2:	e7f2      	b.n	31aa <__itoa+0xe>
    31c4:	2000      	movs	r0, #0
    31c6:	7008      	strb	r0, [r1, #0]
    31c8:	4770      	bx	lr
    31ca:	bf00      	nop

000031cc <itoa>:
    31cc:	f7ff bfe6 	b.w	319c <__itoa>

000031d0 <memcpy>:
    31d0:	4684      	mov	ip, r0
    31d2:	ea41 0300 	orr.w	r3, r1, r0
    31d6:	f013 0303 	ands.w	r3, r3, #3
    31da:	d16d      	bne.n	32b8 <memcpy+0xe8>
    31dc:	3a40      	subs	r2, #64	; 0x40
    31de:	d341      	bcc.n	3264 <memcpy+0x94>
    31e0:	f851 3b04 	ldr.w	r3, [r1], #4
    31e4:	f840 3b04 	str.w	r3, [r0], #4
    31e8:	f851 3b04 	ldr.w	r3, [r1], #4
    31ec:	f840 3b04 	str.w	r3, [r0], #4
    31f0:	f851 3b04 	ldr.w	r3, [r1], #4
    31f4:	f840 3b04 	str.w	r3, [r0], #4
    31f8:	f851 3b04 	ldr.w	r3, [r1], #4
    31fc:	f840 3b04 	str.w	r3, [r0], #4
    3200:	f851 3b04 	ldr.w	r3, [r1], #4
    3204:	f840 3b04 	str.w	r3, [r0], #4
    3208:	f851 3b04 	ldr.w	r3, [r1], #4
    320c:	f840 3b04 	str.w	r3, [r0], #4
    3210:	f851 3b04 	ldr.w	r3, [r1], #4
    3214:	f840 3b04 	str.w	r3, [r0], #4
    3218:	f851 3b04 	ldr.w	r3, [r1], #4
    321c:	f840 3b04 	str.w	r3, [r0], #4
    3220:	f851 3b04 	ldr.w	r3, [r1], #4
    3224:	f840 3b04 	str.w	r3, [r0], #4
    3228:	f851 3b04 	ldr.w	r3, [r1], #4
    322c:	f840 3b04 	str.w	r3, [r0], #4
    3230:	f851 3b04 	ldr.w	r3, [r1], #4
    3234:	f840 3b04 	str.w	r3, [r0], #4
    3238:	f851 3b04 	ldr.w	r3, [r1], #4
    323c:	f840 3b04 	str.w	r3, [r0], #4
    3240:	f851 3b04 	ldr.w	r3, [r1], #4
    3244:	f840 3b04 	str.w	r3, [r0], #4
    3248:	f851 3b04 	ldr.w	r3, [r1], #4
    324c:	f840 3b04 	str.w	r3, [r0], #4
    3250:	f851 3b04 	ldr.w	r3, [r1], #4
    3254:	f840 3b04 	str.w	r3, [r0], #4
    3258:	f851 3b04 	ldr.w	r3, [r1], #4
    325c:	f840 3b04 	str.w	r3, [r0], #4
    3260:	3a40      	subs	r2, #64	; 0x40
    3262:	d2bd      	bcs.n	31e0 <memcpy+0x10>
    3264:	3230      	adds	r2, #48	; 0x30
    3266:	d311      	bcc.n	328c <memcpy+0xbc>
    3268:	f851 3b04 	ldr.w	r3, [r1], #4
    326c:	f840 3b04 	str.w	r3, [r0], #4
    3270:	f851 3b04 	ldr.w	r3, [r1], #4
    3274:	f840 3b04 	str.w	r3, [r0], #4
    3278:	f851 3b04 	ldr.w	r3, [r1], #4
    327c:	f840 3b04 	str.w	r3, [r0], #4
    3280:	f851 3b04 	ldr.w	r3, [r1], #4
    3284:	f840 3b04 	str.w	r3, [r0], #4
    3288:	3a10      	subs	r2, #16
    328a:	d2ed      	bcs.n	3268 <memcpy+0x98>
    328c:	320c      	adds	r2, #12
    328e:	d305      	bcc.n	329c <memcpy+0xcc>
    3290:	f851 3b04 	ldr.w	r3, [r1], #4
    3294:	f840 3b04 	str.w	r3, [r0], #4
    3298:	3a04      	subs	r2, #4
    329a:	d2f9      	bcs.n	3290 <memcpy+0xc0>
    329c:	3204      	adds	r2, #4
    329e:	d008      	beq.n	32b2 <memcpy+0xe2>
    32a0:	07d2      	lsls	r2, r2, #31
    32a2:	bf1c      	itt	ne
    32a4:	f811 3b01 	ldrbne.w	r3, [r1], #1
    32a8:	f800 3b01 	strbne.w	r3, [r0], #1
    32ac:	d301      	bcc.n	32b2 <memcpy+0xe2>
    32ae:	880b      	ldrh	r3, [r1, #0]
    32b0:	8003      	strh	r3, [r0, #0]
    32b2:	4660      	mov	r0, ip
    32b4:	4770      	bx	lr
    32b6:	bf00      	nop
    32b8:	2a08      	cmp	r2, #8
    32ba:	d313      	bcc.n	32e4 <memcpy+0x114>
    32bc:	078b      	lsls	r3, r1, #30
    32be:	d08d      	beq.n	31dc <memcpy+0xc>
    32c0:	f010 0303 	ands.w	r3, r0, #3
    32c4:	d08a      	beq.n	31dc <memcpy+0xc>
    32c6:	f1c3 0304 	rsb	r3, r3, #4
    32ca:	1ad2      	subs	r2, r2, r3
    32cc:	07db      	lsls	r3, r3, #31
    32ce:	bf1c      	itt	ne
    32d0:	f811 3b01 	ldrbne.w	r3, [r1], #1
    32d4:	f800 3b01 	strbne.w	r3, [r0], #1
    32d8:	d380      	bcc.n	31dc <memcpy+0xc>
    32da:	f831 3b02 	ldrh.w	r3, [r1], #2
    32de:	f820 3b02 	strh.w	r3, [r0], #2
    32e2:	e77b      	b.n	31dc <memcpy+0xc>
    32e4:	3a04      	subs	r2, #4
    32e6:	d3d9      	bcc.n	329c <memcpy+0xcc>
    32e8:	3a01      	subs	r2, #1
    32ea:	f811 3b01 	ldrb.w	r3, [r1], #1
    32ee:	f800 3b01 	strb.w	r3, [r0], #1
    32f2:	d2f9      	bcs.n	32e8 <memcpy+0x118>
    32f4:	780b      	ldrb	r3, [r1, #0]
    32f6:	7003      	strb	r3, [r0, #0]
    32f8:	784b      	ldrb	r3, [r1, #1]
    32fa:	7043      	strb	r3, [r0, #1]
    32fc:	788b      	ldrb	r3, [r1, #2]
    32fe:	7083      	strb	r3, [r0, #2]
    3300:	4660      	mov	r0, ip
    3302:	4770      	bx	lr

00003304 <memset>:
    3304:	b470      	push	{r4, r5, r6}
    3306:	0786      	lsls	r6, r0, #30
    3308:	d046      	beq.n	3398 <memset+0x94>
    330a:	1e54      	subs	r4, r2, #1
    330c:	2a00      	cmp	r2, #0
    330e:	d041      	beq.n	3394 <memset+0x90>
    3310:	b2ca      	uxtb	r2, r1
    3312:	4603      	mov	r3, r0
    3314:	e002      	b.n	331c <memset+0x18>
    3316:	f114 34ff 	adds.w	r4, r4, #4294967295
    331a:	d33b      	bcc.n	3394 <memset+0x90>
    331c:	f803 2b01 	strb.w	r2, [r3], #1
    3320:	079d      	lsls	r5, r3, #30
    3322:	d1f8      	bne.n	3316 <memset+0x12>
    3324:	2c03      	cmp	r4, #3
    3326:	d92e      	bls.n	3386 <memset+0x82>
    3328:	b2cd      	uxtb	r5, r1
    332a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    332e:	2c0f      	cmp	r4, #15
    3330:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    3334:	d919      	bls.n	336a <memset+0x66>
    3336:	f103 0210 	add.w	r2, r3, #16
    333a:	4626      	mov	r6, r4
    333c:	3e10      	subs	r6, #16
    333e:	2e0f      	cmp	r6, #15
    3340:	f842 5c10 	str.w	r5, [r2, #-16]
    3344:	f842 5c0c 	str.w	r5, [r2, #-12]
    3348:	f842 5c08 	str.w	r5, [r2, #-8]
    334c:	f842 5c04 	str.w	r5, [r2, #-4]
    3350:	f102 0210 	add.w	r2, r2, #16
    3354:	d8f2      	bhi.n	333c <memset+0x38>
    3356:	f1a4 0210 	sub.w	r2, r4, #16
    335a:	f022 020f 	bic.w	r2, r2, #15
    335e:	f004 040f 	and.w	r4, r4, #15
    3362:	3210      	adds	r2, #16
    3364:	2c03      	cmp	r4, #3
    3366:	4413      	add	r3, r2
    3368:	d90d      	bls.n	3386 <memset+0x82>
    336a:	461e      	mov	r6, r3
    336c:	4622      	mov	r2, r4
    336e:	3a04      	subs	r2, #4
    3370:	2a03      	cmp	r2, #3
    3372:	f846 5b04 	str.w	r5, [r6], #4
    3376:	d8fa      	bhi.n	336e <memset+0x6a>
    3378:	1f22      	subs	r2, r4, #4
    337a:	f022 0203 	bic.w	r2, r2, #3
    337e:	3204      	adds	r2, #4
    3380:	4413      	add	r3, r2
    3382:	f004 0403 	and.w	r4, r4, #3
    3386:	b12c      	cbz	r4, 3394 <memset+0x90>
    3388:	b2c9      	uxtb	r1, r1
    338a:	441c      	add	r4, r3
    338c:	f803 1b01 	strb.w	r1, [r3], #1
    3390:	429c      	cmp	r4, r3
    3392:	d1fb      	bne.n	338c <memset+0x88>
    3394:	bc70      	pop	{r4, r5, r6}
    3396:	4770      	bx	lr
    3398:	4614      	mov	r4, r2
    339a:	4603      	mov	r3, r0
    339c:	e7c2      	b.n	3324 <memset+0x20>
    339e:	bf00      	nop

000033a0 <strcpy>:
    33a0:	ea80 0201 	eor.w	r2, r0, r1
    33a4:	4684      	mov	ip, r0
    33a6:	f012 0f03 	tst.w	r2, #3
    33aa:	d14f      	bne.n	344c <strcpy+0xac>
    33ac:	f011 0f03 	tst.w	r1, #3
    33b0:	d132      	bne.n	3418 <strcpy+0x78>
    33b2:	f84d 4d04 	str.w	r4, [sp, #-4]!
    33b6:	f011 0f04 	tst.w	r1, #4
    33ba:	f851 3b04 	ldr.w	r3, [r1], #4
    33be:	d00b      	beq.n	33d8 <strcpy+0x38>
    33c0:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    33c4:	439a      	bics	r2, r3
    33c6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    33ca:	bf04      	itt	eq
    33cc:	f84c 3b04 	streq.w	r3, [ip], #4
    33d0:	f851 3b04 	ldreq.w	r3, [r1], #4
    33d4:	d116      	bne.n	3404 <strcpy+0x64>
    33d6:	bf00      	nop
    33d8:	f851 4b04 	ldr.w	r4, [r1], #4
    33dc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    33e0:	439a      	bics	r2, r3
    33e2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    33e6:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    33ea:	d10b      	bne.n	3404 <strcpy+0x64>
    33ec:	f84c 3b04 	str.w	r3, [ip], #4
    33f0:	43a2      	bics	r2, r4
    33f2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    33f6:	bf04      	itt	eq
    33f8:	f851 3b04 	ldreq.w	r3, [r1], #4
    33fc:	f84c 4b04 	streq.w	r4, [ip], #4
    3400:	d0ea      	beq.n	33d8 <strcpy+0x38>
    3402:	4623      	mov	r3, r4
    3404:	f80c 3b01 	strb.w	r3, [ip], #1
    3408:	f013 0fff 	tst.w	r3, #255	; 0xff
    340c:	ea4f 2333 	mov.w	r3, r3, ror #8
    3410:	d1f8      	bne.n	3404 <strcpy+0x64>
    3412:	f85d 4b04 	ldr.w	r4, [sp], #4
    3416:	4770      	bx	lr
    3418:	f011 0f01 	tst.w	r1, #1
    341c:	d006      	beq.n	342c <strcpy+0x8c>
    341e:	f811 2b01 	ldrb.w	r2, [r1], #1
    3422:	f80c 2b01 	strb.w	r2, [ip], #1
    3426:	2a00      	cmp	r2, #0
    3428:	bf08      	it	eq
    342a:	4770      	bxeq	lr
    342c:	f011 0f02 	tst.w	r1, #2
    3430:	d0bf      	beq.n	33b2 <strcpy+0x12>
    3432:	f831 2b02 	ldrh.w	r2, [r1], #2
    3436:	f012 0fff 	tst.w	r2, #255	; 0xff
    343a:	bf16      	itet	ne
    343c:	f82c 2b02 	strhne.w	r2, [ip], #2
    3440:	f88c 2000 	strbeq.w	r2, [ip]
    3444:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    3448:	d1b3      	bne.n	33b2 <strcpy+0x12>
    344a:	4770      	bx	lr
    344c:	f811 2b01 	ldrb.w	r2, [r1], #1
    3450:	f80c 2b01 	strb.w	r2, [ip], #1
    3454:	2a00      	cmp	r2, #0
    3456:	d1f9      	bne.n	344c <strcpy+0xac>
    3458:	4770      	bx	lr
    345a:	bf00      	nop
	...

00003480 <strlen>:
    3480:	f890 f000 	pld	[r0]
    3484:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    3488:	f020 0107 	bic.w	r1, r0, #7
    348c:	f06f 0c00 	mvn.w	ip, #0
    3490:	f010 0407 	ands.w	r4, r0, #7
    3494:	f891 f020 	pld	[r1, #32]
    3498:	f040 8049 	bne.w	352e <strlen+0xae>
    349c:	f04f 0400 	mov.w	r4, #0
    34a0:	f06f 0007 	mvn.w	r0, #7
    34a4:	e9d1 2300 	ldrd	r2, r3, [r1]
    34a8:	f891 f040 	pld	[r1, #64]	; 0x40
    34ac:	f100 0008 	add.w	r0, r0, #8
    34b0:	fa82 f24c 	uadd8	r2, r2, ip
    34b4:	faa4 f28c 	sel	r2, r4, ip
    34b8:	fa83 f34c 	uadd8	r3, r3, ip
    34bc:	faa2 f38c 	sel	r3, r2, ip
    34c0:	bb4b      	cbnz	r3, 3516 <strlen+0x96>
    34c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    34c6:	fa82 f24c 	uadd8	r2, r2, ip
    34ca:	f100 0008 	add.w	r0, r0, #8
    34ce:	faa4 f28c 	sel	r2, r4, ip
    34d2:	fa83 f34c 	uadd8	r3, r3, ip
    34d6:	faa2 f38c 	sel	r3, r2, ip
    34da:	b9e3      	cbnz	r3, 3516 <strlen+0x96>
    34dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    34e0:	fa82 f24c 	uadd8	r2, r2, ip
    34e4:	f100 0008 	add.w	r0, r0, #8
    34e8:	faa4 f28c 	sel	r2, r4, ip
    34ec:	fa83 f34c 	uadd8	r3, r3, ip
    34f0:	faa2 f38c 	sel	r3, r2, ip
    34f4:	b97b      	cbnz	r3, 3516 <strlen+0x96>
    34f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    34fa:	f101 0120 	add.w	r1, r1, #32
    34fe:	fa82 f24c 	uadd8	r2, r2, ip
    3502:	f100 0008 	add.w	r0, r0, #8
    3506:	faa4 f28c 	sel	r2, r4, ip
    350a:	fa83 f34c 	uadd8	r3, r3, ip
    350e:	faa2 f38c 	sel	r3, r2, ip
    3512:	2b00      	cmp	r3, #0
    3514:	d0c6      	beq.n	34a4 <strlen+0x24>
    3516:	2a00      	cmp	r2, #0
    3518:	bf04      	itt	eq
    351a:	3004      	addeq	r0, #4
    351c:	461a      	moveq	r2, r3
    351e:	ba12      	rev	r2, r2
    3520:	fab2 f282 	clz	r2, r2
    3524:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    3528:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    352c:	4770      	bx	lr
    352e:	e9d1 2300 	ldrd	r2, r3, [r1]
    3532:	f004 0503 	and.w	r5, r4, #3
    3536:	f1c4 0000 	rsb	r0, r4, #0
    353a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    353e:	f014 0f04 	tst.w	r4, #4
    3542:	f891 f040 	pld	[r1, #64]	; 0x40
    3546:	fa0c f505 	lsl.w	r5, ip, r5
    354a:	ea62 0205 	orn	r2, r2, r5
    354e:	bf1c      	itt	ne
    3550:	ea63 0305 	ornne	r3, r3, r5
    3554:	4662      	movne	r2, ip
    3556:	f04f 0400 	mov.w	r4, #0
    355a:	e7a9      	b.n	34b0 <strlen+0x30>

0000355c <strncmp>:
    355c:	2a00      	cmp	r2, #0
    355e:	d041      	beq.n	35e4 <strncmp+0x88>
    3560:	ea40 0301 	orr.w	r3, r0, r1
    3564:	f013 0303 	ands.w	r3, r3, #3
    3568:	b4f0      	push	{r4, r5, r6, r7}
    356a:	d125      	bne.n	35b8 <strncmp+0x5c>
    356c:	2a03      	cmp	r2, #3
    356e:	d923      	bls.n	35b8 <strncmp+0x5c>
    3570:	6804      	ldr	r4, [r0, #0]
    3572:	680d      	ldr	r5, [r1, #0]
    3574:	42ac      	cmp	r4, r5
    3576:	d11f      	bne.n	35b8 <strncmp+0x5c>
    3578:	3a04      	subs	r2, #4
    357a:	d038      	beq.n	35ee <strncmp+0x92>
    357c:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
    3580:	ea25 0404 	bic.w	r4, r5, r4
    3584:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
    3588:	d12e      	bne.n	35e8 <strncmp+0x8c>
    358a:	3004      	adds	r0, #4
    358c:	3104      	adds	r1, #4
    358e:	e00f      	b.n	35b0 <strncmp+0x54>
    3590:	f850 3b04 	ldr.w	r3, [r0], #4
    3594:	680e      	ldr	r6, [r1, #0]
    3596:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
    359a:	42b3      	cmp	r3, r6
    359c:	ea24 0403 	bic.w	r4, r4, r3
    35a0:	f101 0104 	add.w	r1, r1, #4
    35a4:	d126      	bne.n	35f4 <strncmp+0x98>
    35a6:	3a04      	subs	r2, #4
    35a8:	d021      	beq.n	35ee <strncmp+0x92>
    35aa:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
    35ae:	d11b      	bne.n	35e8 <strncmp+0x8c>
    35b0:	2a03      	cmp	r2, #3
    35b2:	4607      	mov	r7, r0
    35b4:	460d      	mov	r5, r1
    35b6:	d8eb      	bhi.n	3590 <strncmp+0x34>
    35b8:	7805      	ldrb	r5, [r0, #0]
    35ba:	780c      	ldrb	r4, [r1, #0]
    35bc:	42ac      	cmp	r4, r5
    35be:	f102 33ff 	add.w	r3, r2, #4294967295
    35c2:	d11a      	bne.n	35fa <strncmp+0x9e>
    35c4:	b183      	cbz	r3, 35e8 <strncmp+0x8c>
    35c6:	b914      	cbnz	r4, 35ce <strncmp+0x72>
    35c8:	e00e      	b.n	35e8 <strncmp+0x8c>
    35ca:	b16b      	cbz	r3, 35e8 <strncmp+0x8c>
    35cc:	b17a      	cbz	r2, 35ee <strncmp+0x92>
    35ce:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    35d2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    35d6:	42a2      	cmp	r2, r4
    35d8:	f103 33ff 	add.w	r3, r3, #4294967295
    35dc:	d0f5      	beq.n	35ca <strncmp+0x6e>
    35de:	1b10      	subs	r0, r2, r4
    35e0:	bcf0      	pop	{r4, r5, r6, r7}
    35e2:	4770      	bx	lr
    35e4:	4610      	mov	r0, r2
    35e6:	4770      	bx	lr
    35e8:	2000      	movs	r0, #0
    35ea:	bcf0      	pop	{r4, r5, r6, r7}
    35ec:	4770      	bx	lr
    35ee:	4610      	mov	r0, r2
    35f0:	bcf0      	pop	{r4, r5, r6, r7}
    35f2:	4770      	bx	lr
    35f4:	4629      	mov	r1, r5
    35f6:	4638      	mov	r0, r7
    35f8:	e7de      	b.n	35b8 <strncmp+0x5c>
    35fa:	462a      	mov	r2, r5
    35fc:	e7ef      	b.n	35de <strncmp+0x82>
    35fe:	bf00      	nop

00003600 <__utoa>:
    3600:	b5f0      	push	{r4, r5, r6, r7, lr}
    3602:	f8df e078 	ldr.w	lr, [pc, #120]	; 367c <__utoa+0x7c>
    3606:	4616      	mov	r6, r2
    3608:	4604      	mov	r4, r0
    360a:	460f      	mov	r7, r1
    360c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3610:	b08b      	sub	sp, #44	; 0x2c
    3612:	466d      	mov	r5, sp
    3614:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    3616:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    361a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    361c:	e89e 0003 	ldmia.w	lr, {r0, r1}
    3620:	1eb3      	subs	r3, r6, #2
    3622:	f845 0b04 	str.w	r0, [r5], #4
    3626:	2b22      	cmp	r3, #34	; 0x22
    3628:	7029      	strb	r1, [r5, #0]
    362a:	d822      	bhi.n	3672 <__utoa+0x72>
    362c:	1e7d      	subs	r5, r7, #1
    362e:	4628      	mov	r0, r5
    3630:	2200      	movs	r2, #0
    3632:	e000      	b.n	3636 <__utoa+0x36>
    3634:	461a      	mov	r2, r3
    3636:	fbb4 f1f6 	udiv	r1, r4, r6
    363a:	ab0a      	add	r3, sp, #40	; 0x28
    363c:	fb06 4411 	mls	r4, r6, r1, r4
    3640:	4423      	add	r3, r4
    3642:	460c      	mov	r4, r1
    3644:	f813 3c28 	ldrb.w	r3, [r3, #-40]
    3648:	f800 3f01 	strb.w	r3, [r0, #1]!
    364c:	1c53      	adds	r3, r2, #1
    364e:	2900      	cmp	r1, #0
    3650:	d1f0      	bne.n	3634 <__utoa+0x34>
    3652:	54f9      	strb	r1, [r7, r3]
    3654:	18bb      	adds	r3, r7, r2
    3656:	b14a      	cbz	r2, 366c <__utoa+0x6c>
    3658:	7819      	ldrb	r1, [r3, #0]
    365a:	7868      	ldrb	r0, [r5, #1]
    365c:	f805 1f01 	strb.w	r1, [r5, #1]!
    3660:	3401      	adds	r4, #1
    3662:	1b11      	subs	r1, r2, r4
    3664:	428c      	cmp	r4, r1
    3666:	f803 0901 	strb.w	r0, [r3], #-1
    366a:	dbf5      	blt.n	3658 <__utoa+0x58>
    366c:	4638      	mov	r0, r7
    366e:	b00b      	add	sp, #44	; 0x2c
    3670:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3672:	2000      	movs	r0, #0
    3674:	7038      	strb	r0, [r7, #0]
    3676:	b00b      	add	sp, #44	; 0x2c
    3678:	bdf0      	pop	{r4, r5, r6, r7, pc}
    367a:	bf00      	nop
    367c:	000038f4 	.word	0x000038f4

00003680 <register_fini>:
    3680:	4b02      	ldr	r3, [pc, #8]	; (368c <register_fini+0xc>)
    3682:	b113      	cbz	r3, 368a <register_fini+0xa>
    3684:	4802      	ldr	r0, [pc, #8]	; (3690 <register_fini+0x10>)
    3686:	f000 b805 	b.w	3694 <atexit>
    368a:	4770      	bx	lr
    368c:	00000000 	.word	0x00000000
    3690:	000036a1 	.word	0x000036a1

00003694 <atexit>:
    3694:	2300      	movs	r3, #0
    3696:	4601      	mov	r1, r0
    3698:	461a      	mov	r2, r3
    369a:	4618      	mov	r0, r3
    369c:	f000 b81e 	b.w	36dc <__register_exitproc>

000036a0 <__libc_fini_array>:
    36a0:	b538      	push	{r3, r4, r5, lr}
    36a2:	4c0a      	ldr	r4, [pc, #40]	; (36cc <__libc_fini_array+0x2c>)
    36a4:	4d0a      	ldr	r5, [pc, #40]	; (36d0 <__libc_fini_array+0x30>)
    36a6:	1b64      	subs	r4, r4, r5
    36a8:	10a4      	asrs	r4, r4, #2
    36aa:	d00a      	beq.n	36c2 <__libc_fini_array+0x22>
    36ac:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
    36b0:	3b01      	subs	r3, #1
    36b2:	eb05 0583 	add.w	r5, r5, r3, lsl #2
    36b6:	3c01      	subs	r4, #1
    36b8:	f855 3904 	ldr.w	r3, [r5], #-4
    36bc:	4798      	blx	r3
    36be:	2c00      	cmp	r4, #0
    36c0:	d1f9      	bne.n	36b6 <__libc_fini_array+0x16>
    36c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    36c6:	f000 b933 	b.w	3930 <_fini>
    36ca:	bf00      	nop
    36cc:	00003940 	.word	0x00003940
    36d0:	0000393c 	.word	0x0000393c

000036d4 <__retarget_lock_acquire_recursive>:
    36d4:	4770      	bx	lr
    36d6:	bf00      	nop

000036d8 <__retarget_lock_release_recursive>:
    36d8:	4770      	bx	lr
    36da:	bf00      	nop

000036dc <__register_exitproc>:
    36dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    36e0:	4d2c      	ldr	r5, [pc, #176]	; (3794 <__register_exitproc+0xb8>)
    36e2:	4606      	mov	r6, r0
    36e4:	6828      	ldr	r0, [r5, #0]
    36e6:	4698      	mov	r8, r3
    36e8:	460f      	mov	r7, r1
    36ea:	4691      	mov	r9, r2
    36ec:	f7ff fff2 	bl	36d4 <__retarget_lock_acquire_recursive>
    36f0:	4b29      	ldr	r3, [pc, #164]	; (3798 <__register_exitproc+0xbc>)
    36f2:	681c      	ldr	r4, [r3, #0]
    36f4:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    36f8:	2b00      	cmp	r3, #0
    36fa:	d03e      	beq.n	377a <__register_exitproc+0x9e>
    36fc:	685a      	ldr	r2, [r3, #4]
    36fe:	2a1f      	cmp	r2, #31
    3700:	dc1c      	bgt.n	373c <__register_exitproc+0x60>
    3702:	f102 0e01 	add.w	lr, r2, #1
    3706:	b176      	cbz	r6, 3726 <__register_exitproc+0x4a>
    3708:	eb03 0182 	add.w	r1, r3, r2, lsl #2
    370c:	2401      	movs	r4, #1
    370e:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
    3712:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
    3716:	4094      	lsls	r4, r2
    3718:	4320      	orrs	r0, r4
    371a:	2e02      	cmp	r6, #2
    371c:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
    3720:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
    3724:	d023      	beq.n	376e <__register_exitproc+0x92>
    3726:	3202      	adds	r2, #2
    3728:	f8c3 e004 	str.w	lr, [r3, #4]
    372c:	6828      	ldr	r0, [r5, #0]
    372e:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
    3732:	f7ff ffd1 	bl	36d8 <__retarget_lock_release_recursive>
    3736:	2000      	movs	r0, #0
    3738:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    373c:	4b17      	ldr	r3, [pc, #92]	; (379c <__register_exitproc+0xc0>)
    373e:	b30b      	cbz	r3, 3784 <__register_exitproc+0xa8>
    3740:	f44f 70c8 	mov.w	r0, #400	; 0x190
    3744:	f3af 8000 	nop.w
    3748:	4603      	mov	r3, r0
    374a:	b1d8      	cbz	r0, 3784 <__register_exitproc+0xa8>
    374c:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
    3750:	6002      	str	r2, [r0, #0]
    3752:	2100      	movs	r1, #0
    3754:	6041      	str	r1, [r0, #4]
    3756:	460a      	mov	r2, r1
    3758:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
    375c:	f04f 0e01 	mov.w	lr, #1
    3760:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
    3764:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
    3768:	2e00      	cmp	r6, #0
    376a:	d0dc      	beq.n	3726 <__register_exitproc+0x4a>
    376c:	e7cc      	b.n	3708 <__register_exitproc+0x2c>
    376e:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
    3772:	430c      	orrs	r4, r1
    3774:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
    3778:	e7d5      	b.n	3726 <__register_exitproc+0x4a>
    377a:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
    377e:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    3782:	e7bb      	b.n	36fc <__register_exitproc+0x20>
    3784:	6828      	ldr	r0, [r5, #0]
    3786:	f7ff ffa7 	bl	36d8 <__retarget_lock_release_recursive>
    378a:	f04f 30ff 	mov.w	r0, #4294967295
    378e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3792:	bf00      	nop
    3794:	20000440 	.word	0x20000440
    3798:	000038f0 	.word	0x000038f0
    379c:	00000000 	.word	0x00000000
    37a0:	00000001 	.word	0x00000001
    37a4:	00000003 	.word	0x00000003
    37a8:	00000005 	.word	0x00000005
    37ac:	00000007 	.word	0x00000007
    37b0:	00000009 	.word	0x00000009
    37b4:	0000000e 	.word	0x0000000e
    37b8:	00000010 	.word	0x00000010
    37bc:	00000012 	.word	0x00000012
    37c0:	00000014 	.word	0x00000014
    37c4:	00000016 	.word	0x00000016
    37c8:	00000018 	.word	0x00000018
    37cc:	0000001c 	.word	0x0000001c
    37d0:	0000001e 	.word	0x0000001e
    37d4:	33323130 	.word	0x33323130
    37d8:	37363534 	.word	0x37363534
    37dc:	42413938 	.word	0x42413938
    37e0:	46454443 	.word	0x46454443
    37e4:	00000000 	.word	0x00000000
    37e8:	00006325 	.word	0x00006325
    37ec:	74737953 	.word	0x74737953
    37f0:	69206d65 	.word	0x69206d65
    37f4:	2074696e 	.word	0x2074696e
    37f8:	69676562 	.word	0x69676562
    37fc:	0000006e 	.word	0x0000006e
    3800:	4f525245 	.word	0x4f525245
    3804:	4d203a52 	.word	0x4d203a52
    3808:	61696465 	.word	0x61696465
    380c:	74746120 	.word	0x74746120
    3810:	20686361 	.word	0x20686361
    3814:	6c696166 	.word	0x6c696166
    3818:	000a6465 	.word	0x000a6465
    381c:	00000077 	.word	0x00000077
    3820:	7365742f 	.word	0x7365742f
    3824:	78742e74 	.word	0x78742e74
    3828:	00000074 	.word	0x00000074
    382c:	4f525245 	.word	0x4f525245
    3830:	57203a52 	.word	0x57203a52
    3834:	65746972 	.word	0x65746972
    3838:	6c696620 	.word	0x6c696620
    383c:	61662065 	.word	0x61662065
    3840:	64656c69 	.word	0x64656c69
    3844:	0000000a 	.word	0x0000000a
    3848:	4f525245 	.word	0x4f525245
    384c:	43203a52 	.word	0x43203a52
    3850:	74616572 	.word	0x74616572
    3854:	69662065 	.word	0x69662065
    3858:	6620656c 	.word	0x6620656c
    385c:	656c6961 	.word	0x656c6961
    3860:	00000a64 	.word	0x00000a64
    3864:	00000072 	.word	0x00000072
    3868:	4f525245 	.word	0x4f525245
    386c:	6f203a52 	.word	0x6f203a52
    3870:	206e6570 	.word	0x206e6570
    3874:	656c6966 	.word	0x656c6966
    3878:	69616620 	.word	0x69616620
    387c:	0a64656c 	.word	0x0a64656c
    3880:	00000000 	.word	0x00000000
    3884:	65636e4f 	.word	0x65636e4f
    3888:	6f707520 	.word	0x6f707520
    388c:	2061206e 	.word	0x2061206e
    3890:	656d6974 	.word	0x656d6974
    3894:	65687420 	.word	0x65687420
    3898:	77206572 	.word	0x77206572
    389c:	61207361 	.word	0x61207361
    38a0:	616d7320 	.word	0x616d7320
    38a4:	66206c6c 	.word	0x66206c6c
    38a8:	20656c69 	.word	0x20656c69
    38ac:	74616874 	.word	0x74616874
    38b0:	76696c20 	.word	0x76696c20
    38b4:	6f206465 	.word	0x6f206465
    38b8:	2061206e 	.word	0x2061206e
    38bc:	63204453 	.word	0x63204453
    38c0:	2e647261 	.word	0x2e647261
    38c4:	69685420 	.word	0x69685420
    38c8:	69662073 	.word	0x69662073
    38cc:	7720656c 	.word	0x7720656c
    38d0:	63207361 	.word	0x63207361
    38d4:	6f706d6f 	.word	0x6f706d6f
    38d8:	20646573 	.word	0x20646573
    38dc:	7420666f 	.word	0x7420666f
    38e0:	73206f77 	.word	0x73206f77
    38e4:	65746e65 	.word	0x65746e65
    38e8:	7365636e 	.word	0x7365636e
    38ec:	0000002e 	.word	0x0000002e

000038f0 <_global_impure_ptr>:
    38f0:	20000018 33323130 37363534 62613938     ... 0123456789ab
    3900:	66656463 6a696867 6e6d6c6b 7271706f     cdefghijklmnopqr
    3910:	76757473 7a797877 00000000              stuvwxyz....

0000391c <_init>:
    391c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    391e:	bf00      	nop
    3920:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3922:	bc08      	pop	{r3}
    3924:	469e      	mov	lr, r3
    3926:	4770      	bx	lr

00003928 <__init_array_start>:
    3928:	00003681 	.word	0x00003681

0000392c <__frame_dummy_init_array_entry>:
    392c:	000001a5                                ....

00003930 <_fini>:
    3930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3932:	bf00      	nop
    3934:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3936:	bc08      	pop	{r3}
    3938:	469e      	mov	lr, r3
    393a:	4770      	bx	lr

0000393c <__fini_array_start>:
    393c:	00000181 	.word	0x00000181

Disassembly of section .relocate:

20000000 <delay_cycles>:
void delay_cycles(uint32_t n)
{
	(void)(n);		//Void Cast

//#ifdef _SAM4L_		// SAM4L Series delay function
	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <delay_cycles>
20000008:	4770      	bx	lr
	...

2000000c <SystemCoreClock>:
2000000c:	c138 0001                                   8...

20000010 <Rx>:
20000010:	0000 0400                                   ....

20000014 <Tx>:
20000014:	0000 0800                                   ....

20000018 <impure_data>:
20000018:	0000 0000 0304 2000 036c 2000 03d4 2000     ....... l.. ... 
	...
200000c0:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200000d0:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000440 <__atexit_recursive_mutex>:
20000440:	1164 2000                                   d.. 
