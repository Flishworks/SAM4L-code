
101Xplained Temp Logger.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004044  00000000  00000000  00010000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00004044  00004044  00014044  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000044c  20000000  0000404c  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .hramc1       00000000  21000000  21000000  0002044c  2**0
                  CONTENTS
  4 .bss          00000d9c  2000044c  00004498  0002044c  2**2
                  ALLOC
  5 .stack        00004000  200011e8  00005234  0002044c  2**0
                  ALLOC
  6 .ARM.attributes 0000002a  00000000  00000000  0002044c  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  00020476  2**0
                  CONTENTS, READONLY
  8 .debug_info   0004ecf2  00000000  00000000  000204cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00002bd0  00000000  00000000  0006f1c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000079c6  00000000  00000000  00071d91  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000005c0  00000000  00000000  00079757  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000708  00000000  00000000  00079d17  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0002ef2c  00000000  00000000  0007a41f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00007aa9  00000000  00000000  000a934b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00101281  00000000  00000000  000b0df4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  000014e4  00000000  00000000  001b2078  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	e8 51 00 20 c9 0c 00 00 c5 0c 00 00 c5 0c 00 00     .Q. ............
      10:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 00 00 00 00     ................
	...
      2c:	c5 0c 00 00 c5 0c 00 00 00 00 00 00 c5 0c 00 00     ................
      3c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      4c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      5c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      6c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      7c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      8c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      9c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      ac:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      bc:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      cc:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      dc:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      ec:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
      fc:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
     10c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
     11c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
     12c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
     13c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
     14c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
     15c:	c5 0c 00 00 c5 0c 00 00 c5 0c 00 00 c5 0c 00 00     ................
     16c:	c5 0c 00 00 00 00 00 00 c5 0c 00 00 c5 0c 00 00     ................
     17c:	c5 0c 00 00                                         ....

00000180 <__do_global_dtors_aux>:
     180:	b510      	push	{r4, lr}
     182:	4c05      	ldr	r4, [pc, #20]	; (198 <__do_global_dtors_aux+0x18>)
     184:	7823      	ldrb	r3, [r4, #0]
     186:	b933      	cbnz	r3, 196 <__do_global_dtors_aux+0x16>
     188:	4b04      	ldr	r3, [pc, #16]	; (19c <__do_global_dtors_aux+0x1c>)
     18a:	b113      	cbz	r3, 192 <__do_global_dtors_aux+0x12>
     18c:	4804      	ldr	r0, [pc, #16]	; (1a0 <__do_global_dtors_aux+0x20>)
     18e:	f3af 8000 	nop.w
     192:	2301      	movs	r3, #1
     194:	7023      	strb	r3, [r4, #0]
     196:	bd10      	pop	{r4, pc}
     198:	2000044c 	.word	0x2000044c
     19c:	00000000 	.word	0x00000000
     1a0:	0000404c 	.word	0x0000404c

000001a4 <frame_dummy>:
     1a4:	4b0c      	ldr	r3, [pc, #48]	; (1d8 <frame_dummy+0x34>)
     1a6:	b143      	cbz	r3, 1ba <frame_dummy+0x16>
     1a8:	480c      	ldr	r0, [pc, #48]	; (1dc <frame_dummy+0x38>)
     1aa:	490d      	ldr	r1, [pc, #52]	; (1e0 <frame_dummy+0x3c>)
     1ac:	b510      	push	{r4, lr}
     1ae:	f3af 8000 	nop.w
     1b2:	480c      	ldr	r0, [pc, #48]	; (1e4 <frame_dummy+0x40>)
     1b4:	6803      	ldr	r3, [r0, #0]
     1b6:	b923      	cbnz	r3, 1c2 <frame_dummy+0x1e>
     1b8:	bd10      	pop	{r4, pc}
     1ba:	480a      	ldr	r0, [pc, #40]	; (1e4 <frame_dummy+0x40>)
     1bc:	6803      	ldr	r3, [r0, #0]
     1be:	b933      	cbnz	r3, 1ce <frame_dummy+0x2a>
     1c0:	4770      	bx	lr
     1c2:	4b09      	ldr	r3, [pc, #36]	; (1e8 <frame_dummy+0x44>)
     1c4:	2b00      	cmp	r3, #0
     1c6:	d0f7      	beq.n	1b8 <frame_dummy+0x14>
     1c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     1cc:	4718      	bx	r3
     1ce:	4b06      	ldr	r3, [pc, #24]	; (1e8 <frame_dummy+0x44>)
     1d0:	2b00      	cmp	r3, #0
     1d2:	d0f5      	beq.n	1c0 <frame_dummy+0x1c>
     1d4:	4718      	bx	r3
     1d6:	bf00      	nop
     1d8:	00000000 	.word	0x00000000
     1dc:	0000404c 	.word	0x0000404c
     1e0:	20000450 	.word	0x20000450
     1e4:	0000404c 	.word	0x0000404c
     1e8:	00000000 	.word	0x00000000

000001ec <I2C_read_bytes>:
//A. Kazen
//07-2019

#include "AK_I2C.h"

void I2C_read_bytes(uint8_t address, uint8_t* data, uint8_t num_bytes){
     1ec:	b410      	push	{r4}
	//set up CMDR
	uint32_t CMDR_reg = TWIM_CMDR_SADR(address) | TWIM_CMDR_NBYTES(num_bytes);
	CMDR_reg |= TWIM_CMDR_READ;
	CMDR_reg |= TWIM_CMDR_VALID;
	CMDR_reg |= TWIM_CMDR_START;
	CMDR_reg |= TWIM_CMDR_STOP;
     1ee:	f24e 0301 	movw	r3, #57345	; 0xe001
     1f2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
     1f6:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
	//while (TWIM3->bf.SR.bit.CRDY == 0); // block until ready for command
	TWIM3->bf.SCR.reg = TWIM_SCR_CCOMP; //reset command complete flag
     1fa:	480d      	ldr	r0, [pc, #52]	; (230 <I2C_read_bytes+0x44>)
     1fc:	2408      	movs	r4, #8
     1fe:	62c4      	str	r4, [r0, #44]	; 0x2c
	TWIM3 -> bf.CMDR.reg = CMDR_reg; //this will trigger the read
     200:	60c3      	str	r3, [r0, #12]
	//TWIM3 -> bf.CR.reg = TWIM_CR_MEN;
	for (uint8_t byte=0; byte < num_bytes; byte++){
     202:	b16a      	cbz	r2, 220 <I2C_read_bytes+0x34>
     204:	1e50      	subs	r0, r2, #1
     206:	b2c0      	uxtb	r0, r0
     208:	3001      	adds	r0, #1
     20a:	4408      	add	r0, r1
		while (TWIM3->bf.SR.bit.RXRDY == 0); // block until ready to RX
     20c:	4a08      	ldr	r2, [pc, #32]	; (230 <I2C_read_bytes+0x44>)
     20e:	69d3      	ldr	r3, [r2, #28]
     210:	f013 0f01 	tst.w	r3, #1
     214:	d0fb      	beq.n	20e <I2C_read_bytes+0x22>
		//while (is_I2C_free() == 0); // block until ready
		*data = TWIM3->bf.RHR.reg; //load byte
     216:	6953      	ldr	r3, [r2, #20]
     218:	f801 3b01 	strb.w	r3, [r1], #1
	for (uint8_t byte=0; byte < num_bytes; byte++){
     21c:	4281      	cmp	r1, r0
     21e:	d1f6      	bne.n	20e <I2C_read_bytes+0x22>
		data++;
	}
	while(!TWIM3->bf.SR.bit.CCOMP); // block until command complete
     220:	4a03      	ldr	r2, [pc, #12]	; (230 <I2C_read_bytes+0x44>)
     222:	69d3      	ldr	r3, [r2, #28]
     224:	f013 0f08 	tst.w	r3, #8
     228:	d0fb      	beq.n	222 <I2C_read_bytes+0x36>
}
     22a:	bc10      	pop	{r4}
     22c:	4770      	bx	lr
     22e:	bf00      	nop
     230:	4007c000 	.word	0x4007c000

00000234 <I2C_write_bytes>:

void I2C_write_bytes(uint8_t address, uint8_t* data, uint8_t num_bytes ){
     234:	b410      	push	{r4}
	//set up CMDR
	uint32_t CMDR_reg = TWIM_CMDR_SADR(address) | TWIM_CMDR_NBYTES(num_bytes);
     236:	0413      	lsls	r3, r2, #16
	CMDR_reg |= TWIM_CMDR_VALID;
	CMDR_reg |= TWIM_CMDR_START;
	CMDR_reg |= TWIM_CMDR_STOP;
     238:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
     23c:	ea43 0040 	orr.w	r0, r3, r0, lsl #1
	while (TWIM3->bf.SR.bit.CRDY == 0); // block until ready for command
     240:	4c0f      	ldr	r4, [pc, #60]	; (280 <I2C_write_bytes+0x4c>)
     242:	69e3      	ldr	r3, [r4, #28]
     244:	f013 0f04 	tst.w	r3, #4
     248:	d0fb      	beq.n	242 <I2C_write_bytes+0xe>
	TWIM3->bf.SCR.reg = TWIM_SCR_CCOMP; //reset command complete flag
     24a:	4b0d      	ldr	r3, [pc, #52]	; (280 <I2C_write_bytes+0x4c>)
     24c:	2408      	movs	r4, #8
     24e:	62dc      	str	r4, [r3, #44]	; 0x2c
	TWIM3 -> bf.CMDR.reg = CMDR_reg; //this will trigger the send
     250:	60d8      	str	r0, [r3, #12]
	//TWIM3 -> bf.CR.reg = TWIM_CR_MEN; 
	for (uint8_t byte=0; byte < num_bytes; byte++){
     252:	b16a      	cbz	r2, 270 <I2C_write_bytes+0x3c>
     254:	1e50      	subs	r0, r2, #1
     256:	b2c0      	uxtb	r0, r0
     258:	3001      	adds	r0, #1
     25a:	4408      	add	r0, r1
		while (!(TWIM3->bf.SR.reg & TWIM_SR_TXRDY));
     25c:	461a      	mov	r2, r3
     25e:	69d3      	ldr	r3, [r2, #28]
     260:	f013 0f02 	tst.w	r3, #2
     264:	d0fb      	beq.n	25e <I2C_write_bytes+0x2a>
		//load data to be transmitted into THR
		TWIM3 -> bf.THR.reg = *data;
     266:	f811 3b01 	ldrb.w	r3, [r1], #1
     26a:	6193      	str	r3, [r2, #24]
	for (uint8_t byte=0; byte < num_bytes; byte++){
     26c:	4281      	cmp	r1, r0
     26e:	d1f6      	bne.n	25e <I2C_write_bytes+0x2a>
		data++;
	}
	while(!TWIM3->bf.SR.bit.CCOMP); //// block until command complete
     270:	4a03      	ldr	r2, [pc, #12]	; (280 <I2C_write_bytes+0x4c>)
     272:	69d3      	ldr	r3, [r2, #28]
     274:	f013 0f08 	tst.w	r3, #8
     278:	d0fb      	beq.n	272 <I2C_write_bytes+0x3e>
}
     27a:	bc10      	pop	{r4}
     27c:	4770      	bx	lr
     27e:	bf00      	nop
     280:	4007c000 	.word	0x4007c000

00000284 <TWI_init>:

void TWI_init(SCL, SDA){
	//disable GPIO on TWIM pins
	GPIO->bf.Port[1].bf.GPERC.reg = SCL | SDA; //GPIO_PA23 | GPIO_PA24;
     284:	4301      	orrs	r1, r0
     286:	4b18      	ldr	r3, [pc, #96]	; (2e8 <TWI_init+0x64>)
     288:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
	//set GPIO muxing to TWIM (function C)
	GPIO->bf.Port[1].bf.PMR0C.reg = SCL | SDA; //GPIO_PA23 | GPIO_PA24;
     28c:	f8c3 1218 	str.w	r1, [r3, #536]	; 0x218
	GPIO->bf.Port[1].bf.PMR1S.reg = SCL | SDA; //GPIO_PA23 | GPIO_PA24;
     290:	f8c3 1224 	str.w	r1, [r3, #548]	; 0x224
	GPIO->bf.Port[1].bf.PMR2C.reg = SCL | SDA; // GPIO_PA23 | GPIO_PA24;
     294:	f8c3 1238 	str.w	r1, [r3, #568]	; 0x238
	
	//Set up TWIM3 in PM (PBA Mask)
	PM->bf.UNLOCK.reg = ADDR_UNLOCK(PM_PBAMASK_OFFSET);	// Unlock PBA Register
     298:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     29c:	4a13      	ldr	r2, [pc, #76]	; (2ec <TWI_init+0x68>)
     29e:	659a      	str	r2, [r3, #88]	; 0x58
	PM->bf.PBAMASK.reg |= (uint32_t)(0x1ul << PM_PBAMASK_TWIM3_Pos);	// Enable clock for TWIM
     2a0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     2a2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
     2a6:	629a      	str	r2, [r3, #40]	; 0x28
	
	//set up TWI
	TWIM3->bf.CR.reg = TWIM_CR_MDIS;
     2a8:	f5a3 23c8 	sub.w	r3, r3, #409600	; 0x64000
     2ac:	2002      	movs	r0, #2
     2ae:	6018      	str	r0, [r3, #0]
	TWIM3->bf.CR.reg = TWIM_CR_SWRST;
     2b0:	2280      	movs	r2, #128	; 0x80
     2b2:	601a      	str	r2, [r3, #0]
	TWIM3->bf.SCR.reg = TWIM_SCR_MASK;	// reset all status fields
     2b4:	4a0e      	ldr	r2, [pc, #56]	; (2f0 <TWI_init+0x6c>)
     2b6:	62da      	str	r2, [r3, #44]	; 0x2c
	TWIM3->bf.CR.reg = TWIM_CR_MEN;
     2b8:	2201      	movs	r2, #1
     2ba:	601a      	str	r2, [r3, #0]
	
	//set clock stuff.. this is all pretty much just a guess
	TWIM3 -> bf.CWGR.bit.EXP = 2;
     2bc:	6859      	ldr	r1, [r3, #4]
     2be:	f360 711e 	bfi	r1, r0, #28, #3
     2c2:	6059      	str	r1, [r3, #4]
	TWIM3 -> bf.CWGR.bit.LOW = 1;
     2c4:	6859      	ldr	r1, [r3, #4]
     2c6:	f362 0107 	bfi	r1, r2, #0, #8
     2ca:	6059      	str	r1, [r3, #4]
	TWIM3 -> bf.CWGR.bit.HIGH = 1;
     2cc:	6859      	ldr	r1, [r3, #4]
     2ce:	f362 210f 	bfi	r1, r2, #8, #8
     2d2:	6059      	str	r1, [r3, #4]
	TWIM3 -> bf.CWGR.bit.STASTO = 1;
     2d4:	6859      	ldr	r1, [r3, #4]
     2d6:	f362 4117 	bfi	r1, r2, #16, #8
     2da:	6059      	str	r1, [r3, #4]
	TWIM3 -> bf.CWGR.bit.DATA = 1;
     2dc:	6859      	ldr	r1, [r3, #4]
     2de:	f362 611b 	bfi	r1, r2, #24, #4
     2e2:	6059      	str	r1, [r3, #4]
     2e4:	4770      	bx	lr
     2e6:	bf00      	nop
     2e8:	400e1000 	.word	0x400e1000
     2ec:	aa000028 	.word	0xaa000028
     2f0:	00027f08 	.word	0x00027f08

000002f4 <SPI_init>:
#include "AK_utils.h"

void SPI_init()
{
	//Disable GPIO on pins used for SPI
	GPIO->bf.Port[0].bf.GPERC.reg = (uint32_t)(1) << 21;
     2f4:	4b31      	ldr	r3, [pc, #196]	; (3bc <SPI_init+0xc8>)
     2f6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
     2fa:	609a      	str	r2, [r3, #8]
	GPIO->bf.Port[0].bf.GPERC.reg = (uint32_t)(1) << 22;
     2fc:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
     300:	609a      	str	r2, [r3, #8]
	GPIO->bf.Port[1].bf.GPERC.reg = (uint32_t)(1) << 11;
     302:	f44f 6100 	mov.w	r1, #2048	; 0x800
     306:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
	GPIO->bf.Port[2].bf.GPERC.reg = (uint32_t)(1) << 30;
     30a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     30e:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
	//GPIO->bf.Port[0].bf.GPERC.reg = 0x00200000;
	//GPIO->bf.Port[0].bf.GPERC.reg = GPIO_PA21;
	//GPIO->bf.Port[0].bf.GPERC.bit.P21 = 1; //has a slight performance hit
	
    //Configure peripheral Muxing registers (PMR 0-2) to specify that the peripheral function of these GPIO pins is SPI (peripheral function B)
	GPIO->bf.Port[0].bf.PMR0C.reg = GPIO_PA21 | GPIO_PA22;
     312:	f44f 00c0 	mov.w	r0, #6291456	; 0x600000
     316:	6198      	str	r0, [r3, #24]
	GPIO->bf.Port[0].bf.PMR1C.reg = GPIO_PA21 | GPIO_PA22;
     318:	6298      	str	r0, [r3, #40]	; 0x28
	GPIO->bf.Port[0].bf.PMR2C.reg = GPIO_PA21 | GPIO_PA22;
     31a:	6398      	str	r0, [r3, #56]	; 0x38
	
	GPIO->bf.Port[1].bf.PMR0S.reg = GPIO_PB11B_SPI_NPCS2;
     31c:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
	GPIO->bf.Port[1].bf.PMR1C.reg = GPIO_PB11;
     320:	f8c3 1228 	str.w	r1, [r3, #552]	; 0x228
	GPIO->bf.Port[1].bf.PMR2C.reg = GPIO_PB11;
     324:	f8c3 1238 	str.w	r1, [r3, #568]	; 0x238
	
	GPIO->bf.Port[2].bf.PMR0S.reg = GPIO_PC30;
     328:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
	GPIO->bf.Port[2].bf.PMR1C.reg = GPIO_PC30;
     32c:	f8c3 2428 	str.w	r2, [r3, #1064]	; 0x428
	GPIO->bf.Port[2].bf.PMR2C.reg = GPIO_PC30;
     330:	f8c3 2438 	str.w	r2, [r3, #1080]	; 0x438
	
	//enable system clock to be used for SPI peripheral
	PM->bf.UNLOCK.reg =  0xAA000000 | PM_PBAMASK_OFFSET;
     334:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     338:	4a21      	ldr	r2, [pc, #132]	; (3c0 <SPI_init+0xcc>)
     33a:	659a      	str	r2, [r3, #88]	; 0x58
	PM->bf.PBAMASK.reg |= PM_PBAMASK_SPI;
     33c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     33e:	f042 0202 	orr.w	r2, r2, #2
     342:	629a      	str	r2, [r3, #40]	; 0x28
	
	//configure SPI
	SPI->bf.MR.bit.MSTR = 1; //set mode to master (in mode register);
     344:	f5a3 2358 	sub.w	r3, r3, #884736	; 0xd8000
     348:	685a      	ldr	r2, [r3, #4]
     34a:	f042 0201 	orr.w	r2, r2, #1
     34e:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.MODFDIS = 1;//set mode fault detection to off
     350:	685a      	ldr	r2, [r3, #4]
     352:	f042 0210 	orr.w	r2, r2, #16
     356:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.PS = 0;  //set as fixed peripheral (will need to change this if talking to more than one device)
     358:	685a      	ldr	r2, [r3, #4]
     35a:	f36f 0241 	bfc	r2, #1, #1
     35e:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.PCSDEC = 0;//use CS lines directly not in decode mode)
     360:	685a      	ldr	r2, [r3, #4]
     362:	f36f 0282 	bfc	r2, #2, #1
     366:	605a      	str	r2, [r3, #4]
	SPI->bf.MR.bit.PCS = 0b1011; //peripheral chip select.
     368:	685a      	ldr	r2, [r3, #4]
     36a:	210b      	movs	r1, #11
     36c:	f361 4213 	bfi	r2, r1, #16, #4
     370:	605a      	str	r2, [r3, #4]
    
	SPI->bf.CSR[2].bit.CPOL = 0; //set clock polarity (see reference table)
     372:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     374:	f36f 0200 	bfc	r2, #0, #1
     378:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.NCPHA = 1; //set clock phase (see reference table)
     37a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     37c:	f042 0202 	orr.w	r2, r2, #2
     380:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.CSAAT=1; //something with timing
     382:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     384:	f042 0208 	orr.w	r2, r2, #8
     388:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.CSNAAT=0;
     38a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     38c:	f36f 0282 	bfc	r2, #2, #1
     390:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.BITS = 0; //Configure 8 bit package size
     392:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     394:	f36f 1207 	bfc	r2, #4, #4
     398:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.SCBR =32; //set clock division to 32 (~375 khz)
     39a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     39c:	2120      	movs	r1, #32
     39e:	f361 220f 	bfi	r2, r1, #8, #8
     3a2:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.DLYBS = 0; //other timing stuff
     3a4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     3a6:	f36f 4217 	bfc	r2, #16, #8
     3aa:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CSR[2].bit.DLYBCT = 0;
     3ac:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     3ae:	f36f 621f 	bfc	r2, #24, #8
     3b2:	639a      	str	r2, [r3, #56]	; 0x38
	//or...
	//SPI->bf.CSR[2].reg = SPI_CSR_CPOL_0|SPI_CSR_NCPHA_1|SPI_CSR_CSAAT_1|SPI_CSR_BITS(0)|SPI_CSR_SCBR(1)|SPI_CSR_DLYBS(0)|SPI_CSR_DLYBCT(0);
	
	SPI->bf.CR.reg = SPI_CR_SPIEN; //open the gates for communication (enable SPI)
     3b4:	2201      	movs	r2, #1
     3b6:	601a      	str	r2, [r3, #0]
     3b8:	4770      	bx	lr
     3ba:	bf00      	nop
     3bc:	400e1000 	.word	0x400e1000
     3c0:	aa000028 	.word	0xaa000028
     3c4:	00000000 	.word	0x00000000

000003c8 <SD_send_byte>:
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
	delay_us(10);
	return return_data;
}

uint8_t SD_send_byte(uint8_t byte_to_send){
     3c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     3ca:	4604      	mov	r4, r0
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     3cc:	f44f 6200 	mov.w	r2, #2048	; 0x800
     3d0:	4b21      	ldr	r3, [pc, #132]	; (458 <SD_send_byte+0x90>)
     3d2:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us(10);
     3d6:	4b21      	ldr	r3, [pc, #132]	; (45c <SD_send_byte+0x94>)
     3d8:	681a      	ldr	r2, [r3, #0]
     3da:	2300      	movs	r3, #0
     3dc:	0090      	lsls	r0, r2, #2
     3de:	0f91      	lsrs	r1, r2, #30
     3e0:	1880      	adds	r0, r0, r2
     3e2:	4159      	adcs	r1, r3
     3e4:	1800      	adds	r0, r0, r0
     3e6:	4149      	adcs	r1, r1
     3e8:	4a1d      	ldr	r2, [pc, #116]	; (460 <SD_send_byte+0x98>)
     3ea:	2300      	movs	r3, #0
     3ec:	a718      	add	r7, pc, #96	; (adr r7, 450 <SD_send_byte+0x88>)
     3ee:	e9d7 6700 	ldrd	r6, r7, [r7]
     3f2:	1980      	adds	r0, r0, r6
     3f4:	4179      	adcs	r1, r7
     3f6:	4d1b      	ldr	r5, [pc, #108]	; (464 <SD_send_byte+0x9c>)
     3f8:	47a8      	blx	r5
     3fa:	4b1b      	ldr	r3, [pc, #108]	; (468 <SD_send_byte+0xa0>)
     3fc:	4798      	blx	r3
	//send first byte
	while(SPI->bf.SR.bit.TDRE == 0); //is transmit register empty? //while((SPI->reg.SPI_SR & SPI_SR_TDRE) == 0);
     3fe:	4a1b      	ldr	r2, [pc, #108]	; (46c <SD_send_byte+0xa4>)
     400:	6913      	ldr	r3, [r2, #16]
     402:	f013 0f02 	tst.w	r3, #2
     406:	d0fb      	beq.n	400 <SD_send_byte+0x38>
	SPI->bf.TDR.reg = byte_to_send; //load Transmit Data Register
     408:	4b18      	ldr	r3, [pc, #96]	; (46c <SD_send_byte+0xa4>)
     40a:	60dc      	str	r4, [r3, #12]
	//read data returned
	while (SPI->bf.SR.bit.RDRF == 0); //If byte is present in RDR, will read high
     40c:	461a      	mov	r2, r3
     40e:	6913      	ldr	r3, [r2, #16]
     410:	f013 0f01 	tst.w	r3, #1
     414:	d0fb      	beq.n	40e <SD_send_byte+0x46>
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     416:	f44f 6200 	mov.w	r2, #2048	; 0x800
     41a:	4b0f      	ldr	r3, [pc, #60]	; (458 <SD_send_byte+0x90>)
     41c:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us(10);
     420:	4b0e      	ldr	r3, [pc, #56]	; (45c <SD_send_byte+0x94>)
     422:	681a      	ldr	r2, [r3, #0]
     424:	2300      	movs	r3, #0
     426:	0090      	lsls	r0, r2, #2
     428:	0f91      	lsrs	r1, r2, #30
     42a:	1880      	adds	r0, r0, r2
     42c:	4159      	adcs	r1, r3
     42e:	1800      	adds	r0, r0, r0
     430:	4149      	adcs	r1, r1
     432:	4a0b      	ldr	r2, [pc, #44]	; (460 <SD_send_byte+0x98>)
     434:	2300      	movs	r3, #0
     436:	a506      	add	r5, pc, #24	; (adr r5, 450 <SD_send_byte+0x88>)
     438:	e9d5 4500 	ldrd	r4, r5, [r5]
     43c:	1900      	adds	r0, r0, r4
     43e:	4169      	adcs	r1, r5
     440:	4c08      	ldr	r4, [pc, #32]	; (464 <SD_send_byte+0x9c>)
     442:	47a0      	blx	r4
     444:	4b08      	ldr	r3, [pc, #32]	; (468 <SD_send_byte+0xa0>)
     446:	4798      	blx	r3
	return (uint8_t)SPI->bf.RDR.reg; //to receive data (Receive Data reg)
     448:	4b08      	ldr	r3, [pc, #32]	; (46c <SD_send_byte+0xa4>)
     44a:	6898      	ldr	r0, [r3, #8]
}
     44c:	b2c0      	uxtb	r0, r0
     44e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     450:	00d59f7f 	.word	0x00d59f7f
     454:	00000000 	.word	0x00000000
     458:	400e1000 	.word	0x400e1000
     45c:	2000116c 	.word	0x2000116c
     460:	00d59f80 	.word	0x00d59f80
     464:	000035a9 	.word	0x000035a9
     468:	20000001 	.word	0x20000001
     46c:	40008000 	.word	0x40008000

00000470 <SD_transmit_32>:

uint32_t SD_transmit_32(uint32_t data_out)
{
     470:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     474:	4605      	mov	r5, r0
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     476:	f44f 6200 	mov.w	r2, #2048	; 0x800
     47a:	4b19      	ldr	r3, [pc, #100]	; (4e0 <SD_transmit_32+0x70>)
     47c:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us(10);
     480:	4b18      	ldr	r3, [pc, #96]	; (4e4 <SD_transmit_32+0x74>)
     482:	681a      	ldr	r2, [r3, #0]
     484:	2300      	movs	r3, #0
     486:	0090      	lsls	r0, r2, #2
     488:	0f91      	lsrs	r1, r2, #30
     48a:	1880      	adds	r0, r0, r2
     48c:	4159      	adcs	r1, r3
     48e:	1800      	adds	r0, r0, r0
     490:	4149      	adcs	r1, r1
     492:	4a15      	ldr	r2, [pc, #84]	; (4e8 <SD_transmit_32+0x78>)
     494:	2300      	movs	r3, #0
     496:	a710      	add	r7, pc, #64	; (adr r7, 4d8 <SD_transmit_32+0x68>)
     498:	e9d7 6700 	ldrd	r6, r7, [r7]
     49c:	1980      	adds	r0, r0, r6
     49e:	4179      	adcs	r1, r7
     4a0:	4c12      	ldr	r4, [pc, #72]	; (4ec <SD_transmit_32+0x7c>)
     4a2:	47a0      	blx	r4
     4a4:	4b12      	ldr	r3, [pc, #72]	; (4f0 <SD_transmit_32+0x80>)
     4a6:	4798      	blx	r3
		//uint32_t d_out_temp = data_out;
		//return_data |= (uint32_t)SD_send_byte((uint8_t)(d_out_temp >> (24-(8*i)))) << (24-(8*i));
	//}
	//return return_data;
	
	uint8_t byte0 = SD_send_byte(data_out >> (24-(8*0)));
     4a8:	0e28      	lsrs	r0, r5, #24
     4aa:	4e12      	ldr	r6, [pc, #72]	; (4f4 <SD_transmit_32+0x84>)
     4ac:	47b0      	blx	r6
     4ae:	4680      	mov	r8, r0
	uint8_t byte1 = SD_send_byte(data_out >> (24-(8*1)));
     4b0:	f3c5 4007 	ubfx	r0, r5, #16, #8
     4b4:	47b0      	blx	r6
     4b6:	4604      	mov	r4, r0
	uint8_t byte2 = SD_send_byte(data_out >> (24-(8*2)));
     4b8:	f3c5 2007 	ubfx	r0, r5, #8, #8
     4bc:	47b0      	blx	r6
     4be:	4607      	mov	r7, r0
	uint8_t byte3 = SD_send_byte(data_out >> (24-(8*3)));
     4c0:	b2e8      	uxtb	r0, r5
     4c2:	47b0      	blx	r6
	return byte0<<(24-(8*0))|byte1<<(24-(8*1))|byte2<<(24-(8*2))|byte3<<(24-(8*3));
     4c4:	0424      	lsls	r4, r4, #16
     4c6:	ea44 6408 	orr.w	r4, r4, r8, lsl #24
     4ca:	4320      	orrs	r0, r4
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
	delay_us(10);
}
     4cc:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
     4d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     4d4:	f3af 8000 	nop.w
     4d8:	00d59f7f 	.word	0x00d59f7f
     4dc:	00000000 	.word	0x00000000
     4e0:	400e1000 	.word	0x400e1000
     4e4:	2000116c 	.word	0x2000116c
     4e8:	00d59f80 	.word	0x00d59f80
     4ec:	000035a9 	.word	0x000035a9
     4f0:	20000001 	.word	0x20000001
     4f4:	000003c9 	.word	0x000003c9

000004f8 <SD_send_command_cmd_0>:
uint8_t SD_send_command_cmd_0(void){
     4f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     4fa:	240a      	movs	r4, #10
	for (uint8_t i=0; i<10; i++){SD_send_byte(0xFF);} //send some dummy codes
     4fc:	26ff      	movs	r6, #255	; 0xff
     4fe:	4d28      	ldr	r5, [pc, #160]	; (5a0 <SD_send_command_cmd_0+0xa8>)
     500:	4630      	mov	r0, r6
     502:	47a8      	blx	r5
     504:	1e63      	subs	r3, r4, #1
     506:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
     50a:	d1f9      	bne.n	500 <SD_send_command_cmd_0+0x8>
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     50c:	f44f 6200 	mov.w	r2, #2048	; 0x800
     510:	4b24      	ldr	r3, [pc, #144]	; (5a4 <SD_send_command_cmd_0+0xac>)
     512:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us(10);
     516:	4b24      	ldr	r3, [pc, #144]	; (5a8 <SD_send_command_cmd_0+0xb0>)
     518:	681a      	ldr	r2, [r3, #0]
     51a:	2300      	movs	r3, #0
     51c:	0090      	lsls	r0, r2, #2
     51e:	0f91      	lsrs	r1, r2, #30
     520:	1880      	adds	r0, r0, r2
     522:	4159      	adcs	r1, r3
     524:	1800      	adds	r0, r0, r0
     526:	4149      	adcs	r1, r1
     528:	4a20      	ldr	r2, [pc, #128]	; (5ac <SD_send_command_cmd_0+0xb4>)
     52a:	2300      	movs	r3, #0
     52c:	a51a      	add	r5, pc, #104	; (adr r5, 598 <SD_send_command_cmd_0+0xa0>)
     52e:	e9d5 4500 	ldrd	r4, r5, [r5]
     532:	1900      	adds	r0, r0, r4
     534:	4169      	adcs	r1, r5
     536:	4c1e      	ldr	r4, [pc, #120]	; (5b0 <SD_send_command_cmd_0+0xb8>)
     538:	47a0      	blx	r4
     53a:	4b1e      	ldr	r3, [pc, #120]	; (5b4 <SD_send_command_cmd_0+0xbc>)
     53c:	4798      	blx	r3
	return_byte = SD_send_byte(0b01000000);
     53e:	2040      	movs	r0, #64	; 0x40
     540:	4c17      	ldr	r4, [pc, #92]	; (5a0 <SD_send_command_cmd_0+0xa8>)
     542:	47a0      	blx	r4
	SD_transmit_32(0ul);
     544:	2000      	movs	r0, #0
     546:	4b1c      	ldr	r3, [pc, #112]	; (5b8 <SD_send_command_cmd_0+0xc0>)
     548:	4798      	blx	r3
	return_byte = SD_send_byte(0x95); //CRC field
     54a:	2095      	movs	r0, #149	; 0x95
     54c:	47a0      	blx	r4
	while (return_byte == 0xFF) return_byte = SD_send_byte(0xFF); //send 0xFF while reading in data from SD.
     54e:	26ff      	movs	r6, #255	; 0xff
     550:	4625      	mov	r5, r4
     552:	4630      	mov	r0, r6
     554:	47a8      	blx	r5
     556:	4604      	mov	r4, r0
     558:	28ff      	cmp	r0, #255	; 0xff
     55a:	d0fa      	beq.n	552 <SD_send_command_cmd_0+0x5a>
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     55c:	f44f 6200 	mov.w	r2, #2048	; 0x800
     560:	4b10      	ldr	r3, [pc, #64]	; (5a4 <SD_send_command_cmd_0+0xac>)
     562:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us(10);
     566:	4b10      	ldr	r3, [pc, #64]	; (5a8 <SD_send_command_cmd_0+0xb0>)
     568:	681a      	ldr	r2, [r3, #0]
     56a:	2300      	movs	r3, #0
     56c:	0090      	lsls	r0, r2, #2
     56e:	0f91      	lsrs	r1, r2, #30
     570:	1880      	adds	r0, r0, r2
     572:	4159      	adcs	r1, r3
     574:	1800      	adds	r0, r0, r0
     576:	4149      	adcs	r1, r1
     578:	4a0c      	ldr	r2, [pc, #48]	; (5ac <SD_send_command_cmd_0+0xb4>)
     57a:	2300      	movs	r3, #0
     57c:	a706      	add	r7, pc, #24	; (adr r7, 598 <SD_send_command_cmd_0+0xa0>)
     57e:	e9d7 6700 	ldrd	r6, r7, [r7]
     582:	1980      	adds	r0, r0, r6
     584:	4179      	adcs	r1, r7
     586:	4d0a      	ldr	r5, [pc, #40]	; (5b0 <SD_send_command_cmd_0+0xb8>)
     588:	47a8      	blx	r5
     58a:	4b0a      	ldr	r3, [pc, #40]	; (5b4 <SD_send_command_cmd_0+0xbc>)
     58c:	4798      	blx	r3
}
     58e:	4620      	mov	r0, r4
     590:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     592:	bf00      	nop
     594:	f3af 8000 	nop.w
     598:	00d59f7f 	.word	0x00d59f7f
     59c:	00000000 	.word	0x00000000
     5a0:	000003c9 	.word	0x000003c9
     5a4:	400e1000 	.word	0x400e1000
     5a8:	2000116c 	.word	0x2000116c
     5ac:	00d59f80 	.word	0x00d59f80
     5b0:	000035a9 	.word	0x000035a9
     5b4:	20000001 	.word	0x20000001
     5b8:	00000471 	.word	0x00000471
     5bc:	00000000 	.word	0x00000000

000005c0 <SD_send_command_R1>:
uint8_t SD_send_command_R1(uint8_t cmd, uint32_t argument, uint8_t crc){
     5c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     5c4:	b082      	sub	sp, #8
     5c6:	4680      	mov	r8, r0
     5c8:	460f      	mov	r7, r1
     5ca:	4616      	mov	r6, r2
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     5cc:	f44f 6200 	mov.w	r2, #2048	; 0x800
     5d0:	4b2d      	ldr	r3, [pc, #180]	; (688 <SD_send_command_R1+0xc8>)
     5d2:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us(10);
     5d6:	4b2d      	ldr	r3, [pc, #180]	; (68c <SD_send_command_R1+0xcc>)
     5d8:	681a      	ldr	r2, [r3, #0]
     5da:	2300      	movs	r3, #0
     5dc:	0090      	lsls	r0, r2, #2
     5de:	0f91      	lsrs	r1, r2, #30
     5e0:	1880      	adds	r0, r0, r2
     5e2:	4159      	adcs	r1, r3
     5e4:	1800      	adds	r0, r0, r0
     5e6:	4149      	adcs	r1, r1
     5e8:	4a29      	ldr	r2, [pc, #164]	; (690 <SD_send_command_R1+0xd0>)
     5ea:	2300      	movs	r3, #0
     5ec:	a524      	add	r5, pc, #144	; (adr r5, 680 <SD_send_command_R1+0xc0>)
     5ee:	e9d5 4500 	ldrd	r4, r5, [r5]
     5f2:	1900      	adds	r0, r0, r4
     5f4:	4169      	adcs	r1, r5
     5f6:	4c27      	ldr	r4, [pc, #156]	; (694 <SD_send_command_R1+0xd4>)
     5f8:	47a0      	blx	r4
     5fa:	4b27      	ldr	r3, [pc, #156]	; (698 <SD_send_command_R1+0xd8>)
     5fc:	4798      	blx	r3
	while (SD_send_byte(0xFF) != 0xFF); //wait till DO goes high, indicating SD ready to receive command
     5fe:	25ff      	movs	r5, #255	; 0xff
     600:	4c26      	ldr	r4, [pc, #152]	; (69c <SD_send_command_R1+0xdc>)
     602:	4628      	mov	r0, r5
     604:	47a0      	blx	r4
     606:	28ff      	cmp	r0, #255	; 0xff
     608:	d1fb      	bne.n	602 <SD_send_command_R1+0x42>
	SD_send_byte(cmd | 0b01000000);
     60a:	f048 0040 	orr.w	r0, r8, #64	; 0x40
     60e:	4c23      	ldr	r4, [pc, #140]	; (69c <SD_send_command_R1+0xdc>)
     610:	47a0      	blx	r4
	SD_transmit_32(argument);
     612:	4638      	mov	r0, r7
     614:	4b22      	ldr	r3, [pc, #136]	; (6a0 <SD_send_command_R1+0xe0>)
     616:	4798      	blx	r3
	SD_send_byte(crc); //CRC field
     618:	4630      	mov	r0, r6
     61a:	47a0      	blx	r4
	volatile uint8_t return_byte = 0xFF;
     61c:	23ff      	movs	r3, #255	; 0xff
     61e:	f88d 3007 	strb.w	r3, [sp, #7]
	while (return_byte == 0xFF) return_byte = SD_send_byte(0xFF); //send 0xFF while reading in data from SD.
     622:	f89d 3007 	ldrb.w	r3, [sp, #7]
     626:	b2db      	uxtb	r3, r3
     628:	2bff      	cmp	r3, #255	; 0xff
     62a:	d109      	bne.n	640 <SD_send_command_R1+0x80>
     62c:	25ff      	movs	r5, #255	; 0xff
     62e:	4628      	mov	r0, r5
     630:	47a0      	blx	r4
     632:	f88d 0007 	strb.w	r0, [sp, #7]
     636:	f89d 3007 	ldrb.w	r3, [sp, #7]
     63a:	b2db      	uxtb	r3, r3
     63c:	2bff      	cmp	r3, #255	; 0xff
     63e:	d0f6      	beq.n	62e <SD_send_command_R1+0x6e>
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     640:	f44f 6200 	mov.w	r2, #2048	; 0x800
     644:	4b10      	ldr	r3, [pc, #64]	; (688 <SD_send_command_R1+0xc8>)
     646:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us(10);
     64a:	4b10      	ldr	r3, [pc, #64]	; (68c <SD_send_command_R1+0xcc>)
     64c:	681a      	ldr	r2, [r3, #0]
     64e:	2300      	movs	r3, #0
     650:	0090      	lsls	r0, r2, #2
     652:	0f91      	lsrs	r1, r2, #30
     654:	1880      	adds	r0, r0, r2
     656:	4159      	adcs	r1, r3
     658:	1800      	adds	r0, r0, r0
     65a:	4149      	adcs	r1, r1
     65c:	4a0c      	ldr	r2, [pc, #48]	; (690 <SD_send_command_R1+0xd0>)
     65e:	2300      	movs	r3, #0
     660:	a507      	add	r5, pc, #28	; (adr r5, 680 <SD_send_command_R1+0xc0>)
     662:	e9d5 4500 	ldrd	r4, r5, [r5]
     666:	1900      	adds	r0, r0, r4
     668:	4169      	adcs	r1, r5
     66a:	4c0a      	ldr	r4, [pc, #40]	; (694 <SD_send_command_R1+0xd4>)
     66c:	47a0      	blx	r4
     66e:	4b0a      	ldr	r3, [pc, #40]	; (698 <SD_send_command_R1+0xd8>)
     670:	4798      	blx	r3
	return return_byte;
     672:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
     676:	b002      	add	sp, #8
     678:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     67c:	f3af 8000 	nop.w
     680:	00d59f7f 	.word	0x00d59f7f
     684:	00000000 	.word	0x00000000
     688:	400e1000 	.word	0x400e1000
     68c:	2000116c 	.word	0x2000116c
     690:	00d59f80 	.word	0x00d59f80
     694:	000035a9 	.word	0x000035a9
     698:	20000001 	.word	0x20000001
     69c:	000003c9 	.word	0x000003c9
     6a0:	00000471 	.word	0x00000471

000006a4 <SD_write_single_block>:
void SD_write_single_block(uint32_t address, uint8_t *data){
     6a4:	b570      	push	{r4, r5, r6, lr}
     6a6:	460c      	mov	r4, r1
	uint8_t r1_response = SD_send_command_R1(24, address, 0xFF); //send cmd 24 with argument specifying address
     6a8:	22ff      	movs	r2, #255	; 0xff
     6aa:	4601      	mov	r1, r0
     6ac:	2018      	movs	r0, #24
     6ae:	4b13      	ldr	r3, [pc, #76]	; (6fc <SD_write_single_block+0x58>)
     6b0:	4798      	blx	r3
	if (r1_response != 0){throw_error();};
     6b2:	b9f8      	cbnz	r0, 6f4 <SD_write_single_block+0x50>
	SD_send_byte(0xFF); //send dummy variable to give the card some time
     6b4:	20ff      	movs	r0, #255	; 0xff
     6b6:	4d12      	ldr	r5, [pc, #72]	; (700 <SD_write_single_block+0x5c>)
     6b8:	47a8      	blx	r5
	SD_send_byte(0b11111110); //send data token
     6ba:	20fe      	movs	r0, #254	; 0xfe
     6bc:	47a8      	blx	r5
     6be:	f504 7600 	add.w	r6, r4, #512	; 0x200
		SD_send_byte(*data); //send value at address
     6c2:	f814 0b01 	ldrb.w	r0, [r4], #1
     6c6:	47a8      	blx	r5
	for (uint16_t i = 0; i < 512; i++) { //data
     6c8:	42a6      	cmp	r6, r4
     6ca:	d1fa      	bne.n	6c2 <SD_write_single_block+0x1e>
	SD_send_byte(0);// send  two byte CRC
     6cc:	2000      	movs	r0, #0
     6ce:	4c0c      	ldr	r4, [pc, #48]	; (700 <SD_write_single_block+0x5c>)
     6d0:	47a0      	blx	r4
	SD_send_byte(0xFF); // send CRC
     6d2:	20ff      	movs	r0, #255	; 0xff
     6d4:	47a0      	blx	r4
	uint8_t response = SD_send_byte(0xFF); //send dummy variable to get response
     6d6:	20ff      	movs	r0, #255	; 0xff
     6d8:	47a0      	blx	r4
     6da:	4606      	mov	r6, r0
	while(SD_send_byte(0xFF) != 0xFF); //wait for card to not be busy
     6dc:	25ff      	movs	r5, #255	; 0xff
     6de:	4628      	mov	r0, r5
     6e0:	47a0      	blx	r4
     6e2:	28ff      	cmp	r0, #255	; 0xff
     6e4:	d1fb      	bne.n	6de <SD_write_single_block+0x3a>
	if ((response & 0b00001111) != 0b00000101){throw_error();};
     6e6:	f006 060f 	and.w	r6, r6, #15
     6ea:	2e05      	cmp	r6, #5
     6ec:	d001      	beq.n	6f2 <SD_write_single_block+0x4e>
     6ee:	4b05      	ldr	r3, [pc, #20]	; (704 <SD_write_single_block+0x60>)
     6f0:	4798      	blx	r3
     6f2:	bd70      	pop	{r4, r5, r6, pc}
	if (r1_response != 0){throw_error();};
     6f4:	4b03      	ldr	r3, [pc, #12]	; (704 <SD_write_single_block+0x60>)
     6f6:	4798      	blx	r3
     6f8:	e7dc      	b.n	6b4 <SD_write_single_block+0x10>
     6fa:	bf00      	nop
     6fc:	000005c1 	.word	0x000005c1
     700:	000003c9 	.word	0x000003c9
     704:	00000b49 	.word	0x00000b49

00000708 <SD_read_single_block>:
void SD_read_single_block(uint32_t address, uint8_t *data){	
     708:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     70a:	460c      	mov	r4, r1
	uint8_t r1_response = SD_send_command_R1(17, address, 0xFF); //read from address 
     70c:	22ff      	movs	r2, #255	; 0xff
     70e:	4601      	mov	r1, r0
     710:	2011      	movs	r0, #17
     712:	4b0e      	ldr	r3, [pc, #56]	; (74c <SD_read_single_block+0x44>)
     714:	4798      	blx	r3
	if (r1_response != 0){throw_error();};
     716:	b9a8      	cbnz	r0, 744 <SD_read_single_block+0x3c>
	while (SD_send_byte(0xFF)!=0b11111110){}; //wait for data token
     718:	26ff      	movs	r6, #255	; 0xff
     71a:	4d0d      	ldr	r5, [pc, #52]	; (750 <SD_read_single_block+0x48>)
     71c:	4630      	mov	r0, r6
     71e:	47a8      	blx	r5
     720:	28fe      	cmp	r0, #254	; 0xfe
     722:	d1fb      	bne.n	71c <SD_read_single_block+0x14>
     724:	f504 7700 	add.w	r7, r4, #512	; 0x200
		*data = SD_send_byte(0xFF); //store value at variable address
     728:	26ff      	movs	r6, #255	; 0xff
     72a:	4d09      	ldr	r5, [pc, #36]	; (750 <SD_read_single_block+0x48>)
     72c:	4630      	mov	r0, r6
     72e:	47a8      	blx	r5
     730:	f804 0b01 	strb.w	r0, [r4], #1
	for(uint16_t i=0; i < 512; i++){
     734:	42a7      	cmp	r7, r4
     736:	d1f9      	bne.n	72c <SD_read_single_block+0x24>
	SD_send_byte(0xFF);//receive CRC
     738:	20ff      	movs	r0, #255	; 0xff
     73a:	4c05      	ldr	r4, [pc, #20]	; (750 <SD_read_single_block+0x48>)
     73c:	47a0      	blx	r4
	SD_send_byte(0xFF);
     73e:	20ff      	movs	r0, #255	; 0xff
     740:	47a0      	blx	r4
     742:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (r1_response != 0){throw_error();};
     744:	4b03      	ldr	r3, [pc, #12]	; (754 <SD_read_single_block+0x4c>)
     746:	4798      	blx	r3
     748:	e7e6      	b.n	718 <SD_read_single_block+0x10>
     74a:	bf00      	nop
     74c:	000005c1 	.word	0x000005c1
     750:	000003c9 	.word	0x000003c9
     754:	00000b49 	.word	0x00000b49

00000758 <SD_send_command_R3>:
uint32_t SD_send_command_R3(uint8_t cmd, uint32_t argument, uint8_t crc){
     758:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     75c:	b082      	sub	sp, #8
     75e:	4680      	mov	r8, r0
     760:	460f      	mov	r7, r1
     762:	4616      	mov	r6, r2
	GPIO->bf.Port[1].bf.OVRC.reg = (uint32_t)(1) << 11; //set GPIO output to low
     764:	f44f 6200 	mov.w	r2, #2048	; 0x800
     768:	4b2f      	ldr	r3, [pc, #188]	; (828 <SD_send_command_R3+0xd0>)
     76a:	f8c3 2258 	str.w	r2, [r3, #600]	; 0x258
	delay_us(10);
     76e:	4b2f      	ldr	r3, [pc, #188]	; (82c <SD_send_command_R3+0xd4>)
     770:	681a      	ldr	r2, [r3, #0]
     772:	2300      	movs	r3, #0
     774:	0090      	lsls	r0, r2, #2
     776:	0f91      	lsrs	r1, r2, #30
     778:	1880      	adds	r0, r0, r2
     77a:	4159      	adcs	r1, r3
     77c:	1800      	adds	r0, r0, r0
     77e:	4149      	adcs	r1, r1
     780:	4a2b      	ldr	r2, [pc, #172]	; (830 <SD_send_command_R3+0xd8>)
     782:	2300      	movs	r3, #0
     784:	a526      	add	r5, pc, #152	; (adr r5, 820 <SD_send_command_R3+0xc8>)
     786:	e9d5 4500 	ldrd	r4, r5, [r5]
     78a:	1900      	adds	r0, r0, r4
     78c:	4169      	adcs	r1, r5
     78e:	4c29      	ldr	r4, [pc, #164]	; (834 <SD_send_command_R3+0xdc>)
     790:	47a0      	blx	r4
     792:	4b29      	ldr	r3, [pc, #164]	; (838 <SD_send_command_R3+0xe0>)
     794:	4798      	blx	r3
	while (SD_send_byte(0xFF) != 0xFF); //wait till DO goes high, indicating SD read to receive command
     796:	25ff      	movs	r5, #255	; 0xff
     798:	4c28      	ldr	r4, [pc, #160]	; (83c <SD_send_command_R3+0xe4>)
     79a:	4628      	mov	r0, r5
     79c:	47a0      	blx	r4
     79e:	28ff      	cmp	r0, #255	; 0xff
     7a0:	d1fb      	bne.n	79a <SD_send_command_R3+0x42>
	SD_send_byte(cmd | 0b01000000);
     7a2:	f048 0040 	orr.w	r0, r8, #64	; 0x40
     7a6:	4c25      	ldr	r4, [pc, #148]	; (83c <SD_send_command_R3+0xe4>)
     7a8:	47a0      	blx	r4
	SD_transmit_32(argument);
     7aa:	4638      	mov	r0, r7
     7ac:	4b24      	ldr	r3, [pc, #144]	; (840 <SD_send_command_R3+0xe8>)
     7ae:	4798      	blx	r3
	SD_send_byte(crc); //CRC field
     7b0:	4630      	mov	r0, r6
     7b2:	47a0      	blx	r4
	volatile uint8_t return_byte = 0xFF;
     7b4:	23ff      	movs	r3, #255	; 0xff
     7b6:	f88d 3007 	strb.w	r3, [sp, #7]
	volatile uint32_t return_data = 0;
     7ba:	2300      	movs	r3, #0
     7bc:	9300      	str	r3, [sp, #0]
	while (return_byte == 0xFF) return_byte = SD_send_byte(0xFF); //send 0xFF while reading in data from SD.
     7be:	f89d 3007 	ldrb.w	r3, [sp, #7]
     7c2:	b2db      	uxtb	r3, r3
     7c4:	2bff      	cmp	r3, #255	; 0xff
     7c6:	d109      	bne.n	7dc <SD_send_command_R3+0x84>
     7c8:	25ff      	movs	r5, #255	; 0xff
     7ca:	4628      	mov	r0, r5
     7cc:	47a0      	blx	r4
     7ce:	f88d 0007 	strb.w	r0, [sp, #7]
     7d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
     7d6:	b2db      	uxtb	r3, r3
     7d8:	2bff      	cmp	r3, #255	; 0xff
     7da:	d0f6      	beq.n	7ca <SD_send_command_R3+0x72>
	return_data = SD_transmit_32(0xFFFFFFFF);
     7dc:	f04f 30ff 	mov.w	r0, #4294967295
     7e0:	4b17      	ldr	r3, [pc, #92]	; (840 <SD_send_command_R3+0xe8>)
     7e2:	4798      	blx	r3
     7e4:	9000      	str	r0, [sp, #0]
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     7e6:	f44f 6200 	mov.w	r2, #2048	; 0x800
     7ea:	4b0f      	ldr	r3, [pc, #60]	; (828 <SD_send_command_R3+0xd0>)
     7ec:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	delay_us(10);
     7f0:	4b0e      	ldr	r3, [pc, #56]	; (82c <SD_send_command_R3+0xd4>)
     7f2:	681a      	ldr	r2, [r3, #0]
     7f4:	2300      	movs	r3, #0
     7f6:	0090      	lsls	r0, r2, #2
     7f8:	0f91      	lsrs	r1, r2, #30
     7fa:	1880      	adds	r0, r0, r2
     7fc:	4159      	adcs	r1, r3
     7fe:	1800      	adds	r0, r0, r0
     800:	4149      	adcs	r1, r1
     802:	4a0b      	ldr	r2, [pc, #44]	; (830 <SD_send_command_R3+0xd8>)
     804:	2300      	movs	r3, #0
     806:	a506      	add	r5, pc, #24	; (adr r5, 820 <SD_send_command_R3+0xc8>)
     808:	e9d5 4500 	ldrd	r4, r5, [r5]
     80c:	1900      	adds	r0, r0, r4
     80e:	4169      	adcs	r1, r5
     810:	4c08      	ldr	r4, [pc, #32]	; (834 <SD_send_command_R3+0xdc>)
     812:	47a0      	blx	r4
     814:	4b08      	ldr	r3, [pc, #32]	; (838 <SD_send_command_R3+0xe0>)
     816:	4798      	blx	r3
	return return_data;
     818:	9800      	ldr	r0, [sp, #0]
}
     81a:	b002      	add	sp, #8
     81c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     820:	00d59f7f 	.word	0x00d59f7f
     824:	00000000 	.word	0x00000000
     828:	400e1000 	.word	0x400e1000
     82c:	2000116c 	.word	0x2000116c
     830:	00d59f80 	.word	0x00d59f80
     834:	000035a9 	.word	0x000035a9
     838:	20000001 	.word	0x20000001
     83c:	000003c9 	.word	0x000003c9
     840:	00000471 	.word	0x00000471
     844:	00000000 	.word	0x00000000

00000848 <SD_init>:
void SD_init(){
     848:	b570      	push	{r4, r5, r6, lr}
     84a:	b082      	sub	sp, #8
	SPI->bf.CR.bit.SPIDIS = 1;
     84c:	4b3a      	ldr	r3, [pc, #232]	; (938 <SD_init+0xf0>)
     84e:	681a      	ldr	r2, [r3, #0]
     850:	f042 0202 	orr.w	r2, r2, #2
     854:	601a      	str	r2, [r3, #0]
	SPI->bf.CSR[2].bit.SCBR = 32; //set clock division to 32 (~375 khz)
     856:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     858:	2120      	movs	r1, #32
     85a:	f361 220f 	bfi	r2, r1, #8, #8
     85e:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CR.bit.SPIEN = 1;
     860:	681a      	ldr	r2, [r3, #0]
     862:	f042 0201 	orr.w	r2, r2, #1
     866:	601a      	str	r2, [r3, #0]
	GPIO->bf.Port[1].bf.OVRS.reg = (uint32_t)(1) << 11; //set GPIO output to high
     868:	f503 2359 	add.w	r3, r3, #888832	; 0xd9000
     86c:	f44f 6200 	mov.w	r2, #2048	; 0x800
     870:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254
	GPIO->bf.Port[1].bf.ODERS.reg = (uint32_t)(1) << 11; //set GPIO output to output
     874:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244
	GPIO->bf.Port[1].bf.GPERS.reg = (uint32_t)(1) << 11; // enable GPIO
     878:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
     87c:	240c      	movs	r4, #12
		SD_send_byte(0xFF);
     87e:	26ff      	movs	r6, #255	; 0xff
     880:	4d2e      	ldr	r5, [pc, #184]	; (93c <SD_init+0xf4>)
     882:	4630      	mov	r0, r6
     884:	47a8      	blx	r5
     886:	1e63      	subs	r3, r4, #1
	for (uint8_t i=0; i<12; i++)
     888:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
     88c:	d1f9      	bne.n	882 <SD_init+0x3a>
	SPI->bf.CR.bit.SPIDIS = 1;
     88e:	4b2a      	ldr	r3, [pc, #168]	; (938 <SD_init+0xf0>)
     890:	681a      	ldr	r2, [r3, #0]
     892:	f042 0202 	orr.w	r2, r2, #2
     896:	601a      	str	r2, [r3, #0]
	SPI->bf.CSR[2].bit.SCBR = 8; //set clock division to 8 (1.5mhz?)
     898:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     89a:	2108      	movs	r1, #8
     89c:	f361 220f 	bfi	r2, r1, #8, #8
     8a0:	639a      	str	r2, [r3, #56]	; 0x38
	SPI->bf.CR.bit.SPIEN = 1;
     8a2:	681a      	ldr	r2, [r3, #0]
     8a4:	f042 0201 	orr.w	r2, r2, #1
     8a8:	601a      	str	r2, [r3, #0]
	while(SD_send_command_cmd_0() != 0x01);
     8aa:	4c25      	ldr	r4, [pc, #148]	; (940 <SD_init+0xf8>)
     8ac:	47a0      	blx	r4
     8ae:	2801      	cmp	r0, #1
     8b0:	d1fc      	bne.n	8ac <SD_init+0x64>
	uint32_t response = SD_send_command_R3(8, 0x000001AA, 0x87);
     8b2:	2287      	movs	r2, #135	; 0x87
     8b4:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
     8b8:	2008      	movs	r0, #8
     8ba:	4b22      	ldr	r3, [pc, #136]	; (944 <SD_init+0xfc>)
     8bc:	4798      	blx	r3
	if(response != 0x000001AA){throw_error();};
     8be:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
     8c2:	d001      	beq.n	8c8 <SD_init+0x80>
     8c4:	4b20      	ldr	r3, [pc, #128]	; (948 <SD_init+0x100>)
     8c6:	4798      	blx	r3
	return_byte = 0x01;
     8c8:	2301      	movs	r3, #1
     8ca:	f88d 3007 	strb.w	r3, [sp, #7]
	while(return_byte != 0){
     8ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
     8d2:	b18b      	cbz	r3, 8f8 <SD_init+0xb0>
		SD_send_command_R1(55,0,0x01);
     8d4:	2501      	movs	r5, #1
     8d6:	2600      	movs	r6, #0
     8d8:	4c1c      	ldr	r4, [pc, #112]	; (94c <SD_init+0x104>)
     8da:	462a      	mov	r2, r5
     8dc:	4631      	mov	r1, r6
     8de:	2037      	movs	r0, #55	; 0x37
     8e0:	47a0      	blx	r4
		return_byte = SD_send_command_R1(41,1<<30,0x01);
     8e2:	462a      	mov	r2, r5
     8e4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
     8e8:	2029      	movs	r0, #41	; 0x29
     8ea:	47a0      	blx	r4
     8ec:	f88d 0007 	strb.w	r0, [sp, #7]
	while(return_byte != 0){
     8f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
     8f4:	2b00      	cmp	r3, #0
     8f6:	d1f0      	bne.n	8da <SD_init+0x92>
	return_data = SD_send_command_R3(58, 0, 1);
     8f8:	2201      	movs	r2, #1
     8fa:	2100      	movs	r1, #0
     8fc:	203a      	movs	r0, #58	; 0x3a
     8fe:	4b11      	ldr	r3, [pc, #68]	; (944 <SD_init+0xfc>)
     900:	4798      	blx	r3
     902:	9000      	str	r0, [sp, #0]
	delay_us(10); //for breakpoint
     904:	4b12      	ldr	r3, [pc, #72]	; (950 <SD_init+0x108>)
     906:	681a      	ldr	r2, [r3, #0]
     908:	2300      	movs	r3, #0
     90a:	0090      	lsls	r0, r2, #2
     90c:	0f91      	lsrs	r1, r2, #30
     90e:	1880      	adds	r0, r0, r2
     910:	4159      	adcs	r1, r3
     912:	1800      	adds	r0, r0, r0
     914:	4149      	adcs	r1, r1
     916:	4a0f      	ldr	r2, [pc, #60]	; (954 <SD_init+0x10c>)
     918:	2300      	movs	r3, #0
     91a:	a505      	add	r5, pc, #20	; (adr r5, 930 <SD_init+0xe8>)
     91c:	e9d5 4500 	ldrd	r4, r5, [r5]
     920:	1900      	adds	r0, r0, r4
     922:	4169      	adcs	r1, r5
     924:	4c0c      	ldr	r4, [pc, #48]	; (958 <SD_init+0x110>)
     926:	47a0      	blx	r4
     928:	4b0c      	ldr	r3, [pc, #48]	; (95c <SD_init+0x114>)
     92a:	4798      	blx	r3
}
     92c:	b002      	add	sp, #8
     92e:	bd70      	pop	{r4, r5, r6, pc}
     930:	00d59f7f 	.word	0x00d59f7f
     934:	00000000 	.word	0x00000000
     938:	40008000 	.word	0x40008000
     93c:	000003c9 	.word	0x000003c9
     940:	000004f9 	.word	0x000004f9
     944:	00000759 	.word	0x00000759
     948:	00000b49 	.word	0x00000b49
     94c:	000005c1 	.word	0x000005c1
     950:	2000116c 	.word	0x2000116c
     954:	00d59f80 	.word	0x00d59f80
     958:	000035a9 	.word	0x000035a9
     95c:	20000001 	.word	0x20000001

00000960 <USART_write_char>:
	//USART_write_char('n');
}

void USART_write_char(uint8_t data){
	//Check that CSR.TXRDY is one before writing to THR
	while (!USART1->bf.CSR.USART.TXRDY); //set when THR is empty.
     960:	4a05      	ldr	r2, [pc, #20]	; (978 <USART_write_char+0x18>)
     962:	6953      	ldr	r3, [r2, #20]
     964:	f013 0f02 	tst.w	r3, #2
     968:	d0fb      	beq.n	962 <USART_write_char+0x2>
	USART1->bf.THR.bit.TXCHR = data;
     96a:	4b03      	ldr	r3, [pc, #12]	; (978 <USART_write_char+0x18>)
     96c:	69da      	ldr	r2, [r3, #28]
     96e:	f360 0208 	bfi	r2, r0, #0, #9
     972:	61da      	str	r2, [r3, #28]
     974:	4770      	bx	lr
     976:	bf00      	nop
     978:	40028000 	.word	0x40028000

0000097c <USART_print>:
	for (uint32_t i = 0; i < size; i++) { //data
     97c:	b151      	cbz	r1, 994 <USART_print+0x18>
void USART_print(uint8_t *data, uint32_t size){
     97e:	b570      	push	{r4, r5, r6, lr}
     980:	4604      	mov	r4, r0
     982:	460d      	mov	r5, r1
     984:	4405      	add	r5, r0
			USART_write_char(*data);
     986:	4e04      	ldr	r6, [pc, #16]	; (998 <USART_print+0x1c>)
     988:	f814 0b01 	ldrb.w	r0, [r4], #1
     98c:	47b0      	blx	r6
	for (uint32_t i = 0; i < size; i++) { //data
     98e:	42a5      	cmp	r5, r4
     990:	d1fa      	bne.n	988 <USART_print+0xc>
     992:	bd70      	pop	{r4, r5, r6, pc}
     994:	4770      	bx	lr
     996:	bf00      	nop
     998:	00000961 	.word	0x00000961

0000099c <USART_newline>:
void USART_newline(){
     99c:	b510      	push	{r4, lr}
	USART_write_char(10); //line feed
     99e:	200a      	movs	r0, #10
     9a0:	4c02      	ldr	r4, [pc, #8]	; (9ac <USART_newline+0x10>)
     9a2:	47a0      	blx	r4
	USART_write_char(13); //carriage return
     9a4:	200d      	movs	r0, #13
     9a6:	47a0      	blx	r4
     9a8:	bd10      	pop	{r4, pc}
     9aa:	bf00      	nop
     9ac:	00000961 	.word	0x00000961

000009b0 <set_baudrate>:
}

void set_baudrate(uint32_t rate){
     9b0:	b538      	push	{r3, r4, r5, lr}
     9b2:	4604      	mov	r4, r0
		//		-over = oversampling mode (8 or 16)
		//      -cd = clock divider
		//      -see page 587
		uint8_t oversamp;
		//calculate CD
		USART1->bf.MR.USART.OVER = 1;
     9b4:	4b0e      	ldr	r3, [pc, #56]	; (9f0 <set_baudrate+0x40>)
     9b6:	685a      	ldr	r2, [r3, #4]
     9b8:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
     9bc:	605a      	str	r2, [r3, #4]
		if (!USART1->bf.MR.USART.OVER){oversamp = 16;}
     9be:	685b      	ldr	r3, [r3, #4]
     9c0:	f3c3 43c0 	ubfx	r3, r3, #19, #1
		else{oversamp = 8;}
     9c4:	2b00      	cmp	r3, #0
     9c6:	bf0c      	ite	eq
     9c8:	2510      	moveq	r5, #16
     9ca:	2508      	movne	r5, #8
		
		uint32_t clk = clock_speed();
     9cc:	4b09      	ldr	r3, [pc, #36]	; (9f4 <set_baudrate+0x44>)
     9ce:	4798      	blx	r3
		uint16_t cd = clk/(rate*oversamp);
     9d0:	fb04 f405 	mul.w	r4, r4, r5
     9d4:	fbb0 f4f4 	udiv	r4, r0, r4
     9d8:	b2a4      	uxth	r4, r4
		if (cd == 0){throw_error();}
     9da:	b12c      	cbz	r4, 9e8 <set_baudrate+0x38>
		USART1->bf.BRGR.bit.CD = cd;
     9dc:	4b04      	ldr	r3, [pc, #16]	; (9f0 <set_baudrate+0x40>)
     9de:	6a1a      	ldr	r2, [r3, #32]
     9e0:	f364 020f 	bfi	r2, r4, #0, #16
     9e4:	621a      	str	r2, [r3, #32]
     9e6:	bd38      	pop	{r3, r4, r5, pc}
		if (cd == 0){throw_error();}
     9e8:	4b03      	ldr	r3, [pc, #12]	; (9f8 <set_baudrate+0x48>)
     9ea:	4798      	blx	r3
     9ec:	e7f6      	b.n	9dc <set_baudrate+0x2c>
     9ee:	bf00      	nop
     9f0:	40028000 	.word	0x40028000
     9f4:	00000b81 	.word	0x00000b81
     9f8:	00000b49 	.word	0x00000b49

000009fc <USART_init>:
void USART_init(TX, RX){
     9fc:	b508      	push	{r3, lr}
	GPIO->bf.Port[2].bf.GPERC.reg = TX | RX;
     9fe:	4301      	orrs	r1, r0
     a00:	4b13      	ldr	r3, [pc, #76]	; (a50 <USART_init+0x54>)
     a02:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
	GPIO->bf.Port[2].bf.PMR0C.reg = TX | RX;
     a06:	f8c3 1418 	str.w	r1, [r3, #1048]	; 0x418
	GPIO->bf.Port[2].bf.PMR1C.reg = TX | RX;
     a0a:	f8c3 1428 	str.w	r1, [r3, #1064]	; 0x428
	GPIO->bf.Port[2].bf.PMR2C.reg = TX | RX;
     a0e:	f8c3 1438 	str.w	r1, [r3, #1080]	; 0x438
	PM->bf.UNLOCK.reg = ADDR_UNLOCK(PM_PBAMASK_OFFSET);	// Unlock PBA Register
     a12:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     a16:	4a0f      	ldr	r2, [pc, #60]	; (a54 <USART_init+0x58>)
     a18:	659a      	str	r2, [r3, #88]	; 0x58
	PM->bf.PBAMASK.reg |= (uint32_t)(0x1ul << PM_PBAMASK_USART1_Pos);	// Enable clock for USART
     a1a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     a1c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
     a20:	629a      	str	r2, [r3, #40]	; 0x28
	set_baudrate(115000);
     a22:	480d      	ldr	r0, [pc, #52]	; (a58 <USART_init+0x5c>)
     a24:	4b0d      	ldr	r3, [pc, #52]	; (a5c <USART_init+0x60>)
     a26:	4798      	blx	r3
	USART1->bf.MR.USART.CHRL = 0b11; //8bit
     a28:	4b0d      	ldr	r3, [pc, #52]	; (a60 <USART_init+0x64>)
     a2a:	685a      	ldr	r2, [r3, #4]
     a2c:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
     a30:	605a      	str	r2, [r3, #4]
	USART1->bf.CR.USART.RSTTX = 1; //reset transmitter
     a32:	681a      	ldr	r2, [r3, #0]
     a34:	f042 0208 	orr.w	r2, r2, #8
     a38:	601a      	str	r2, [r3, #0]
	USART1->bf.CR.USART.TXEN = 1;
     a3a:	681a      	ldr	r2, [r3, #0]
     a3c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
     a40:	601a      	str	r2, [r3, #0]
	while (!USART1->bf.CSR.USART.TXRDY);
     a42:	461a      	mov	r2, r3
     a44:	6953      	ldr	r3, [r2, #20]
     a46:	f013 0f02 	tst.w	r3, #2
     a4a:	d0fb      	beq.n	a44 <USART_init+0x48>
}
     a4c:	bd08      	pop	{r3, pc}
     a4e:	bf00      	nop
     a50:	400e1000 	.word	0x400e1000
     a54:	aa000028 	.word	0xaa000028
     a58:	0001c138 	.word	0x0001c138
     a5c:	000009b1 	.word	0x000009b1
     a60:	40028000 	.word	0x40028000

00000a64 <USART_printf>:
}


//adapted code to mimic printf function on serial terminal
void  USART_printf (char * str, ...){
     a64:	b40f      	push	{r0, r1, r2, r3}
     a66:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     a6a:	b0a1      	sub	sp, #132	; 0x84
     a6c:	ac28      	add	r4, sp, #160	; 0xa0
     a6e:	f854 6b04 	ldr.w	r6, [r4], #4
	va_list arg_list;
	int i = 0, j=0;
	char buff[100]={0}, tmp[20];
     a72:	2264      	movs	r2, #100	; 0x64
     a74:	2100      	movs	r1, #0
     a76:	a806      	add	r0, sp, #24
     a78:	4b2e      	ldr	r3, [pc, #184]	; (b34 <USART_printf+0xd0>)
     a7a:	4798      	blx	r3
	va_start( arg_list, str );
     a7c:	941f      	str	r4, [sp, #124]	; 0x7c

	while (str && str[i]){
     a7e:	2e00      	cmp	r6, #0
     a80:	d04f      	beq.n	b22 <USART_printf+0xbe>
     a82:	7833      	ldrb	r3, [r6, #0]
     a84:	2b00      	cmp	r3, #0
     a86:	d04c      	beq.n	b22 <USART_printf+0xbe>
     a88:	2500      	movs	r5, #0
     a8a:	462c      	mov	r4, r5
					strcpy(&buff[j], tmp);
					j += strlen(tmp);
					break;
				}
				case 'x': {
					itoa(va_arg( arg_list, int ), tmp, 16);
     a8c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; b40 <USART_printf+0xdc>
					strcpy(&buff[j], tmp);
     a90:	f8df 80b0 	ldr.w	r8, [pc, #176]	; b44 <USART_printf+0xe0>
					j += strlen(tmp);
     a94:	4f28      	ldr	r7, [pc, #160]	; (b38 <USART_printf+0xd4>)
     a96:	e01d      	b.n	ad4 <USART_printf+0x70>
			i++;
     a98:	3401      	adds	r4, #1
			switch (str[i]) {
     a9a:	5d33      	ldrb	r3, [r6, r4]
     a9c:	3b63      	subs	r3, #99	; 0x63
     a9e:	2b15      	cmp	r3, #21
     aa0:	d815      	bhi.n	ace <USART_printf+0x6a>
     aa2:	e8df f003 	tbb	[pc, r3]
     aa6:	1f0b      	.short	0x1f0b
     aa8:	14143d14 	.word	0x14143d14
     aac:	14141414 	.word	0x14141414
     ab0:	14141414 	.word	0x14141414
     ab4:	14141414 	.word	0x14141414
     ab8:	2e141414 	.word	0x2e141414
					buff[j] = (char)va_arg( arg_list, int );
     abc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     abe:	1d1a      	adds	r2, r3, #4
     ac0:	921f      	str	r2, [sp, #124]	; 0x7c
     ac2:	aa20      	add	r2, sp, #128	; 0x80
     ac4:	442a      	add	r2, r5
     ac6:	681b      	ldr	r3, [r3, #0]
     ac8:	f802 3c68 	strb.w	r3, [r2, #-104]
					j++;
     acc:	3501      	adds	r5, #1
			}
			} else {
			buff[j] =str[i];
			j++;
		}
		i++;
     ace:	3401      	adds	r4, #1
	while (str && str[i]){
     ad0:	5d33      	ldrb	r3, [r6, r4]
     ad2:	b333      	cbz	r3, b22 <USART_printf+0xbe>
		if(str[i] == '%'){
     ad4:	2b25      	cmp	r3, #37	; 0x25
     ad6:	d0df      	beq.n	a98 <USART_printf+0x34>
			buff[j] =str[i];
     ad8:	aa20      	add	r2, sp, #128	; 0x80
     ada:	442a      	add	r2, r5
     adc:	f802 3c68 	strb.w	r3, [r2, #-104]
			j++;
     ae0:	3501      	adds	r5, #1
     ae2:	e7f4      	b.n	ace <USART_printf+0x6a>
					itoa(va_arg( arg_list, int ), tmp, 10);
     ae4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     ae6:	1d1a      	adds	r2, r3, #4
     ae8:	921f      	str	r2, [sp, #124]	; 0x7c
     aea:	220a      	movs	r2, #10
     aec:	a901      	add	r1, sp, #4
     aee:	6818      	ldr	r0, [r3, #0]
     af0:	47c8      	blx	r9
					strcpy(&buff[j], tmp);
     af2:	a901      	add	r1, sp, #4
     af4:	ab06      	add	r3, sp, #24
     af6:	1958      	adds	r0, r3, r5
     af8:	47c0      	blx	r8
					j += strlen(tmp);
     afa:	a801      	add	r0, sp, #4
     afc:	47b8      	blx	r7
     afe:	4405      	add	r5, r0
					break;
     b00:	e7e5      	b.n	ace <USART_printf+0x6a>
					itoa(va_arg( arg_list, int ), tmp, 16);
     b02:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     b04:	1d1a      	adds	r2, r3, #4
     b06:	921f      	str	r2, [sp, #124]	; 0x7c
     b08:	2210      	movs	r2, #16
     b0a:	a901      	add	r1, sp, #4
     b0c:	6818      	ldr	r0, [r3, #0]
     b0e:	47c8      	blx	r9
					strcpy(&buff[j], tmp);
     b10:	a901      	add	r1, sp, #4
     b12:	ab06      	add	r3, sp, #24
     b14:	1958      	adds	r0, r3, r5
     b16:	47c0      	blx	r8
					j += strlen(tmp);
     b18:	a801      	add	r0, sp, #4
     b1a:	47b8      	blx	r7
     b1c:	4405      	add	r5, r0
					break;
     b1e:	e7d6      	b.n	ace <USART_printf+0x6a>
     b20:	deff      	udf	#255	; 0xff
	}
	//fwrite(buff, j, 1, stdout);
	USART_print(buff, sizeof(buff));
     b22:	2164      	movs	r1, #100	; 0x64
     b24:	a806      	add	r0, sp, #24
     b26:	4b05      	ldr	r3, [pc, #20]	; (b3c <USART_printf+0xd8>)
     b28:	4798      	blx	r3
	va_end(arg_list);
}
     b2a:	b021      	add	sp, #132	; 0x84
     b2c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
     b30:	b004      	add	sp, #16
     b32:	4770      	bx	lr
     b34:	00003a71 	.word	0x00003a71
     b38:	00003c01 	.word	0x00003c01
     b3c:	0000097d 	.word	0x0000097d
     b40:	00003939 	.word	0x00003939
     b44:	00003b0d 	.word	0x00003b0d

00000b48 <throw_error>:

void Assert(bool expr){
	if (!(expr)) throw_error();
}

void throw_error(){
     b48:	b580      	push	{r7, lr}
	//blinks to indicate and issue
	//enable GPIO PC7
	GPIO->bf.Port[2].bf.GPERS.reg = 0x00000080;
     b4a:	4b0b      	ldr	r3, [pc, #44]	; (b78 <throw_error+0x30>)
     b4c:	2280      	movs	r2, #128	; 0x80
     b4e:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
	//set PC7 as output
	GPIO->bf.Port[2].bf.ODERS.reg = GPIO_ODER_P7;
     b52:	f8c3 2444 	str.w	r2, [r3, #1092]	; 0x444
	while (1)
	{
		//turn on
		GPIO->bf.Port[2].bf.OVRC.reg = GPIO_OVRC_P7;
     b56:	461d      	mov	r5, r3
     b58:	4616      	mov	r6, r2
     b5a:	4617      	mov	r7, r2
     b5c:	f8c5 7458 	str.w	r7, [r5, #1112]	; 0x458
		delay_ms_2(1000);
     b60:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     b64:	2100      	movs	r1, #0
     b66:	4c05      	ldr	r4, [pc, #20]	; (b7c <throw_error+0x34>)
     b68:	47a0      	blx	r4
		//delay_2(5000);
		//turn off
		GPIO->bf.Port[2].bf.OVRS.reg = GPIO_OVRS_P7;
     b6a:	f8c5 6454 	str.w	r6, [r5, #1108]	; 0x454
		delay_ms_2(1000);
     b6e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     b72:	2100      	movs	r1, #0
     b74:	47a0      	blx	r4
     b76:	e7f1      	b.n	b5c <throw_error+0x14>
     b78:	400e1000 	.word	0x400e1000
     b7c:	00000c05 	.word	0x00000c05

00000b80 <clock_speed>:
uint32_t clock_speed(){
     b80:	b508      	push	{r3, lr}
	switch((uint8_t)PM->bf.MCCTRL.bit.MCSEL) {
     b82:	4b17      	ldr	r3, [pc, #92]	; (be0 <clock_speed+0x60>)
     b84:	681b      	ldr	r3, [r3, #0]
     b86:	f003 0307 	and.w	r3, r3, #7
     b8a:	2b06      	cmp	r3, #6
     b8c:	d81f      	bhi.n	bce <clock_speed+0x4e>
     b8e:	e8df f003 	tbb	[pc, r3]
     b92:	0620      	.short	0x0620
     b94:	08041e1e 	.word	0x08041e1e
     b98:	22          	.byte	0x22
     b99:	00          	.byte	0x00
		return(80000000);
     b9a:	4812      	ldr	r0, [pc, #72]	; (be4 <clock_speed+0x64>)
     b9c:	bd08      	pop	{r3, pc}
		throw_error();
     b9e:	4b12      	ldr	r3, [pc, #72]	; (be8 <clock_speed+0x68>)
     ba0:	4798      	blx	r3
		if (SCIF->bf.RCFASTCFG.bit.EN == 1){
     ba2:	4b12      	ldr	r3, [pc, #72]	; (bec <clock_speed+0x6c>)
     ba4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     ba6:	f013 0f01 	tst.w	r3, #1
     baa:	d00e      	beq.n	bca <clock_speed+0x4a>
			switch((uint8_t)SCIF->bf.RCFASTCFG.bit.FRANGE){
     bac:	4b0f      	ldr	r3, [pc, #60]	; (bec <clock_speed+0x6c>)
     bae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     bb0:	f3c3 2301 	ubfx	r3, r3, #8, #2
     bb4:	2b01      	cmp	r3, #1
     bb6:	d006      	beq.n	bc6 <clock_speed+0x46>
     bb8:	b17b      	cbz	r3, bda <clock_speed+0x5a>
		return(1000000);
     bba:	4a0d      	ldr	r2, [pc, #52]	; (bf0 <clock_speed+0x70>)
     bbc:	480d      	ldr	r0, [pc, #52]	; (bf4 <clock_speed+0x74>)
     bbe:	2b02      	cmp	r3, #2
     bc0:	bf18      	it	ne
     bc2:	4610      	movne	r0, r2
     bc4:	bd08      	pop	{r3, pc}
				case 1 : return(8000000);
     bc6:	480c      	ldr	r0, [pc, #48]	; (bf8 <clock_speed+0x78>)
     bc8:	bd08      	pop	{r3, pc}
			throw_error();
     bca:	4b07      	ldr	r3, [pc, #28]	; (be8 <clock_speed+0x68>)
     bcc:	4798      	blx	r3
		throw_error();
     bce:	4b06      	ldr	r3, [pc, #24]	; (be8 <clock_speed+0x68>)
     bd0:	4798      	blx	r3
		return(115000);
     bd2:	480a      	ldr	r0, [pc, #40]	; (bfc <clock_speed+0x7c>)
     bd4:	bd08      	pop	{r3, pc}
		return(1000000);
     bd6:	4806      	ldr	r0, [pc, #24]	; (bf0 <clock_speed+0x70>)
     bd8:	bd08      	pop	{r3, pc}
				case 0 : return(4000000);
     bda:	4809      	ldr	r0, [pc, #36]	; (c00 <clock_speed+0x80>)
}
     bdc:	bd08      	pop	{r3, pc}
     bde:	bf00      	nop
     be0:	400e0000 	.word	0x400e0000
     be4:	04c4b400 	.word	0x04c4b400
     be8:	00000b49 	.word	0x00000b49
     bec:	400e0800 	.word	0x400e0800
     bf0:	000f4240 	.word	0x000f4240
     bf4:	00b71b00 	.word	0x00b71b00
     bf8:	007a1200 	.word	0x007a1200
     bfc:	0001c138 	.word	0x0001c138
     c00:	003d0900 	.word	0x003d0900

00000c04 <delay_ms_2>:
void delay_ms_2(uint64_t ms){
     c04:	b570      	push	{r4, r5, r6, lr}
     c06:	4604      	mov	r4, r0
     c08:	460e      	mov	r6, r1
	delay_cycles(((uint64_t)(ms) * clock_speed() + (uint64_t)(14e3 - 1ul)) / (uint64_t)14e3);
     c0a:	4b09      	ldr	r3, [pc, #36]	; (c30 <delay_ms_2+0x2c>)
     c0c:	4798      	blx	r3
     c0e:	fba0 4504 	umull	r4, r5, r0, r4
     c12:	fb00 5506 	mla	r5, r0, r6, r5
     c16:	f243 62b0 	movw	r2, #14000	; 0x36b0
     c1a:	2300      	movs	r3, #0
     c1c:	f243 60af 	movw	r0, #13999	; 0x36af
     c20:	2100      	movs	r1, #0
     c22:	1900      	adds	r0, r0, r4
     c24:	4169      	adcs	r1, r5
     c26:	4c03      	ldr	r4, [pc, #12]	; (c34 <delay_ms_2+0x30>)
     c28:	47a0      	blx	r4
     c2a:	4b03      	ldr	r3, [pc, #12]	; (c38 <delay_ms_2+0x34>)
     c2c:	4798      	blx	r3
     c2e:	bd70      	pop	{r4, r5, r6, pc}
     c30:	00000b81 	.word	0x00000b81
     c34:	000035a9 	.word	0x000035a9
     c38:	20000001 	.word	0x20000001

00000c3c <RCFAST_init>:
	}
}

void RCFAST_init(){
	//Enable SCIF, which controls oscillators/clocks.
	SCIF->bf.UNLOCK.reg = 0xAA000000 | SCIF_RCFASTCFG_OFFSET; //unlock RCFASTCFG
     c3c:	4b09      	ldr	r3, [pc, #36]	; (c64 <RCFAST_init+0x28>)
     c3e:	4a0a      	ldr	r2, [pc, #40]	; (c68 <RCFAST_init+0x2c>)
     c40:	619a      	str	r2, [r3, #24]
	SCIF->bf.RCFASTCFG.bit.EN = 1; // Enable RCFAST
     c42:	6c9a      	ldr	r2, [r3, #72]	; 0x48
     c44:	f042 0201 	orr.w	r2, r2, #1
     c48:	649a      	str	r2, [r3, #72]	; 0x48
	while (SCIF->bf.RCFASTCFG.bit.EN != 1); // wait for it to turn on
     c4a:	461a      	mov	r2, r3
     c4c:	6c93      	ldr	r3, [r2, #72]	; 0x48
     c4e:	f013 0f01 	tst.w	r3, #1
     c52:	d0fb      	beq.n	c4c <RCFAST_init+0x10>
	//set RCFAST as system clock
	PM->bf.UNLOCK.reg =  0xAA000000 | PM_MCCTRL_OFFSET;
     c54:	4b05      	ldr	r3, [pc, #20]	; (c6c <RCFAST_init+0x30>)
     c56:	f04f 422a 	mov.w	r2, #2852126720	; 0xaa000000
     c5a:	659a      	str	r2, [r3, #88]	; 0x58
	PM->bf.MCCTRL.reg = 0x00000005;
     c5c:	2205      	movs	r2, #5
     c5e:	601a      	str	r2, [r3, #0]
     c60:	4770      	bx	lr
     c62:	bf00      	nop
     c64:	400e0800 	.word	0x400e0800
     c68:	aa000048 	.word	0xaa000048
     c6c:	400e0000 	.word	0x400e0000

00000c70 <get_temp_12bit>:
//08-2019

#include "AT30TSE758A_Temp.h"
#include "AK_I2C.h"

uint16_t get_temp_12bit(uint8_t address){
     c70:	b500      	push	{lr}
     c72:	b083      	sub	sp, #12
	uint8_t data_read [2];
	I2C_read_bytes(address, data_read, sizeof(data_read));
     c74:	2202      	movs	r2, #2
     c76:	a901      	add	r1, sp, #4
     c78:	4b05      	ldr	r3, [pc, #20]	; (c90 <get_temp_12bit+0x20>)
     c7a:	4798      	blx	r3
	uint16_t raw_temp = data_read[0] << 4 | data_read[1] >> 4; //ignore bottom 4 bits
     c7c:	f89d 0004 	ldrb.w	r0, [sp, #4]
     c80:	f89d 3005 	ldrb.w	r3, [sp, #5]
     c84:	091b      	lsrs	r3, r3, #4
	return raw_temp;
}
     c86:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
     c8a:	b003      	add	sp, #12
     c8c:	f85d fb04 	ldr.w	pc, [sp], #4
     c90:	000001ed 	.word	0x000001ed

00000c94 <set_config_register>:

void set_config_register(uint8_t address, uint8_t config_val){
     c94:	b570      	push	{r4, r5, r6, lr}
     c96:	b082      	sub	sp, #8
     c98:	4606      	mov	r6, r0
	uint8_t data_to_send[2];// = {0x01, config_val};
	data_to_send[0] = 0x01; //pointer to configuration Register
     c9a:	2501      	movs	r5, #1
     c9c:	f88d 5004 	strb.w	r5, [sp, #4]
	data_to_send[1] = config_val; 
     ca0:	f88d 1005 	strb.w	r1, [sp, #5]
	I2C_write_bytes(address, data_to_send, sizeof(data_to_send)); //data to send is already pointer (because it is an array), so no & needed
     ca4:	2202      	movs	r2, #2
     ca6:	a901      	add	r1, sp, #4
     ca8:	4c05      	ldr	r4, [pc, #20]	; (cc0 <set_config_register+0x2c>)
     caa:	47a0      	blx	r4
	
	//now set pointer back to temp register
	uint8_t pointer = 0x00; //pointer to temp register
     cac:	a902      	add	r1, sp, #8
     cae:	2300      	movs	r3, #0
     cb0:	f801 3d05 	strb.w	r3, [r1, #-5]!
	I2C_write_bytes(address, &pointer, 1);
     cb4:	462a      	mov	r2, r5
     cb6:	4630      	mov	r0, r6
     cb8:	47a0      	blx	r4
}
     cba:	b002      	add	sp, #8
     cbc:	bd70      	pop	{r4, r5, r6, pc}
     cbe:	bf00      	nop
     cc0:	00000235 	.word	0x00000235

00000cc4 <Dummy_Handler>:
     cc4:	e7fe      	b.n	cc4 <Dummy_Handler>
	...

00000cc8 <Reset_Handler>:
     cc8:	b508      	push	{r3, lr}
     cca:	4b17      	ldr	r3, [pc, #92]	; (d28 <Reset_Handler+0x60>)
     ccc:	4a17      	ldr	r2, [pc, #92]	; (d2c <Reset_Handler+0x64>)
     cce:	429a      	cmp	r2, r3
     cd0:	d010      	beq.n	cf4 <Reset_Handler+0x2c>
     cd2:	4b17      	ldr	r3, [pc, #92]	; (d30 <Reset_Handler+0x68>)
     cd4:	4a14      	ldr	r2, [pc, #80]	; (d28 <Reset_Handler+0x60>)
     cd6:	429a      	cmp	r2, r3
     cd8:	d20c      	bcs.n	cf4 <Reset_Handler+0x2c>
     cda:	3b01      	subs	r3, #1
     cdc:	1a9b      	subs	r3, r3, r2
     cde:	f023 0303 	bic.w	r3, r3, #3
     ce2:	3304      	adds	r3, #4
     ce4:	4413      	add	r3, r2
     ce6:	4911      	ldr	r1, [pc, #68]	; (d2c <Reset_Handler+0x64>)
     ce8:	f851 0b04 	ldr.w	r0, [r1], #4
     cec:	f842 0b04 	str.w	r0, [r2], #4
     cf0:	429a      	cmp	r2, r3
     cf2:	d1f9      	bne.n	ce8 <Reset_Handler+0x20>
     cf4:	4b0f      	ldr	r3, [pc, #60]	; (d34 <Reset_Handler+0x6c>)
     cf6:	4a10      	ldr	r2, [pc, #64]	; (d38 <Reset_Handler+0x70>)
     cf8:	429a      	cmp	r2, r3
     cfa:	d20a      	bcs.n	d12 <Reset_Handler+0x4a>
     cfc:	3b01      	subs	r3, #1
     cfe:	1a9b      	subs	r3, r3, r2
     d00:	f023 0303 	bic.w	r3, r3, #3
     d04:	3304      	adds	r3, #4
     d06:	4413      	add	r3, r2
     d08:	2100      	movs	r1, #0
     d0a:	f842 1b04 	str.w	r1, [r2], #4
     d0e:	4293      	cmp	r3, r2
     d10:	d1fb      	bne.n	d0a <Reset_Handler+0x42>
     d12:	4a0a      	ldr	r2, [pc, #40]	; (d3c <Reset_Handler+0x74>)
     d14:	4b0a      	ldr	r3, [pc, #40]	; (d40 <Reset_Handler+0x78>)
     d16:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
     d1a:	6093      	str	r3, [r2, #8]
     d1c:	4b09      	ldr	r3, [pc, #36]	; (d44 <Reset_Handler+0x7c>)
     d1e:	4798      	blx	r3
     d20:	4b09      	ldr	r3, [pc, #36]	; (d48 <Reset_Handler+0x80>)
     d22:	4798      	blx	r3
     d24:	e7fe      	b.n	d24 <Reset_Handler+0x5c>
     d26:	bf00      	nop
     d28:	20000000 	.word	0x20000000
     d2c:	0000404c 	.word	0x0000404c
     d30:	2000044c 	.word	0x2000044c
     d34:	200011e8 	.word	0x200011e8
     d38:	2000044c 	.word	0x2000044c
     d3c:	e000ed00 	.word	0xe000ed00
     d40:	00000000 	.word	0x00000000
     d44:	000038b9 	.word	0x000038b9
     d48:	00002e89 	.word	0x00002e89

00000d4c <SystemInit>:
     d4c:	4a01      	ldr	r2, [pc, #4]	; (d54 <SystemInit+0x8>)
     d4e:	4b02      	ldr	r3, [pc, #8]	; (d58 <SystemInit+0xc>)
     d50:	601a      	str	r2, [r3, #0]
     d52:	4770      	bx	lr
     d54:	0001c138 	.word	0x0001c138
     d58:	2000000c 	.word	0x2000000c

00000d5c <fatfs_init>:

//-----------------------------------------------------------------------------
// fatfs_init: Load FAT Parameters
//-----------------------------------------------------------------------------
int fatfs_init(struct fatfs *fs)
{
     d5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     d60:	4604      	mov	r4, r0
    uint32 total_sectors;
    uint32 data_sectors;
    uint32 count_of_clusters;
    uint8 valid_partition = 0;

    fs->currentsector.address = FAT32_INVALID_CLUSTER;
     d62:	f04f 33ff 	mov.w	r3, #4294967295
     d66:	f8c0 3240 	str.w	r3, [r0, #576]	; 0x240
    fs->currentsector.dirty = 0;
     d6a:	2300      	movs	r3, #0
     d6c:	f8c0 3244 	str.w	r3, [r0, #580]	; 0x244

    fs->next_free_cluster = 0; // Invalid
     d70:	6243      	str	r3, [r0, #36]	; 0x24

    fatfs_fat_init(fs);
     d72:	4b98      	ldr	r3, [pc, #608]	; (fd4 <fatfs_init+0x278>)
     d74:	4798      	blx	r3

    // Make sure we have a read function (write function is optional)
    if (!fs->disk_io.read_media)
     d76:	6b23      	ldr	r3, [r4, #48]	; 0x30
     d78:	2b00      	cmp	r3, #0
     d7a:	f000 8107 	beq.w	f8c <fatfs_init+0x230>

    // MBR: Sector 0 on the disk
    // NOTE: Some removeable media does not have this.

    // Load MBR (LBA 0) into the 512 byte buffer
    if (!fs->disk_io.read_media(0, fs->currentsector.sector, 1))
     d7e:	f104 0540 	add.w	r5, r4, #64	; 0x40
     d82:	2201      	movs	r2, #1
     d84:	4629      	mov	r1, r5
     d86:	2000      	movs	r0, #0
     d88:	4798      	blx	r3
     d8a:	2800      	cmp	r0, #0
     d8c:	f000 8102 	beq.w	f94 <fatfs_init+0x238>
        return FAT_INIT_MEDIA_ACCESS_ERROR;

    // Make Sure 0x55 and 0xAA are at end of sector
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
     d90:	f8b4 223e 	ldrh.w	r2, [r4, #574]	; 0x23e
     d94:	f64a 2355 	movw	r3, #43605	; 0xaa55
     d98:	429a      	cmp	r2, r3
     d9a:	f040 80ff 	bne.w	f9c <fatfs_init+0x240>
        return FAT_INIT_INVALID_SIGNATURE;

    // Now check again using the access function to prove endian conversion function
    if (GET_16BIT_WORD(fs->currentsector.sector, SIGNATURE_POSITION) != SIGNATURE_VALUE)
     d9e:	f894 223f 	ldrb.w	r2, [r4, #575]	; 0x23f
     da2:	f894 323e 	ldrb.w	r3, [r4, #574]	; 0x23e
     da6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
     daa:	f64a 2255 	movw	r2, #43605	; 0xaa55
     dae:	4293      	cmp	r3, r2
     db0:	f040 80f8 	bne.w	fa4 <fatfs_init+0x248>
    // Verify packed structures
    if (sizeof(struct fat_dir_entry) != FAT_DIR_ENTRY_SIZE)
        return FAT_INIT_STRUCT_PACKING;

    // Check the partition type code
    switch(fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION])
     db4:	f894 3202 	ldrb.w	r3, [r4, #514]	; 0x202
     db8:	2b0f      	cmp	r3, #15
     dba:	d809      	bhi.n	dd0 <fatfs_init+0x74>
     dbc:	e8df f003 	tbb	[pc, r3]
     dc0:	080808be 	.word	0x080808be
     dc4:	080d0d08 	.word	0x080d0d08
     dc8:	0d080808 	.word	0x0d080808
     dcc:	0d0d080d 	.word	0x0d0d080d
        case 0x06:
        case 0x0C:
        case 0x0E:
        case 0x0F:
        case 0x05:
            valid_partition = 1;
     dd0:	2b06      	cmp	r3, #6
     dd2:	bf8c      	ite	hi
     dd4:	2300      	movhi	r3, #0
     dd6:	2301      	movls	r3, #1
     dd8:	e000      	b.n	ddc <fatfs_init+0x80>
     dda:	2301      	movs	r3, #1
                valid_partition = 1;
        break;
    }

    // Read LBA Begin for the file system
    if (valid_partition)
     ddc:	2b00      	cmp	r3, #0
     dde:	f000 80ad 	beq.w	f3c <fatfs_init+0x1e0>
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
     de2:	f894 2209 	ldrb.w	r2, [r4, #521]	; 0x209
     de6:	f894 3208 	ldrb.w	r3, [r4, #520]	; 0x208
     dea:	041b      	lsls	r3, r3, #16
     dec:	eb03 6302 	add.w	r3, r3, r2, lsl #24
     df0:	f894 2206 	ldrb.w	r2, [r4, #518]	; 0x206
     df4:	4413      	add	r3, r2
     df6:	f894 2207 	ldrb.w	r2, [r4, #519]	; 0x207
     dfa:	eb03 2302 	add.w	r3, r3, r2, lsl #8
     dfe:	61e3      	str	r3, [r4, #28]
    else
        fs->lba_begin = 0;

    // Load Volume 1 table into sector buffer
    // (We may already have this in the buffer if MBR less drive!)
    if (!fs->disk_io.read_media(fs->lba_begin, fs->currentsector.sector, 1))
     e00:	6b23      	ldr	r3, [r4, #48]	; 0x30
     e02:	2201      	movs	r2, #1
     e04:	4629      	mov	r1, r5
     e06:	69e0      	ldr	r0, [r4, #28]
     e08:	4798      	blx	r3
     e0a:	2800      	cmp	r0, #0
     e0c:	f000 80ce 	beq.w	fac <fatfs_init+0x250>
        return FAT_INIT_MEDIA_ACCESS_ERROR;

    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE)
     e10:	f894 204c 	ldrb.w	r2, [r4, #76]	; 0x4c
     e14:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
     e18:	eb03 2302 	add.w	r3, r3, r2, lsl #8
     e1c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     e20:	f040 80c8 	bne.w	fb4 <fatfs_init+0x258>
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
     e24:	f894 004d 	ldrb.w	r0, [r4, #77]	; 0x4d
     e28:	7020      	strb	r0, [r4, #0]
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
     e2a:	f894 604f 	ldrb.w	r6, [r4, #79]	; 0x4f
     e2e:	f894 104e 	ldrb.w	r1, [r4, #78]	; 0x4e
     e32:	eb01 2c06 	add.w	ip, r1, r6, lsl #8
     e36:	fa1f fc8c 	uxth.w	ip, ip
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
     e3a:	f894 5050 	ldrb.w	r5, [r4, #80]	; 0x50
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
     e3e:	f894 8052 	ldrb.w	r8, [r4, #82]	; 0x52
     e42:	f894 2051 	ldrb.w	r2, [r4, #81]	; 0x51
     e46:	eb02 2e08 	add.w	lr, r2, r8, lsl #8
     e4a:	fa1f fe8e 	uxth.w	lr, lr
     e4e:	f8a4 e028 	strh.w	lr, [r4, #40]	; 0x28

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
     e52:	f894 7057 	ldrb.w	r7, [r4, #87]	; 0x57
     e56:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
     e5a:	eb13 2307 	adds.w	r3, r3, r7, lsl #8
     e5e:	d070      	beq.n	f42 <fatfs_init+0x1e6>
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
     e60:	6223      	str	r3, [r4, #32]
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);

    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
     e62:	f894 906f 	ldrb.w	r9, [r4, #111]	; 0x6f
     e66:	f894 706e 	ldrb.w	r7, [r4, #110]	; 0x6e
     e6a:	043f      	lsls	r7, r7, #16
     e6c:	eb07 6709 	add.w	r7, r7, r9, lsl #24
     e70:	f894 906c 	ldrb.w	r9, [r4, #108]	; 0x6c
     e74:	444f      	add	r7, r9
     e76:	f894 906d 	ldrb.w	r9, [r4, #109]	; 0x6d
     e7a:	eb07 2709 	add.w	r7, r7, r9, lsl #8
     e7e:	60a7      	str	r7, [r4, #8]
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
     e80:	f894 9071 	ldrb.w	r9, [r4, #113]	; 0x71
     e84:	f894 7070 	ldrb.w	r7, [r4, #112]	; 0x70
     e88:	eb07 2709 	add.w	r7, r7, r9, lsl #8
     e8c:	8327      	strh	r7, [r4, #24]

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
     e8e:	6a27      	ldr	r7, [r4, #32]
     e90:	fb07 f905 	mul.w	r9, r7, r5
     e94:	eb0c 0709 	add.w	r7, ip, r9
     e98:	60e7      	str	r7, [r4, #12]
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
     e9a:	ea4f 1e4e 	mov.w	lr, lr, lsl #5
     e9e:	f20e 1eff 	addw	lr, lr, #511	; 0x1ff
     ea2:	ea4f 276e 	mov.w	r7, lr, asr #9
     ea6:	6127      	str	r7, [r4, #16]

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
     ea8:	69e7      	ldr	r7, [r4, #28]
     eaa:	4467      	add	r7, ip
     eac:	6167      	str	r7, [r4, #20]

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
     eae:	444f      	add	r7, r9
     eb0:	6067      	str	r7, [r4, #4]

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
     eb2:	f894 e23f 	ldrb.w	lr, [r4, #575]	; 0x23f
     eb6:	f894 723e 	ldrb.w	r7, [r4, #574]	; 0x23e
     eba:	eb07 270e 	add.w	r7, r7, lr, lsl #8
     ebe:	f64a 2e55 	movw	lr, #43605	; 0xaa55
     ec2:	4577      	cmp	r7, lr
     ec4:	d17a      	bne.n	fbc <fatfs_init+0x260>
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
     ec6:	eb02 2208 	add.w	r2, r2, r8, lsl #8
     eca:	0152      	lsls	r2, r2, #5
     ecc:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
     ed0:	2a00      	cmp	r2, #0
     ed2:	bfb8      	it	lt
     ed4:	f202 12ff 	addwlt	r2, r2, #511	; 0x1ff
     ed8:	ea4f 2862 	mov.w	r8, r2, asr #9

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
     edc:	2b00      	cmp	r3, #0
     ede:	d040      	beq.n	f62 <fatfs_init+0x206>
        FATSz = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
     ee0:	461f      	mov	r7, r3
    else
        FATSz = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16) != 0)
     ee2:	f894 2054 	ldrb.w	r2, [r4, #84]	; 0x54
     ee6:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
     eea:	eb13 2302 	adds.w	r3, r3, r2, lsl #8
     eee:	d10d      	bne.n	f0c <fatfs_init+0x1b0>
        total_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16);
    else
        total_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_TOTSEC32);
     ef0:	f894 3063 	ldrb.w	r3, [r4, #99]	; 0x63
     ef4:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
     ef8:	0412      	lsls	r2, r2, #16
     efa:	eb02 6203 	add.w	r2, r2, r3, lsl #24
     efe:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
     f02:	441a      	add	r2, r3
     f04:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
     f08:	eb02 2303 	add.w	r3, r2, r3, lsl #8

    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);
     f0c:	eb01 2206 	add.w	r2, r1, r6, lsl #8
     f10:	4442      	add	r2, r8
     f12:	fb05 2207 	mla	r2, r5, r7, r2
     f16:	1a9b      	subs	r3, r3, r2

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
     f18:	2800      	cmp	r0, #0
     f1a:	d053      	beq.n	fc4 <fatfs_init+0x268>
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
     f1c:	fbb3 f3f0 	udiv	r3, r3, r0

        if(count_of_clusters < 4085)
     f20:	f640 72f4 	movw	r2, #4084	; 0xff4
     f24:	4293      	cmp	r3, r2
     f26:	d951      	bls.n	fcc <fatfs_init+0x270>
            // Volume is FAT12
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525)
     f28:	f64f 72f4 	movw	r2, #65524	; 0xfff4
     f2c:	4293      	cmp	r3, r2
     f2e:	d927      	bls.n	f80 <fatfs_init+0x224>
            return FAT_INIT_OK;
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
     f30:	2301      	movs	r3, #1
     f32:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
            return FAT_INIT_OK;
     f36:	2000      	movs	r0, #0
     f38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        fs->lba_begin = 0;
     f3c:	2300      	movs	r3, #0
     f3e:	61e3      	str	r3, [r4, #28]
     f40:	e75e      	b.n	e00 <fatfs_init+0xa4>
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
     f42:	f894 9067 	ldrb.w	r9, [r4, #103]	; 0x67
     f46:	f894 7066 	ldrb.w	r7, [r4, #102]	; 0x66
     f4a:	043f      	lsls	r7, r7, #16
     f4c:	eb07 6709 	add.w	r7, r7, r9, lsl #24
     f50:	f894 9064 	ldrb.w	r9, [r4, #100]	; 0x64
     f54:	444f      	add	r7, r9
     f56:	f894 9065 	ldrb.w	r9, [r4, #101]	; 0x65
     f5a:	eb07 2709 	add.w	r7, r7, r9, lsl #8
     f5e:	6227      	str	r7, [r4, #32]
     f60:	e77f      	b.n	e62 <fatfs_init+0x106>
        FATSz = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
     f62:	f894 7067 	ldrb.w	r7, [r4, #103]	; 0x67
     f66:	f894 3066 	ldrb.w	r3, [r4, #102]	; 0x66
     f6a:	041b      	lsls	r3, r3, #16
     f6c:	eb03 6307 	add.w	r3, r3, r7, lsl #24
     f70:	f894 7064 	ldrb.w	r7, [r4, #100]	; 0x64
     f74:	443b      	add	r3, r7
     f76:	f894 7065 	ldrb.w	r7, [r4, #101]	; 0x65
     f7a:	eb03 2707 	add.w	r7, r3, r7, lsl #8
     f7e:	e7b0      	b.n	ee2 <fatfs_init+0x186>
            fs->rootdir_first_cluster = 0;
     f80:	2000      	movs	r0, #0
     f82:	60a0      	str	r0, [r4, #8]
            fs->fat_type = FAT_TYPE_16;
     f84:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
            return FAT_INIT_OK;
     f88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_MEDIA_ACCESS_ERROR;
     f8c:	f04f 30ff 	mov.w	r0, #4294967295
     f90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_MEDIA_ACCESS_ERROR;
     f94:	f04f 30ff 	mov.w	r0, #4294967295
     f98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_INVALID_SIGNATURE;
     f9c:	f06f 0002 	mvn.w	r0, #2
     fa0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_ENDIAN_ERROR;
     fa4:	f06f 0003 	mvn.w	r0, #3
     fa8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_MEDIA_ACCESS_ERROR;
     fac:	f04f 30ff 	mov.w	r0, #4294967295
     fb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_INVALID_SECTOR_SIZE;
     fb4:	f06f 0001 	mvn.w	r0, #1
     fb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return FAT_INIT_INVALID_SIGNATURE;
     fbc:	f06f 0002 	mvn.w	r0, #2
     fc0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        }
    }
    else
        return FAT_INIT_WRONG_FILESYS_TYPE;
     fc4:	f06f 0004 	mvn.w	r0, #4
     fc8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            return FAT_INIT_WRONG_FILESYS_TYPE;
     fcc:	f06f 0004 	mvn.w	r0, #4
}
     fd0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     fd4:	000027bd 	.word	0x000027bd

00000fd8 <fatfs_lba_of_cluster>:
// fatfs_lba_of_cluster: This function converts a cluster number into a sector /
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
     fd8:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
     fdc:	b12b      	cbz	r3, fea <fatfs_lba_of_cluster+0x12>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
     fde:	3902      	subs	r1, #2
     fe0:	7803      	ldrb	r3, [r0, #0]
     fe2:	6840      	ldr	r0, [r0, #4]
     fe4:	fb03 0001 	mla	r0, r3, r1, r0
}
     fe8:	4770      	bx	lr
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
     fea:	3902      	subs	r1, #2
     fec:	7802      	ldrb	r2, [r0, #0]
     fee:	6843      	ldr	r3, [r0, #4]
     ff0:	fb02 3101 	mla	r1, r2, r1, r3
     ff4:	8d00      	ldrh	r0, [r0, #40]	; 0x28
     ff6:	0140      	lsls	r0, r0, #5
     ff8:	eb01 2060 	add.w	r0, r1, r0, asr #9
     ffc:	4770      	bx	lr

00000ffe <fatfs_sector_read>:
//-----------------------------------------------------------------------------
// fatfs_sector_read:
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
     ffe:	b538      	push	{r3, r4, r5, lr}
    1000:	460d      	mov	r5, r1
    1002:	4611      	mov	r1, r2
    return fs->disk_io.read_media(lba, target, count);
    1004:	6b04      	ldr	r4, [r0, #48]	; 0x30
    1006:	461a      	mov	r2, r3
    1008:	4628      	mov	r0, r5
    100a:	47a0      	blx	r4
}
    100c:	bd38      	pop	{r3, r4, r5, pc}

0000100e <fatfs_sector_write>:
//-----------------------------------------------------------------------------
// fatfs_sector_write:
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
    100e:	b538      	push	{r3, r4, r5, lr}
    1010:	460d      	mov	r5, r1
    1012:	4611      	mov	r1, r2
    return fs->disk_io.write_media(lba, target, count);
    1014:	6b44      	ldr	r4, [r0, #52]	; 0x34
    1016:	461a      	mov	r2, r3
    1018:	4628      	mov	r0, r5
    101a:	47a0      	blx	r4
}
    101c:	bd38      	pop	{r3, r4, r5, pc}
	...

00001020 <fatfs_sector_reader>:
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
    1020:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1024:	4605      	mov	r5, r0
    1026:	4698      	mov	r8, r3
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
    1028:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    102c:	b943      	cbnz	r3, 1040 <fatfs_sector_reader+0x20>
    102e:	b939      	cbnz	r1, 1040 <fatfs_sector_reader+0x20>
    {
        if (offset < fs->rootdir_sectors)
    1030:	6903      	ldr	r3, [r0, #16]
    1032:	4293      	cmp	r3, r2
    1034:	d92f      	bls.n	1096 <fatfs_sector_reader+0x76>
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
    1036:	69c3      	ldr	r3, [r0, #28]
    1038:	68c0      	ldr	r0, [r0, #12]
    103a:	4403      	add	r3, r0
    103c:	1898      	adds	r0, r3, r2
        if (offset < fs->rootdir_sectors)
    103e:	e014      	b.n	106a <fatfs_sector_reader+0x4a>
    {
        // Set start of cluster chain to initial value
        cluster_chain = start_cluster;

        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;
    1040:	7828      	ldrb	r0, [r5, #0]
    1042:	fbb2 f6f0 	udiv	r6, r2, r0
    1046:	fb00 2916 	mls	r9, r0, r6, r2
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
    104a:	b13e      	cbz	r6, 105c <fatfs_sector_reader+0x3c>
    104c:	2400      	movs	r4, #0
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
    104e:	4f16      	ldr	r7, [pc, #88]	; (10a8 <fatfs_sector_reader+0x88>)
    1050:	4628      	mov	r0, r5
    1052:	47b8      	blx	r7
    1054:	4601      	mov	r1, r0
        for (i=0; i<cluster_to_read; i++)
    1056:	3401      	adds	r4, #1
    1058:	42a6      	cmp	r6, r4
    105a:	d1f9      	bne.n	1050 <fatfs_sector_reader+0x30>

        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER)
    105c:	f1b1 3fff 	cmp.w	r1, #4294967295
    1060:	d01c      	beq.n	109c <fatfs_sector_reader+0x7c>
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
    1062:	4628      	mov	r0, r5
    1064:	4b11      	ldr	r3, [pc, #68]	; (10ac <fatfs_sector_reader+0x8c>)
    1066:	4798      	blx	r3
    1068:	4448      	add	r0, r9
    }

    // User provided target array
    if (target)
    106a:	f1b8 0f00 	cmp.w	r8, #0
    106e:	d005      	beq.n	107c <fatfs_sector_reader+0x5c>
        return fs->disk_io.read_media(lba, target, 1);
    1070:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    1072:	2201      	movs	r2, #1
    1074:	4641      	mov	r1, r8
    1076:	4798      	blx	r3
    1078:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
    107c:	f8d5 3240 	ldr.w	r3, [r5, #576]	; 0x240
    1080:	4298      	cmp	r0, r3
    1082:	d00e      	beq.n	10a2 <fatfs_sector_reader+0x82>
    {
        fs->currentsector.address = lba;
    1084:	f8c5 0240 	str.w	r0, [r5, #576]	; 0x240
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
    1088:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    108a:	2201      	movs	r2, #1
    108c:	f105 0140 	add.w	r1, r5, #64	; 0x40
    1090:	4798      	blx	r3
    1092:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            return 0;
    1096:	2000      	movs	r0, #0
    1098:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            return 0;
    109c:	2000      	movs	r0, #0
    109e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
    else
        return 1;
    10a2:	2001      	movs	r0, #1
}
    10a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    10a8:	00002829 	.word	0x00002829
    10ac:	00000fd9 	.word	0x00000fd9

000010b0 <fatfs_write_sector>:
// fatfs_write_sector: Write to the provided cluster and sector offset
// Returns True if success, returns False if not
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_write_sector(struct fatfs *fs, uint32 cluster, uint32 sector, uint8 *target)
{
    10b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // No write access?
    if (!fs->disk_io.write_media)
    10b2:	6b46      	ldr	r6, [r0, #52]	; 0x34
    10b4:	b36e      	cbz	r6, 1112 <fatfs_write_sector+0x62>
    10b6:	461f      	mov	r7, r3
    10b8:	4615      	mov	r5, r2
    10ba:	4604      	mov	r4, r0
        return 0;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && cluster == 0)
    10bc:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    10c0:	b99b      	cbnz	r3, 10ea <fatfs_write_sector+0x3a>
    10c2:	b991      	cbnz	r1, 10ea <fatfs_write_sector+0x3a>
    {
        uint32 lba;

        // In FAT16 we cannot extend the root dir!
        if (sector < fs->rootdir_sectors)
    10c4:	6903      	ldr	r3, [r0, #16]
    10c6:	4293      	cmp	r3, r2
    10c8:	d925      	bls.n	1116 <fatfs_write_sector+0x66>
            lba = fs->lba_begin + fs->rootdir_first_sector + sector;
    10ca:	69c0      	ldr	r0, [r0, #28]
    10cc:	68e3      	ldr	r3, [r4, #12]
    10ce:	4418      	add	r0, r3
    10d0:	4410      	add	r0, r2
        else
            return 0;

        // User target buffer passed in
        if (target)
    10d2:	b11f      	cbz	r7, 10dc <fatfs_write_sector+0x2c>
        {
            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
    10d4:	2201      	movs	r2, #1
    10d6:	4639      	mov	r1, r7
    10d8:	47b0      	blx	r6
    10da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = lba;
    10dc:	f8c4 0240 	str.w	r0, [r4, #576]	; 0x240

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
    10e0:	2201      	movs	r2, #1
    10e2:	f104 0140 	add.w	r1, r4, #64	; 0x40
    10e6:	47b0      	blx	r6
    10e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    // FAT16/32 Other
    else
    {
        // User target buffer passed in
        if (target)
    10ea:	b13f      	cbz	r7, 10fc <fatfs_write_sector+0x4c>
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;
    10ec:	4620      	mov	r0, r4
    10ee:	4b0b      	ldr	r3, [pc, #44]	; (111c <fatfs_write_sector+0x6c>)
    10f0:	4798      	blx	r3

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
    10f2:	2201      	movs	r2, #1
    10f4:	4639      	mov	r1, r7
    10f6:	4428      	add	r0, r5
    10f8:	47b0      	blx	r6
    10fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
    10fc:	4620      	mov	r0, r4
    10fe:	4b07      	ldr	r3, [pc, #28]	; (111c <fatfs_write_sector+0x6c>)
    1100:	4798      	blx	r3
    1102:	4428      	add	r0, r5
    1104:	f8c4 0240 	str.w	r0, [r4, #576]	; 0x240

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
    1108:	2201      	movs	r2, #1
    110a:	f104 0140 	add.w	r1, r4, #64	; 0x40
    110e:	47b0      	blx	r6
    1110:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
    1112:	2000      	movs	r0, #0
    1114:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return 0;
    1116:	2000      	movs	r0, #0
        }
    }
}
    1118:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    111a:	bf00      	nop
    111c:	00000fd9 	.word	0x00000fd9

00001120 <fatfs_get_root_cluster>:
//-----------------------------------------------------------------------------
uint32 fatfs_get_root_cluster(struct fatfs *fs)
{
    // NOTE: On FAT16 this will be 0 which has a special meaning...
    return fs->rootdir_first_cluster;
}
    1120:	6880      	ldr	r0, [r0, #8]
    1122:	4770      	bx	lr

00001124 <fatfs_get_file_entry>:
//-------------------------------------------------------------
// fatfs_get_file_entry: Find the file entry for a filename
//-------------------------------------------------------------
uint32 fatfs_get_file_entry(struct fatfs *fs, uint32 Cluster, char *name_to_find, struct fat_dir_entry *sfEntry)
{
    1124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1128:	b0cb      	sub	sp, #300	; 0x12c
    112a:	4682      	mov	sl, r0
    112c:	9102      	str	r1, [sp, #8]
    112e:	9201      	str	r2, [sp, #4]
    1130:	9303      	str	r3, [sp, #12]
    char short_filename[13];
    struct lfn_cache lfn;
    int dotRequired = 0;
    struct fat_dir_entry *directoryEntry;

    fatfs_lfn_cache_init(&lfn, 1);
    1132:	2101      	movs	r1, #1
    1134:	a804      	add	r0, sp, #16
    1136:	4b52      	ldr	r3, [pc, #328]	; (1280 <fatfs_get_file_entry+0x15c>)
    1138:	4798      	blx	r3
    113a:	f04f 0b00 	mov.w	fp, #0
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) )
    113e:	4f51      	ldr	r7, [pc, #324]	; (1284 <fatfs_get_file_entry+0x160>)
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    1140:	f8df 8158 	ldr.w	r8, [pc, #344]	; 129c <fatfs_get_file_entry+0x178>
                    fatfs_lfn_cache_init(&lfn, 0);

                // Normal SFN Entry and Long text exists
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) )
    1144:	f8df 9158 	ldr.w	r9, [pc, #344]	; 12a0 <fatfs_get_file_entry+0x17c>
    1148:	e08b      	b.n	1262 <fatfs_get_file_entry+0x13e>
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    114a:	4620      	mov	r0, r4
    114c:	47c0      	blx	r8
    114e:	b180      	cbz	r0, 1172 <fatfs_get_file_entry+0x4e>
                    fatfs_lfn_cache_init(&lfn, 0);
    1150:	2100      	movs	r1, #0
    1152:	a804      	add	r0, sp, #16
    1154:	4b4a      	ldr	r3, [pc, #296]	; (1280 <fatfs_get_file_entry+0x15c>)
    1156:	4798      	blx	r3
    1158:	3420      	adds	r4, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    115a:	42a6      	cmp	r6, r4
    115c:	d07f      	beq.n	125e <fatfs_get_file_entry+0x13a>
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
    115e:	4625      	mov	r5, r4
                if (fatfs_entry_lfn_text(directoryEntry) )
    1160:	4620      	mov	r0, r4
    1162:	47b8      	blx	r7
    1164:	2800      	cmp	r0, #0
    1166:	d0f0      	beq.n	114a <fatfs_get_file_entry+0x26>
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);
    1168:	4621      	mov	r1, r4
    116a:	a804      	add	r0, sp, #16
    116c:	4b46      	ldr	r3, [pc, #280]	; (1288 <fatfs_get_file_entry+0x164>)
    116e:	4798      	blx	r3
    1170:	e7f2      	b.n	1158 <fatfs_get_file_entry+0x34>
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) )
    1172:	4621      	mov	r1, r4
    1174:	a804      	add	r0, sp, #16
    1176:	47c8      	blx	r9
    1178:	b300      	cbz	r0, 11bc <fatfs_get_file_entry+0x98>
                {
                    long_filename = fatfs_lfn_cache_get(&lfn);
    117a:	a804      	add	r0, sp, #16
    117c:	4b43      	ldr	r3, [pc, #268]	; (128c <fatfs_get_file_entry+0x168>)
    117e:	4798      	blx	r3

                    // Compare names to see if they match
                    if (fatfs_compare_names(long_filename, name_to_find))
    1180:	9901      	ldr	r1, [sp, #4]
    1182:	4b43      	ldr	r3, [pc, #268]	; (1290 <fatfs_get_file_entry+0x16c>)
    1184:	4798      	blx	r3
    1186:	b920      	cbnz	r0, 1192 <fatfs_get_file_entry+0x6e>
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
    1188:	2100      	movs	r1, #0
    118a:	a804      	add	r0, sp, #16
    118c:	4b3c      	ldr	r3, [pc, #240]	; (1280 <fatfs_get_file_entry+0x15c>)
    118e:	4798      	blx	r3
    1190:	e7e2      	b.n	1158 <fatfs_get_file_entry+0x34>
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
    1192:	6820      	ldr	r0, [r4, #0]
    1194:	6861      	ldr	r1, [r4, #4]
    1196:	68a2      	ldr	r2, [r4, #8]
    1198:	68e3      	ldr	r3, [r4, #12]
    119a:	9e03      	ldr	r6, [sp, #12]
    119c:	6030      	str	r0, [r6, #0]
    119e:	6071      	str	r1, [r6, #4]
    11a0:	60b2      	str	r2, [r6, #8]
    11a2:	60f3      	str	r3, [r6, #12]
    11a4:	6928      	ldr	r0, [r5, #16]
    11a6:	6969      	ldr	r1, [r5, #20]
    11a8:	69aa      	ldr	r2, [r5, #24]
    11aa:	69eb      	ldr	r3, [r5, #28]
    11ac:	6130      	str	r0, [r6, #16]
    11ae:	6171      	str	r1, [r6, #20]
    11b0:	61b2      	str	r2, [r6, #24]
    11b2:	61f3      	str	r3, [r6, #28]
                        return 1;
    11b4:	2001      	movs	r0, #1
        else
            break;
    } // End of while loop

    return 0;
}
    11b6:	b04b      	add	sp, #300	; 0x12c
    11b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (fatfs_entry_sfn_only(directoryEntry) )
    11bc:	4620      	mov	r0, r4
    11be:	4b35      	ldr	r3, [pc, #212]	; (1294 <fatfs_get_file_entry+0x170>)
    11c0:	4798      	blx	r3
    11c2:	2800      	cmp	r0, #0
    11c4:	d0c8      	beq.n	1158 <fatfs_get_file_entry+0x34>
                    memset(short_filename, 0, sizeof(short_filename));
    11c6:	2300      	movs	r3, #0
    11c8:	9346      	str	r3, [sp, #280]	; 0x118
    11ca:	9347      	str	r3, [sp, #284]	; 0x11c
    11cc:	9348      	str	r3, [sp, #288]	; 0x120
    11ce:	f88d 3124 	strb.w	r3, [sp, #292]	; 0x124
    11d2:	1e63      	subs	r3, r4, #1
    11d4:	f20d 1217 	addw	r2, sp, #279	; 0x117
    11d8:	1de0      	adds	r0, r4, #7
                        short_filename[i] = directoryEntry->Name[i];
    11da:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    11de:	f802 1f01 	strb.w	r1, [r2, #1]!
                    for (i=0; i<8; i++)
    11e2:	4298      	cmp	r0, r3
    11e4:	d1f9      	bne.n	11da <fatfs_get_file_entry+0xb6>
                        short_filename[i+1] = directoryEntry->Name[i];
    11e6:	7a2b      	ldrb	r3, [r5, #8]
    11e8:	f88d 3121 	strb.w	r3, [sp, #289]	; 0x121
                        if (directoryEntry->Name[i] != ' ')
    11ec:	3b20      	subs	r3, #32
    11ee:	bf18      	it	ne
    11f0:	2301      	movne	r3, #1
                        short_filename[i+1] = directoryEntry->Name[i];
    11f2:	7a6a      	ldrb	r2, [r5, #9]
    11f4:	f88d 2122 	strb.w	r2, [sp, #290]	; 0x122
                            dotRequired = 1;
    11f8:	2a20      	cmp	r2, #32
    11fa:	bf18      	it	ne
    11fc:	2301      	movne	r3, #1
                        short_filename[i+1] = directoryEntry->Name[i];
    11fe:	7aaa      	ldrb	r2, [r5, #10]
    1200:	f88d 2123 	strb.w	r2, [sp, #291]	; 0x123
                        if (directoryEntry->Name[i] != ' ')
    1204:	2a20      	cmp	r2, #32
    1206:	d011      	beq.n	122c <fatfs_get_file_entry+0x108>
                        if (short_filename[0]!='.')
    1208:	f89d 3118 	ldrb.w	r3, [sp, #280]	; 0x118
    120c:	2b2e      	cmp	r3, #46	; 0x2e
                            short_filename[8] = '.';
    120e:	bf14      	ite	ne
    1210:	232e      	movne	r3, #46	; 0x2e
                            short_filename[8] = ' ';
    1212:	2320      	moveq	r3, #32
    1214:	f88d 3120 	strb.w	r3, [sp, #288]	; 0x120
                    if (fatfs_compare_names(short_filename, name_to_find))
    1218:	9901      	ldr	r1, [sp, #4]
    121a:	a846      	add	r0, sp, #280	; 0x118
    121c:	4b1c      	ldr	r3, [pc, #112]	; (1290 <fatfs_get_file_entry+0x16c>)
    121e:	4798      	blx	r3
    1220:	b950      	cbnz	r0, 1238 <fatfs_get_file_entry+0x114>
                    fatfs_lfn_cache_init(&lfn, 0);
    1222:	2100      	movs	r1, #0
    1224:	a804      	add	r0, sp, #16
    1226:	4b16      	ldr	r3, [pc, #88]	; (1280 <fatfs_get_file_entry+0x15c>)
    1228:	4798      	blx	r3
    122a:	e795      	b.n	1158 <fatfs_get_file_entry+0x34>
                    if (dotRequired)
    122c:	2b00      	cmp	r3, #0
    122e:	d1eb      	bne.n	1208 <fatfs_get_file_entry+0xe4>
                        short_filename[8] = ' ';
    1230:	2320      	movs	r3, #32
    1232:	f88d 3120 	strb.w	r3, [sp, #288]	; 0x120
    1236:	e7ef      	b.n	1218 <fatfs_get_file_entry+0xf4>
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
    1238:	6828      	ldr	r0, [r5, #0]
    123a:	6869      	ldr	r1, [r5, #4]
    123c:	68aa      	ldr	r2, [r5, #8]
    123e:	68eb      	ldr	r3, [r5, #12]
    1240:	9e03      	ldr	r6, [sp, #12]
    1242:	6030      	str	r0, [r6, #0]
    1244:	6071      	str	r1, [r6, #4]
    1246:	60b2      	str	r2, [r6, #8]
    1248:	60f3      	str	r3, [r6, #12]
    124a:	6928      	ldr	r0, [r5, #16]
    124c:	6969      	ldr	r1, [r5, #20]
    124e:	69aa      	ldr	r2, [r5, #24]
    1250:	69eb      	ldr	r3, [r5, #28]
    1252:	6130      	str	r0, [r6, #16]
    1254:	6171      	str	r1, [r6, #20]
    1256:	61b2      	str	r2, [r6, #24]
    1258:	61f3      	str	r3, [r6, #28]
                        return 1;
    125a:	2001      	movs	r0, #1
    125c:	e7ab      	b.n	11b6 <fatfs_get_file_entry+0x92>
    125e:	f10b 0b01 	add.w	fp, fp, #1
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
    1262:	2300      	movs	r3, #0
    1264:	465a      	mov	r2, fp
    1266:	9902      	ldr	r1, [sp, #8]
    1268:	4650      	mov	r0, sl
    126a:	4c0b      	ldr	r4, [pc, #44]	; (1298 <fatfs_get_file_entry+0x174>)
    126c:	47a0      	blx	r4
    126e:	b120      	cbz	r0, 127a <fatfs_get_file_entry+0x156>
    1270:	f10a 0440 	add.w	r4, sl, #64	; 0x40
    1274:	f50a 7610 	add.w	r6, sl, #576	; 0x240
    1278:	e771      	b.n	115e <fatfs_get_file_entry+0x3a>
    return 0;
    127a:	2000      	movs	r0, #0
    127c:	e79b      	b.n	11b6 <fatfs_get_file_entry+0x92>
    127e:	bf00      	nop
    1280:	00001fed 	.word	0x00001fed
    1284:	000020a5 	.word	0x000020a5
    1288:	0000200d 	.word	0x0000200d
    128c:	0000207f 	.word	0x0000207f
    1290:	000025e1 	.word	0x000025e1
    1294:	00002113 	.word	0x00002113
    1298:	00001021 	.word	0x00001021
    129c:	000020b5 	.word	0x000020b5
    12a0:	000020db 	.word	0x000020db

000012a4 <fatfs_sfn_exists>:
// fatfs_sfn_exists: Check if a short filename exists.
// NOTE: shortname is XXXXXXXXYYY not XXXXXXXX.YYY
//-------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_sfn_exists(struct fatfs *fs, uint32 Cluster, char *shortname)
{
    12a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    12a8:	b083      	sub	sp, #12
    12aa:	4681      	mov	r9, r0
    12ac:	9100      	str	r1, [sp, #0]
    12ae:	9201      	str	r2, [sp, #4]
    12b0:	f04f 0a00 	mov.w	sl, #0
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) )
    12b4:	4f18      	ldr	r7, [pc, #96]	; (1318 <fatfs_sfn_exists+0x74>)
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    12b6:	f8df 806c 	ldr.w	r8, [pc, #108]	; 1324 <fatfs_sfn_exists+0x80>
                    ;
                else
#endif
                // Normal Entry, only 8.3 Text
                if (fatfs_entry_sfn_only(directoryEntry) )
    12ba:	f8df b06c 	ldr.w	fp, [pc, #108]	; 1328 <fatfs_sfn_exists+0x84>
    12be:	e01c      	b.n	12fa <fatfs_sfn_exists+0x56>
    12c0:	3420      	adds	r4, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    12c2:	42b4      	cmp	r4, r6
    12c4:	d017      	beq.n	12f6 <fatfs_sfn_exists+0x52>
                if (fatfs_entry_lfn_text(directoryEntry) )
    12c6:	4620      	mov	r0, r4
    12c8:	47b8      	blx	r7
    12ca:	2800      	cmp	r0, #0
    12cc:	d1f8      	bne.n	12c0 <fatfs_sfn_exists+0x1c>
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    12ce:	4620      	mov	r0, r4
    12d0:	47c0      	blx	r8
    12d2:	2800      	cmp	r0, #0
    12d4:	d1f4      	bne.n	12c0 <fatfs_sfn_exists+0x1c>
                if (fatfs_entry_sfn_only(directoryEntry) )
    12d6:	4620      	mov	r0, r4
    12d8:	47d8      	blx	fp
    12da:	2800      	cmp	r0, #0
    12dc:	d0f0      	beq.n	12c0 <fatfs_sfn_exists+0x1c>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
    12de:	220b      	movs	r2, #11
    12e0:	9901      	ldr	r1, [sp, #4]
    12e2:	4620      	mov	r0, r4
    12e4:	4b0d      	ldr	r3, [pc, #52]	; (131c <fatfs_sfn_exists+0x78>)
    12e6:	4798      	blx	r3
    12e8:	2800      	cmp	r0, #0
    12ea:	d1e9      	bne.n	12c0 <fatfs_sfn_exists+0x1c>
                        return 1;
    12ec:	2301      	movs	r3, #1
        else
            break;
    } // End of while loop

    return 0;
}
    12ee:	4618      	mov	r0, r3
    12f0:	b003      	add	sp, #12
    12f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    12f6:	f10a 0a01 	add.w	sl, sl, #1
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
    12fa:	2300      	movs	r3, #0
    12fc:	4652      	mov	r2, sl
    12fe:	9900      	ldr	r1, [sp, #0]
    1300:	4648      	mov	r0, r9
    1302:	4c07      	ldr	r4, [pc, #28]	; (1320 <fatfs_sfn_exists+0x7c>)
    1304:	47a0      	blx	r4
    1306:	4603      	mov	r3, r0
    1308:	2800      	cmp	r0, #0
    130a:	d0f0      	beq.n	12ee <fatfs_sfn_exists+0x4a>
    130c:	f109 0440 	add.w	r4, r9, #64	; 0x40
    1310:	f509 7610 	add.w	r6, r9, #576	; 0x240
    1314:	e7d7      	b.n	12c6 <fatfs_sfn_exists+0x22>
    1316:	bf00      	nop
    1318:	000020a5 	.word	0x000020a5
    131c:	00003cdd 	.word	0x00003cdd
    1320:	00001021 	.word	0x00001021
    1324:	000020b5 	.word	0x000020b5
    1328:	00002113 	.word	0x00002113

0000132c <fatfs_update_file_length>:
// fatfs_update_file_length: Find a SFN entry and update it
// NOTE: shortname is XXXXXXXXYYY not XXXXXXXX.YYY
//-------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_update_file_length(struct fatfs *fs, uint32 Cluster, char *shortname, uint32 fileLength)
{
    132c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1330:	b085      	sub	sp, #20
    uint16 recordoffset = 0;
    int x=0;
    struct fat_dir_entry *directoryEntry;

    // No write access?
    if (!fs->disk_io.write_media)
    1332:	6b44      	ldr	r4, [r0, #52]	; 0x34
    1334:	2c00      	cmp	r4, #0
    1336:	d043      	beq.n	13c0 <fatfs_update_file_length+0x94>
    1338:	9303      	str	r3, [sp, #12]
    133a:	9202      	str	r2, [sp, #8]
    133c:	9101      	str	r1, [sp, #4]
    133e:	4605      	mov	r5, r0
    1340:	f04f 0b00 	mov.w	fp, #0

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
    1344:	f8df 8088 	ldr.w	r8, [pc, #136]	; 13d0 <fatfs_update_file_length+0xa4>
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) )
    1348:	4e1e      	ldr	r6, [pc, #120]	; (13c4 <fatfs_update_file_length+0x98>)
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    134a:	f8df a088 	ldr.w	sl, [pc, #136]	; 13d4 <fatfs_update_file_length+0xa8>
    134e:	e02a      	b.n	13a6 <fatfs_update_file_length+0x7a>
    1350:	3420      	adds	r4, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    1352:	42bc      	cmp	r4, r7
    1354:	d025      	beq.n	13a2 <fatfs_update_file_length+0x76>
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
    1356:	f105 0940 	add.w	r9, r5, #64	; 0x40
    135a:	9400      	str	r4, [sp, #0]
                if (fatfs_entry_lfn_text(directoryEntry) )
    135c:	4620      	mov	r0, r4
    135e:	47b0      	blx	r6
    1360:	2800      	cmp	r0, #0
    1362:	d1f5      	bne.n	1350 <fatfs_update_file_length+0x24>
                else if (fatfs_entry_lfn_invalid(directoryEntry) )
    1364:	4620      	mov	r0, r4
    1366:	47d0      	blx	sl
    1368:	2800      	cmp	r0, #0
    136a:	d1f1      	bne.n	1350 <fatfs_update_file_length+0x24>
                    ;

                // Normal Entry, only 8.3 Text
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
    136c:	9800      	ldr	r0, [sp, #0]
    136e:	4b16      	ldr	r3, [pc, #88]	; (13c8 <fatfs_update_file_length+0x9c>)
    1370:	4798      	blx	r3
    1372:	2800      	cmp	r0, #0
    1374:	d0ec      	beq.n	1350 <fatfs_update_file_length+0x24>
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
    1376:	220b      	movs	r2, #11
    1378:	9902      	ldr	r1, [sp, #8]
    137a:	9800      	ldr	r0, [sp, #0]
    137c:	4b13      	ldr	r3, [pc, #76]	; (13cc <fatfs_update_file_length+0xa0>)
    137e:	4798      	blx	r3
    1380:	2800      	cmp	r0, #0
    1382:	d1e5      	bne.n	1350 <fatfs_update_file_length+0x24>
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
    1384:	9b00      	ldr	r3, [sp, #0]
    1386:	461a      	mov	r2, r3
    1388:	9b03      	ldr	r3, [sp, #12]
    138a:	61d3      	str	r3, [r2, #28]

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
    138c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    138e:	2201      	movs	r2, #1
    1390:	4649      	mov	r1, r9
    1392:	f8d5 0240 	ldr.w	r0, [r5, #576]	; 0x240
    1396:	4798      	blx	r3
    1398:	4603      	mov	r3, r0
        else
            break;
    } // End of while loop

    return 0;
}
    139a:	4618      	mov	r0, r3
    139c:	b005      	add	sp, #20
    139e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    13a2:	f10b 0b01 	add.w	fp, fp, #1
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
    13a6:	2300      	movs	r3, #0
    13a8:	465a      	mov	r2, fp
    13aa:	9901      	ldr	r1, [sp, #4]
    13ac:	4628      	mov	r0, r5
    13ae:	47c0      	blx	r8
    13b0:	4603      	mov	r3, r0
    13b2:	2800      	cmp	r0, #0
    13b4:	d0f1      	beq.n	139a <fatfs_update_file_length+0x6e>
    13b6:	f105 0440 	add.w	r4, r5, #64	; 0x40
    13ba:	f505 7710 	add.w	r7, r5, #576	; 0x240
    13be:	e7ca      	b.n	1356 <fatfs_update_file_length+0x2a>
        return 0;
    13c0:	2300      	movs	r3, #0
    13c2:	e7ea      	b.n	139a <fatfs_update_file_length+0x6e>
    13c4:	000020a5 	.word	0x000020a5
    13c8:	00002113 	.word	0x00002113
    13cc:	00003cdd 	.word	0x00003cdd
    13d0:	00001021 	.word	0x00001021
    13d4:	000020b5 	.word	0x000020b5

000013d8 <fatfs_cache_init>:
        file->cluster_cache_data[i] = 0;
    }
#endif

    return 1;
}
    13d8:	2001      	movs	r0, #1
    13da:	4770      	bx	lr

000013dc <fatfs_cache_get_next_cluster>:
        return 1;
    }
#endif

    return 0;
}
    13dc:	2000      	movs	r0, #0
    13de:	4770      	bx	lr

000013e0 <fatfs_cache_set_next_cluster>:
        file->cluster_cache_data[slot] = nextCluster;
    }
#endif

    return 1;
}
    13e0:	2001      	movs	r0, #1
    13e2:	4770      	bx	lr

000013e4 <fat_list_insert_last>:
static FAT_INLINE void fat_list_insert_last(struct fat_list *list, struct fat_node *node)
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
    13e4:	6843      	ldr	r3, [r0, #4]
    13e6:	b13b      	cbz	r3, 13f8 <fat_list_insert_last+0x14>
    new_node->previous = node;
    13e8:	600b      	str	r3, [r1, #0]
    new_node->next = node->next;
    13ea:	685a      	ldr	r2, [r3, #4]
    13ec:	604a      	str	r2, [r1, #4]
    if (!node->next)
    13ee:	685a      	ldr	r2, [r3, #4]
    13f0:	b19a      	cbz	r2, 141a <fat_list_insert_last+0x36>
        node->next->previous = new_node;
    13f2:	6011      	str	r1, [r2, #0]
    node->next = new_node;
    13f4:	6059      	str	r1, [r3, #4]
    13f6:	4770      	bx	lr
    if (!list->head)
    13f8:	6803      	ldr	r3, [r0, #0]
    13fa:	b13b      	cbz	r3, 140c <fat_list_insert_last+0x28>
    new_node->previous = node->previous;
    13fc:	681a      	ldr	r2, [r3, #0]
    13fe:	600a      	str	r2, [r1, #0]
    new_node->next = node;
    1400:	604b      	str	r3, [r1, #4]
    if (!node->previous)
    1402:	681a      	ldr	r2, [r3, #0]
    1404:	b13a      	cbz	r2, 1416 <fat_list_insert_last+0x32>
        node->previous->next = new_node;
    1406:	6051      	str	r1, [r2, #4]
    node->previous = new_node;
    1408:	6019      	str	r1, [r3, #0]
    140a:	4770      	bx	lr
        list->head = node;
    140c:	6001      	str	r1, [r0, #0]
        list->tail = node;
    140e:	6041      	str	r1, [r0, #4]
        node->previous = 0;
    1410:	600b      	str	r3, [r1, #0]
        node->next = 0;
    1412:	604b      	str	r3, [r1, #4]
    1414:	4770      	bx	lr
        list->head = new_node;
    1416:	6001      	str	r1, [r0, #0]
    1418:	e7f6      	b.n	1408 <fat_list_insert_last+0x24>
        list->tail = new_node;
    141a:	6041      	str	r1, [r0, #4]
    141c:	e7ea      	b.n	13f4 <fat_list_insert_last+0x10>
	...

00001420 <_allocate_file>:

//-----------------------------------------------------------------------------
// _allocate_file: Find a slot in the open files buffer for a new file
//-----------------------------------------------------------------------------
static FL_FILE* _allocate_file(void)
{
    1420:	b510      	push	{r4, lr}
{
    struct fat_node * node;

    FAT_ASSERT(list);

    node = fat_list_first(list);
    1422:	4b0e      	ldr	r3, [pc, #56]	; (145c <_allocate_file+0x3c>)
    1424:	681c      	ldr	r4, [r3, #0]
    if (node)
    1426:	b1b4      	cbz	r4, 1456 <_allocate_file+0x36>
    if(!node->previous)
    1428:	6823      	ldr	r3, [r4, #0]
    142a:	b163      	cbz	r3, 1446 <_allocate_file+0x26>
        node->previous->next = node->next;
    142c:	6862      	ldr	r2, [r4, #4]
    142e:	605a      	str	r2, [r3, #4]
    if(!node->next)
    1430:	6863      	ldr	r3, [r4, #4]
    1432:	b163      	cbz	r3, 144e <_allocate_file+0x2e>
        node->next->previous = node->previous;
    1434:	6822      	ldr	r2, [r4, #0]
    1436:	601a      	str	r2, [r3, #0]
    // Allocate free file
    struct fat_node *node = fat_list_pop_head(&_free_file_list);

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);
    1438:	4621      	mov	r1, r4
    143a:	4809      	ldr	r0, [pc, #36]	; (1460 <_allocate_file+0x40>)
    143c:	4b09      	ldr	r3, [pc, #36]	; (1464 <_allocate_file+0x44>)
    143e:	4798      	blx	r3

    return fat_list_entry(node, FL_FILE, list_node);
    1440:	f2a4 403c 	subw	r0, r4, #1084	; 0x43c
}
    1444:	bd10      	pop	{r4, pc}
        list->head = node->next;
    1446:	6862      	ldr	r2, [r4, #4]
    1448:	4b04      	ldr	r3, [pc, #16]	; (145c <_allocate_file+0x3c>)
    144a:	601a      	str	r2, [r3, #0]
    144c:	e7f0      	b.n	1430 <_allocate_file+0x10>
        list->tail = node->previous;
    144e:	6822      	ldr	r2, [r4, #0]
    1450:	4b02      	ldr	r3, [pc, #8]	; (145c <_allocate_file+0x3c>)
    1452:	605a      	str	r2, [r3, #4]
    1454:	e7f0      	b.n	1438 <_allocate_file+0x18>
    if (node)
    1456:	2000      	movs	r0, #0
    1458:	bd10      	pop	{r4, pc}
    145a:	bf00      	nop
    145c:	20000468 	.word	0x20000468
    1460:	20000470 	.word	0x20000470
    1464:	000013e5 	.word	0x000013e5

00001468 <_check_file_open>:
//-----------------------------------------------------------------------------
// _check_file_open: Returns true if the file is already open
//-----------------------------------------------------------------------------
static int _check_file_open(FL_FILE* file)
{
    1468:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    struct fat_node *node;

    // Compare open files
    fat_list_for_each(&_open_file_list, node)
    146c:	4b12      	ldr	r3, [pc, #72]	; (14b8 <_check_file_open+0x50>)
    146e:	689c      	ldr	r4, [r3, #8]
    1470:	b1f4      	cbz	r4, 14b0 <_check_file_open+0x48>
    1472:	4606      	mov	r6, r0

        // If not the current file
        if (openFile != file)
        {
            // Compare path and name
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
    1474:	f100 0814 	add.w	r8, r0, #20
    1478:	4f10      	ldr	r7, [pc, #64]	; (14bc <_check_file_open+0x54>)
    147a:	f500 798c 	add.w	r9, r0, #280	; 0x118
    147e:	e001      	b.n	1484 <_check_file_open+0x1c>
    fat_list_for_each(&_open_file_list, node)
    1480:	6864      	ldr	r4, [r4, #4]
    1482:	b194      	cbz	r4, 14aa <_check_file_open+0x42>
        FL_FILE* openFile = fat_list_entry(node, FL_FILE, list_node);
    1484:	f2a4 453c 	subw	r5, r4, #1084	; 0x43c
        if (openFile != file)
    1488:	42b5      	cmp	r5, r6
    148a:	d0f9      	beq.n	1480 <_check_file_open+0x18>
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
    148c:	4641      	mov	r1, r8
    148e:	f5a4 6085 	sub.w	r0, r4, #1064	; 0x428
    1492:	47b8      	blx	r7
    1494:	2800      	cmp	r0, #0
    1496:	d0f3      	beq.n	1480 <_check_file_open+0x18>
    1498:	4649      	mov	r1, r9
    149a:	f5a4 7049 	sub.w	r0, r4, #804	; 0x324
    149e:	47b8      	blx	r7
    14a0:	2800      	cmp	r0, #0
    14a2:	d0ed      	beq.n	1480 <_check_file_open+0x18>
                return 1;
    14a4:	2001      	movs	r0, #1
        }
    }

    return 0;
}
    14a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;
    14aa:	2000      	movs	r0, #0
    14ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    14b0:	2000      	movs	r0, #0
    14b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    14b6:	bf00      	nop
    14b8:	20000468 	.word	0x20000468
    14bc:	000025e1 	.word	0x000025e1

000014c0 <_open_directory>:
//-----------------------------------------------------------------------------
// _open_directory: Cycle through path string to find the start cluster
// address of the highest subdir.
//-----------------------------------------------------------------------------
static int _open_directory(char *path, uint32 *pathCluster)
{
    14c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14c4:	b0ca      	sub	sp, #296	; 0x128
    14c6:	4680      	mov	r8, r0
    14c8:	468a      	mov	sl, r1
    char currentfolder[FATFS_MAX_LONG_FILENAME];
    struct fat_dir_entry sfEntry;
    uint32 startcluster;

    // Set starting cluster to root cluster
    startcluster = fatfs_get_root_cluster(&_fs);
    14ca:	481c      	ldr	r0, [pc, #112]	; (153c <_open_directory+0x7c>)
    14cc:	4b1c      	ldr	r3, [pc, #112]	; (1540 <_open_directory+0x80>)
    14ce:	4798      	blx	r3
    14d0:	4604      	mov	r4, r0

    // Find number of levels
    levels = fatfs_total_path_levels(path);
    14d2:	4640      	mov	r0, r8
    14d4:	4b1b      	ldr	r3, [pc, #108]	; (1544 <_open_directory+0x84>)
    14d6:	4798      	blx	r3

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++)
    14d8:	1c43      	adds	r3, r0, #1
    14da:	2b00      	cmp	r3, #0
    14dc:	dd22      	ble.n	1524 <_open_directory+0x64>
    14de:	461e      	mov	r6, r3
    14e0:	2500      	movs	r5, #0
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
    14e2:	4f19      	ldr	r7, [pc, #100]	; (1548 <_open_directory+0x88>)
            return 0;

        // Find clusteraddress for folder (currentfolder)
        if (fatfs_get_file_entry(&_fs, startcluster, currentfolder,&sfEntry))
    14e4:	f8df 9054 	ldr.w	r9, [pc, #84]	; 153c <_open_directory+0x7c>
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
    14e8:	f44f 7382 	mov.w	r3, #260	; 0x104
    14ec:	aa09      	add	r2, sp, #36	; 0x24
    14ee:	4629      	mov	r1, r5
    14f0:	4640      	mov	r0, r8
    14f2:	47b8      	blx	r7
    14f4:	f1b0 3fff 	cmp.w	r0, #4294967295
    14f8:	d01b      	beq.n	1532 <_open_directory+0x72>
        if (fatfs_get_file_entry(&_fs, startcluster, currentfolder,&sfEntry))
    14fa:	ab01      	add	r3, sp, #4
    14fc:	aa09      	add	r2, sp, #36	; 0x24
    14fe:	4621      	mov	r1, r4
    1500:	4648      	mov	r0, r9
    1502:	4c12      	ldr	r4, [pc, #72]	; (154c <_open_directory+0x8c>)
    1504:	47a0      	blx	r4
    1506:	b1b0      	cbz	r0, 1536 <_open_directory+0x76>
        {
            // Check entry is folder
            if (fatfs_entry_is_dir(&sfEntry))
    1508:	a801      	add	r0, sp, #4
    150a:	4b11      	ldr	r3, [pc, #68]	; (1550 <_open_directory+0x90>)
    150c:	4798      	blx	r3
    150e:	4603      	mov	r3, r0
    1510:	b158      	cbz	r0, 152a <_open_directory+0x6a>
                startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
    1512:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    1516:	f8bd 401e 	ldrh.w	r4, [sp, #30]
    151a:	eb04 4403 	add.w	r4, r4, r3, lsl #16
    for (sublevel=0;sublevel<(levels+1);sublevel++)
    151e:	3501      	adds	r5, #1
    1520:	42ae      	cmp	r6, r5
    1522:	d1e1      	bne.n	14e8 <_open_directory+0x28>
        }
        else
            return 0;
    }

    *pathCluster = startcluster;
    1524:	f8ca 4000 	str.w	r4, [sl]
    return 1;
    1528:	2301      	movs	r3, #1
}
    152a:	4618      	mov	r0, r3
    152c:	b04a      	add	sp, #296	; 0x128
    152e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            return 0;
    1532:	2300      	movs	r3, #0
    1534:	e7f9      	b.n	152a <_open_directory+0x6a>
            return 0;
    1536:	2300      	movs	r3, #0
    1538:	e7f7      	b.n	152a <_open_directory+0x6a>
    153a:	bf00      	nop
    153c:	20000478 	.word	0x20000478
    1540:	00001121 	.word	0x00001121
    1544:	00002477 	.word	0x00002477
    1548:	000024cd 	.word	0x000024cd
    154c:	00001125 	.word	0x00001125
    1550:	00002141 	.word	0x00002141

00001554 <_write_sectors>:
//-----------------------------------------------------------------------------
// _write_sectors: Write sector(s) to disk
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
static uint32 _write_sectors(FL_FILE* file, uint32 offset, uint8 *buf, uint32 count)
{
    1554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1558:	b085      	sub	sp, #20
    155a:	4606      	mov	r6, r0
    155c:	9200      	str	r2, [sp, #0]
    155e:	461a      	mov	r2, r3
    1560:	9301      	str	r3, [sp, #4]
    uint32 SectorNumber = 0;
    uint32 ClusterIdx = 0;
    uint32 Cluster = 0;
    uint32 LastCluster = FAT32_LAST_CLUSTER;
    1562:	f04f 33ff 	mov.w	r3, #4294967295
    1566:	9303      	str	r3, [sp, #12]
    uint32 i;
    uint32 lba;
    uint32 TotalWriteCount = count;

    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;
    1568:	4b35      	ldr	r3, [pc, #212]	; (1640 <_write_sectors+0xec>)
    156a:	f893 8010 	ldrb.w	r8, [r3, #16]
    156e:	fbb1 f7f8 	udiv	r7, r1, r8
    1572:	fb08 1a17 	mls	sl, r8, r7, r1
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);

    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
    1576:	4613      	mov	r3, r2
    1578:	4453      	add	r3, sl
    157a:	4598      	cmp	r8, r3
        count = _fs.sectors_per_cluster - SectorNumber;
    157c:	bf34      	ite	cc
    157e:	eba8 080a 	subcc.w	r8, r8, sl
    1582:	f8dd 8004 	ldrcs.w	r8, [sp, #4]

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
    1586:	f8d0 4228 	ldr.w	r4, [r0, #552]	; 0x228
    158a:	42a7      	cmp	r7, r4
    158c:	d00a      	beq.n	15a4 <_write_sectors+0x50>
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
    158e:	b117      	cbz	r7, 1596 <_write_sectors+0x42>
    1590:	1c63      	adds	r3, r4, #1
    1592:	429f      	cmp	r7, r3
    1594:	d009      	beq.n	15aa <_write_sectors+0x56>
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;
    1596:	6875      	ldr	r5, [r6, #4]
            i = 0;
    1598:	2400      	movs	r4, #0
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
    159a:	42a7      	cmp	r7, r4
    159c:	d924      	bls.n	15e8 <_write_sectors+0x94>
        {
            uint32 nextCluster;

            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    159e:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 1658 <_write_sectors+0x104>
    15a2:	e00d      	b.n	15c0 <_write_sectors+0x6c>
        Cluster = file->last_fat_lookup.CurrentCluster;
    15a4:	f8d0 522c 	ldr.w	r5, [r0, #556]	; 0x22c
    15a8:	e032      	b.n	1610 <_write_sectors+0xbc>
            Cluster = file->last_fat_lookup.CurrentCluster;
    15aa:	f8d0 522c 	ldr.w	r5, [r0, #556]	; 0x22c
    15ae:	e7f4      	b.n	159a <_write_sectors+0x46>

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }

            LastCluster = Cluster;
    15b0:	9503      	str	r5, [sp, #12]
            Cluster = nextCluster;
    15b2:	9d02      	ldr	r5, [sp, #8]

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
    15b4:	f1b5 3fff 	cmp.w	r5, #4294967295
    15b8:	d019      	beq.n	15ee <_write_sectors+0x9a>
        for ( ;i<ClusterIdx; i++)
    15ba:	3401      	adds	r4, #1
    15bc:	42a7      	cmp	r7, r4
    15be:	d023      	beq.n	1608 <_write_sectors+0xb4>
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    15c0:	ab02      	add	r3, sp, #8
    15c2:	4622      	mov	r2, r4
    15c4:	4631      	mov	r1, r6
    15c6:	481f      	ldr	r0, [pc, #124]	; (1644 <_write_sectors+0xf0>)
    15c8:	47c8      	blx	r9
    15ca:	2800      	cmp	r0, #0
    15cc:	d1f0      	bne.n	15b0 <_write_sectors+0x5c>
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
    15ce:	4629      	mov	r1, r5
    15d0:	481c      	ldr	r0, [pc, #112]	; (1644 <_write_sectors+0xf0>)
    15d2:	4b1d      	ldr	r3, [pc, #116]	; (1648 <_write_sectors+0xf4>)
    15d4:	4798      	blx	r3
    15d6:	4603      	mov	r3, r0
    15d8:	9002      	str	r0, [sp, #8]
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
    15da:	4622      	mov	r2, r4
    15dc:	4631      	mov	r1, r6
    15de:	4819      	ldr	r0, [pc, #100]	; (1644 <_write_sectors+0xf0>)
    15e0:	f8df b078 	ldr.w	fp, [pc, #120]	; 165c <_write_sectors+0x108>
    15e4:	47d8      	blx	fp
    15e6:	e7e3      	b.n	15b0 <_write_sectors+0x5c>
                break;
        }

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
    15e8:	f1b5 3fff 	cmp.w	r5, #4294967295
    15ec:	d10c      	bne.n	1608 <_write_sectors+0xb4>
        {
            // Add some more cluster(s) to the last good cluster chain
            if (!fatfs_add_free_space(&_fs, &LastCluster,  (TotalWriteCount + _fs.sectors_per_cluster -1) / _fs.sectors_per_cluster))
    15ee:	4814      	ldr	r0, [pc, #80]	; (1640 <_write_sectors+0xec>)
    15f0:	f810 2f10 	ldrb.w	r2, [r0, #16]!
    15f4:	1e53      	subs	r3, r2, #1
    15f6:	9901      	ldr	r1, [sp, #4]
    15f8:	440b      	add	r3, r1
    15fa:	fbb3 f2f2 	udiv	r2, r3, r2
    15fe:	a903      	add	r1, sp, #12
    1600:	4b12      	ldr	r3, [pc, #72]	; (164c <_write_sectors+0xf8>)
    1602:	4798      	blx	r3
    1604:	b1c0      	cbz	r0, 1638 <_write_sectors+0xe4>
                return 0;

            Cluster = LastCluster;
    1606:	9d03      	ldr	r5, [sp, #12]
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
    1608:	f8c6 522c 	str.w	r5, [r6, #556]	; 0x22c
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
    160c:	f8c6 7228 	str.w	r7, [r6, #552]	; 0x228
    }

    // Calculate write address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + SectorNumber;
    1610:	4c0c      	ldr	r4, [pc, #48]	; (1644 <_write_sectors+0xf0>)
    1612:	4629      	mov	r1, r5
    1614:	4620      	mov	r0, r4
    1616:	4b0e      	ldr	r3, [pc, #56]	; (1650 <_write_sectors+0xfc>)
    1618:	4798      	blx	r3

    if (fatfs_sector_write(&_fs, lba, buf, count))
    161a:	4643      	mov	r3, r8
    161c:	9a00      	ldr	r2, [sp, #0]
    161e:	eb00 010a 	add.w	r1, r0, sl
    1622:	4620      	mov	r0, r4
    1624:	4c0b      	ldr	r4, [pc, #44]	; (1654 <_write_sectors+0x100>)
    1626:	47a0      	blx	r4
    1628:	2800      	cmp	r0, #0
        return count;
    else
        return 0;
    162a:	bf08      	it	eq
    162c:	f04f 0800 	moveq.w	r8, #0
}
    1630:	4640      	mov	r0, r8
    1632:	b005      	add	sp, #20
    1634:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                return 0;
    1638:	f04f 0800 	mov.w	r8, #0
    163c:	e7f8      	b.n	1630 <_write_sectors+0xdc>
    163e:	bf00      	nop
    1640:	20000468 	.word	0x20000468
    1644:	20000478 	.word	0x20000478
    1648:	00002829 	.word	0x00002829
    164c:	00002ac5 	.word	0x00002ac5
    1650:	00000fd9 	.word	0x00000fd9
    1654:	0000100f 	.word	0x0000100f
    1658:	000013dd 	.word	0x000013dd
    165c:	000013e1 	.word	0x000013e1

00001660 <_read_sectors>:
{
    1660:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1664:	b085      	sub	sp, #20
    1666:	4605      	mov	r5, r0
    1668:	9201      	str	r2, [sp, #4]
    166a:	469a      	mov	sl, r3
    ClusterIdx = offset / _fs.sectors_per_cluster;
    166c:	4b2c      	ldr	r3, [pc, #176]	; (1720 <_read_sectors+0xc0>)
    166e:	7c1b      	ldrb	r3, [r3, #16]
    1670:	fbb1 f6f3 	udiv	r6, r1, r3
    1674:	fb03 1916 	mls	r9, r3, r6, r1
    if ((Sector + count) > _fs.sectors_per_cluster)
    1678:	eb0a 0209 	add.w	r2, sl, r9
    167c:	4293      	cmp	r3, r2
        count = _fs.sectors_per_cluster - Sector;
    167e:	bf38      	it	cc
    1680:	eba3 0a09 	subcc.w	sl, r3, r9
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
    1684:	f8d0 4228 	ldr.w	r4, [r0, #552]	; 0x228
    1688:	42a6      	cmp	r6, r4
    168a:	d00c      	beq.n	16a6 <_read_sectors+0x46>
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
    168c:	b116      	cbz	r6, 1694 <_read_sectors+0x34>
    168e:	1c63      	adds	r3, r4, #1
    1690:	429e      	cmp	r6, r3
    1692:	d00f      	beq.n	16b4 <_read_sectors+0x54>
            Cluster = file->startcluster;
    1694:	686f      	ldr	r7, [r5, #4]
            i = 0;
    1696:	2400      	movs	r4, #0
        for ( ;i<ClusterIdx; i++)
    1698:	42a6      	cmp	r6, r4
    169a:	d924      	bls.n	16e6 <_read_sectors+0x86>
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    169c:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1734 <_read_sectors+0xd4>
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
    16a0:	f8df b094 	ldr.w	fp, [pc, #148]	; 1738 <_read_sectors+0xd8>
    16a4:	e00d      	b.n	16c2 <_read_sectors+0x62>
        Cluster = file->last_fat_lookup.CurrentCluster;
    16a6:	f8d0 722c 	ldr.w	r7, [r0, #556]	; 0x22c
    if (Cluster == FAT32_LAST_CLUSTER)
    16aa:	f1b7 3fff 	cmp.w	r7, #4294967295
    16ae:	d121      	bne.n	16f4 <_read_sectors+0x94>
        return 0;
    16b0:	2000      	movs	r0, #0
    16b2:	e02f      	b.n	1714 <_read_sectors+0xb4>
            Cluster = file->last_fat_lookup.CurrentCluster;
    16b4:	f8d0 722c 	ldr.w	r7, [r0, #556]	; 0x22c
    16b8:	e7ee      	b.n	1698 <_read_sectors+0x38>
            Cluster = nextCluster;
    16ba:	9f03      	ldr	r7, [sp, #12]
        for ( ;i<ClusterIdx; i++)
    16bc:	3401      	adds	r4, #1
    16be:	42a6      	cmp	r6, r4
    16c0:	d011      	beq.n	16e6 <_read_sectors+0x86>
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))
    16c2:	ab03      	add	r3, sp, #12
    16c4:	4622      	mov	r2, r4
    16c6:	4629      	mov	r1, r5
    16c8:	4816      	ldr	r0, [pc, #88]	; (1724 <_read_sectors+0xc4>)
    16ca:	47c0      	blx	r8
    16cc:	2800      	cmp	r0, #0
    16ce:	d1f4      	bne.n	16ba <_read_sectors+0x5a>
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
    16d0:	4639      	mov	r1, r7
    16d2:	4814      	ldr	r0, [pc, #80]	; (1724 <_read_sectors+0xc4>)
    16d4:	47d8      	blx	fp
    16d6:	4603      	mov	r3, r0
    16d8:	9003      	str	r0, [sp, #12]
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
    16da:	4622      	mov	r2, r4
    16dc:	4629      	mov	r1, r5
    16de:	4811      	ldr	r0, [pc, #68]	; (1724 <_read_sectors+0xc4>)
    16e0:	4f11      	ldr	r7, [pc, #68]	; (1728 <_read_sectors+0xc8>)
    16e2:	47b8      	blx	r7
    16e4:	e7e9      	b.n	16ba <_read_sectors+0x5a>
        if (Cluster != FAT32_LAST_CLUSTER)
    16e6:	f1b7 3fff 	cmp.w	r7, #4294967295
    16ea:	d016      	beq.n	171a <_read_sectors+0xba>
            file->last_fat_lookup.CurrentCluster = Cluster;
    16ec:	f8c5 722c 	str.w	r7, [r5, #556]	; 0x22c
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
    16f0:	f8c5 6228 	str.w	r6, [r5, #552]	; 0x228
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;
    16f4:	4c0b      	ldr	r4, [pc, #44]	; (1724 <_read_sectors+0xc4>)
    16f6:	4639      	mov	r1, r7
    16f8:	4620      	mov	r0, r4
    16fa:	4b0c      	ldr	r3, [pc, #48]	; (172c <_read_sectors+0xcc>)
    16fc:	4798      	blx	r3
    if (fatfs_sector_read(&_fs, lba, buffer, count))
    16fe:	4653      	mov	r3, sl
    1700:	9a01      	ldr	r2, [sp, #4]
    1702:	eb00 0109 	add.w	r1, r0, r9
    1706:	4620      	mov	r0, r4
    1708:	4c09      	ldr	r4, [pc, #36]	; (1730 <_read_sectors+0xd0>)
    170a:	47a0      	blx	r4
    170c:	2800      	cmp	r0, #0
        return 0;
    170e:	bf14      	ite	ne
    1710:	4650      	movne	r0, sl
    1712:	2000      	moveq	r0, #0
}
    1714:	b005      	add	sp, #20
    1716:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return 0;
    171a:	2000      	movs	r0, #0
    171c:	e7fa      	b.n	1714 <_read_sectors+0xb4>
    171e:	bf00      	nop
    1720:	20000468 	.word	0x20000468
    1724:	20000478 	.word	0x20000478
    1728:	000013e1 	.word	0x000013e1
    172c:	00000fd9 	.word	0x00000fd9
    1730:	00000fff 	.word	0x00000fff
    1734:	000013dd 	.word	0x000013dd
    1738:	00002829 	.word	0x00002829

0000173c <_free_file>:
{
    173c:	b508      	push	{r3, lr}
    fat_list_remove(&_open_file_list, &file->list_node);
    173e:	f200 413c 	addw	r1, r0, #1084	; 0x43c
    if(!node->previous)
    1742:	f8d0 343c 	ldr.w	r3, [r0, #1084]	; 0x43c
    1746:	b163      	cbz	r3, 1762 <_free_file+0x26>
        node->previous->next = node->next;
    1748:	f8d0 2440 	ldr.w	r2, [r0, #1088]	; 0x440
    174c:	605a      	str	r2, [r3, #4]
    if(!node->next)
    174e:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
    1752:	b15b      	cbz	r3, 176c <_free_file+0x30>
        node->next->previous = node->previous;
    1754:	f8d0 243c 	ldr.w	r2, [r0, #1084]	; 0x43c
    1758:	601a      	str	r2, [r3, #0]
    fat_list_insert_last(&_free_file_list, &file->list_node);
    175a:	4807      	ldr	r0, [pc, #28]	; (1778 <_free_file+0x3c>)
    175c:	4b07      	ldr	r3, [pc, #28]	; (177c <_free_file+0x40>)
    175e:	4798      	blx	r3
    1760:	bd08      	pop	{r3, pc}
        list->head = node->next;
    1762:	f8d0 2440 	ldr.w	r2, [r0, #1088]	; 0x440
    1766:	4b04      	ldr	r3, [pc, #16]	; (1778 <_free_file+0x3c>)
    1768:	609a      	str	r2, [r3, #8]
    176a:	e7f0      	b.n	174e <_free_file+0x12>
        list->tail = node->previous;
    176c:	f8d0 243c 	ldr.w	r2, [r0, #1084]	; 0x43c
    1770:	4b01      	ldr	r3, [pc, #4]	; (1778 <_free_file+0x3c>)
    1772:	60da      	str	r2, [r3, #12]
    1774:	e7f1      	b.n	175a <_free_file+0x1e>
    1776:	bf00      	nop
    1778:	20000468 	.word	0x20000468
    177c:	000013e5 	.word	0x000013e5

00001780 <_open_file>:
{
    1780:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1784:	b08b      	sub	sp, #44	; 0x2c
    1786:	4681      	mov	r9, r0
    file = _allocate_file();
    1788:	4b3f      	ldr	r3, [pc, #252]	; (1888 <_open_file+0x108>)
    178a:	4798      	blx	r3
    if (!file)
    178c:	4604      	mov	r4, r0
    178e:	2800      	cmp	r0, #0
    1790:	d05c      	beq.n	184c <_open_file+0xcc>
    memset(file->path, '\0', sizeof(file->path));
    1792:	f100 0714 	add.w	r7, r0, #20
    1796:	f44f 7582 	mov.w	r5, #260	; 0x104
    179a:	462a      	mov	r2, r5
    179c:	2100      	movs	r1, #0
    179e:	4638      	mov	r0, r7
    17a0:	f8df 8110 	ldr.w	r8, [pc, #272]	; 18b4 <_open_file+0x134>
    17a4:	47c0      	blx	r8
    memset(file->filename, '\0', sizeof(file->filename));
    17a6:	f504 768c 	add.w	r6, r4, #280	; 0x118
    17aa:	462a      	mov	r2, r5
    17ac:	2100      	movs	r1, #0
    17ae:	4630      	mov	r0, r6
    17b0:	47c0      	blx	r8
    if (fatfs_split_path((char*)path, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
    17b2:	9500      	str	r5, [sp, #0]
    17b4:	4633      	mov	r3, r6
    17b6:	462a      	mov	r2, r5
    17b8:	4639      	mov	r1, r7
    17ba:	4648      	mov	r0, r9
    17bc:	4d33      	ldr	r5, [pc, #204]	; (188c <_open_file+0x10c>)
    17be:	47a8      	blx	r5
    17c0:	f1b0 3fff 	cmp.w	r0, #4294967295
    17c4:	d046      	beq.n	1854 <_open_file+0xd4>
    if (_check_file_open(file))
    17c6:	4620      	mov	r0, r4
    17c8:	4b31      	ldr	r3, [pc, #196]	; (1890 <_open_file+0x110>)
    17ca:	4798      	blx	r3
    17cc:	2800      	cmp	r0, #0
    17ce:	d146      	bne.n	185e <_open_file+0xde>
    if (file->path[0]==0)
    17d0:	7d23      	ldrb	r3, [r4, #20]
    17d2:	2b00      	cmp	r3, #0
    17d4:	d148      	bne.n	1868 <_open_file+0xe8>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    17d6:	482f      	ldr	r0, [pc, #188]	; (1894 <_open_file+0x114>)
    17d8:	4b2f      	ldr	r3, [pc, #188]	; (1898 <_open_file+0x118>)
    17da:	4798      	blx	r3
    17dc:	6020      	str	r0, [r4, #0]
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry))
    17de:	ab02      	add	r3, sp, #8
    17e0:	4632      	mov	r2, r6
    17e2:	6821      	ldr	r1, [r4, #0]
    17e4:	482b      	ldr	r0, [pc, #172]	; (1894 <_open_file+0x114>)
    17e6:	4d2d      	ldr	r5, [pc, #180]	; (189c <_open_file+0x11c>)
    17e8:	47a8      	blx	r5
    17ea:	2800      	cmp	r0, #0
    17ec:	d047      	beq.n	187e <_open_file+0xfe>
        if (fatfs_entry_is_file(&sfEntry))
    17ee:	a802      	add	r0, sp, #8
    17f0:	4b2b      	ldr	r3, [pc, #172]	; (18a0 <_open_file+0x120>)
    17f2:	4798      	blx	r3
    17f4:	2800      	cmp	r0, #0
    17f6:	d042      	beq.n	187e <_open_file+0xfe>
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
    17f8:	ab02      	add	r3, sp, #8
    17fa:	cb03      	ldmia	r3!, {r0, r1}
    17fc:	f8c4 021c 	str.w	r0, [r4, #540]	; 0x21c
    1800:	f8c4 1220 	str.w	r1, [r4, #544]	; 0x220
    1804:	8819      	ldrh	r1, [r3, #0]
    1806:	789b      	ldrb	r3, [r3, #2]
    1808:	f8a4 1224 	strh.w	r1, [r4, #548]	; 0x224
    180c:	f884 3226 	strb.w	r3, [r4, #550]	; 0x226
            file->filelength = FAT_HTONL(sfEntry.FileSize);
    1810:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1812:	60e3      	str	r3, [r4, #12]
            file->bytenum = 0;
    1814:	2200      	movs	r2, #0
    1816:	60a2      	str	r2, [r4, #8]
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
    1818:	f8bd 101c 	ldrh.w	r1, [sp, #28]
    181c:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
    1820:	eb03 4301 	add.w	r3, r3, r1, lsl #16
    1824:	6063      	str	r3, [r4, #4]
            file->file_data_address = 0xFFFFFFFF;
    1826:	f04f 33ff 	mov.w	r3, #4294967295
    182a:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
            file->file_data_dirty = 0;
    182e:	f8c4 2434 	str.w	r2, [r4, #1076]	; 0x434
            file->filelength_changed = 0;
    1832:	6122      	str	r2, [r4, #16]
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    1834:	f8c4 3228 	str.w	r3, [r4, #552]	; 0x228
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
    1838:	f8c4 322c 	str.w	r3, [r4, #556]	; 0x22c
            fatfs_cache_init(&_fs, file);
    183c:	4d15      	ldr	r5, [pc, #84]	; (1894 <_open_file+0x114>)
    183e:	4621      	mov	r1, r4
    1840:	4628      	mov	r0, r5
    1842:	4b18      	ldr	r3, [pc, #96]	; (18a4 <_open_file+0x124>)
    1844:	4798      	blx	r3
            fatfs_fat_purge(&_fs);
    1846:	4628      	mov	r0, r5
    1848:	4b17      	ldr	r3, [pc, #92]	; (18a8 <_open_file+0x128>)
    184a:	4798      	blx	r3
}
    184c:	4620      	mov	r0, r4
    184e:	b00b      	add	sp, #44	; 0x2c
    1850:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        _free_file(file);
    1854:	4620      	mov	r0, r4
    1856:	4b15      	ldr	r3, [pc, #84]	; (18ac <_open_file+0x12c>)
    1858:	4798      	blx	r3
        return NULL;
    185a:	2400      	movs	r4, #0
    185c:	e7f6      	b.n	184c <_open_file+0xcc>
        _free_file(file);
    185e:	4620      	mov	r0, r4
    1860:	4b12      	ldr	r3, [pc, #72]	; (18ac <_open_file+0x12c>)
    1862:	4798      	blx	r3
        return NULL;
    1864:	2400      	movs	r4, #0
    1866:	e7f1      	b.n	184c <_open_file+0xcc>
        if (!_open_directory(file->path, &file->parentcluster))
    1868:	4621      	mov	r1, r4
    186a:	4638      	mov	r0, r7
    186c:	4b10      	ldr	r3, [pc, #64]	; (18b0 <_open_file+0x130>)
    186e:	4798      	blx	r3
    1870:	2800      	cmp	r0, #0
    1872:	d1b4      	bne.n	17de <_open_file+0x5e>
            _free_file(file);
    1874:	4620      	mov	r0, r4
    1876:	4b0d      	ldr	r3, [pc, #52]	; (18ac <_open_file+0x12c>)
    1878:	4798      	blx	r3
            return NULL;
    187a:	2400      	movs	r4, #0
    187c:	e7e6      	b.n	184c <_open_file+0xcc>
    _free_file(file);
    187e:	4620      	mov	r0, r4
    1880:	4b0a      	ldr	r3, [pc, #40]	; (18ac <_open_file+0x12c>)
    1882:	4798      	blx	r3
    return NULL;
    1884:	2400      	movs	r4, #0
    1886:	e7e1      	b.n	184c <_open_file+0xcc>
    1888:	00001421 	.word	0x00001421
    188c:	00002569 	.word	0x00002569
    1890:	00001469 	.word	0x00001469
    1894:	20000478 	.word	0x20000478
    1898:	00001121 	.word	0x00001121
    189c:	00001125 	.word	0x00001125
    18a0:	00002149 	.word	0x00002149
    18a4:	000013d9 	.word	0x000013d9
    18a8:	000027f1 	.word	0x000027f1
    18ac:	0000173d 	.word	0x0000173d
    18b0:	000014c1 	.word	0x000014c1
    18b4:	00003a71 	.word	0x00003a71

000018b8 <fl_init>:
{
    18b8:	b538      	push	{r3, r4, r5, lr}
    list->head = list->tail = 0;
    18ba:	4c09      	ldr	r4, [pc, #36]	; (18e0 <fl_init+0x28>)
    18bc:	2300      	movs	r3, #0
    18be:	6063      	str	r3, [r4, #4]
    18c0:	6023      	str	r3, [r4, #0]
    18c2:	60e3      	str	r3, [r4, #12]
    18c4:	60a3      	str	r3, [r4, #8]
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);
    18c6:	f504 610b 	add.w	r1, r4, #2224	; 0x8b0
    18ca:	4620      	mov	r0, r4
    18cc:	4d05      	ldr	r5, [pc, #20]	; (18e4 <fl_init+0x2c>)
    18ce:	47a8      	blx	r5
    18d0:	f604 41f4 	addw	r1, r4, #3316	; 0xcf4
    18d4:	4620      	mov	r0, r4
    18d6:	47a8      	blx	r5
    _filelib_init = 1;
    18d8:	2301      	movs	r3, #1
    18da:	f8c4 3cfc 	str.w	r3, [r4, #3324]	; 0xcfc
    18de:	bd38      	pop	{r3, r4, r5, pc}
    18e0:	20000468 	.word	0x20000468
    18e4:	000013e5 	.word	0x000013e5

000018e8 <fl_attach_media>:
{
    18e8:	b538      	push	{r3, r4, r5, lr}
    18ea:	4605      	mov	r5, r0
    18ec:	460c      	mov	r4, r1
    CHECK_FL_INIT();
    18ee:	4b0a      	ldr	r3, [pc, #40]	; (1918 <fl_attach_media+0x30>)
    18f0:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    18f4:	b16b      	cbz	r3, 1912 <fl_attach_media+0x2a>
    _fs.disk_io.read_media = rd;
    18f6:	4808      	ldr	r0, [pc, #32]	; (1918 <fl_attach_media+0x30>)
    18f8:	6405      	str	r5, [r0, #64]	; 0x40
    _fs.disk_io.write_media = wr;
    18fa:	6444      	str	r4, [r0, #68]	; 0x44
    if ((res = fatfs_init(&_fs)) != FAT_INIT_OK)
    18fc:	3010      	adds	r0, #16
    18fe:	4b07      	ldr	r3, [pc, #28]	; (191c <fl_attach_media+0x34>)
    1900:	4798      	blx	r3
    1902:	4603      	mov	r3, r0
    1904:	b918      	cbnz	r0, 190e <fl_attach_media+0x26>
    _filelib_valid = 1;
    1906:	2101      	movs	r1, #1
    1908:	4a03      	ldr	r2, [pc, #12]	; (1918 <fl_attach_media+0x30>)
    190a:	f8c2 1d00 	str.w	r1, [r2, #3328]	; 0xd00
}
    190e:	4618      	mov	r0, r3
    1910:	bd38      	pop	{r3, r4, r5, pc}
    CHECK_FL_INIT();
    1912:	4b03      	ldr	r3, [pc, #12]	; (1920 <fl_attach_media+0x38>)
    1914:	4798      	blx	r3
    1916:	e7ee      	b.n	18f6 <fl_attach_media+0xe>
    1918:	20000468 	.word	0x20000468
    191c:	00000d5d 	.word	0x00000d5d
    1920:	000018b9 	.word	0x000018b9

00001924 <fl_fopen>:
{
    1924:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1928:	b093      	sub	sp, #76	; 0x4c
    192a:	4680      	mov	r8, r0
    192c:	460c      	mov	r4, r1
    CHECK_FL_INIT();
    192e:	4bbd      	ldr	r3, [pc, #756]	; (1c24 <fl_fopen+0x300>)
    1930:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1934:	b19b      	cbz	r3, 195e <fl_fopen+0x3a>
    if (!_filelib_valid)
    1936:	4bbb      	ldr	r3, [pc, #748]	; (1c24 <fl_fopen+0x300>)
    1938:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	; 0xd00
    193c:	2b00      	cmp	r3, #0
    193e:	f000 81f2 	beq.w	1d26 <fl_fopen+0x402>
    if (!path || !mode)
    1942:	f1b8 0f00 	cmp.w	r8, #0
    1946:	f000 81f0 	beq.w	1d2a <fl_fopen+0x406>
    194a:	2c00      	cmp	r4, #0
    194c:	f000 81ef 	beq.w	1d2e <fl_fopen+0x40a>
    for (i=0;i<(int)strlen(mode);i++)
    1950:	4620      	mov	r0, r4
    1952:	4bb5      	ldr	r3, [pc, #724]	; (1c28 <fl_fopen+0x304>)
    1954:	4798      	blx	r3
    1956:	1e61      	subs	r1, r4, #1
    1958:	2400      	movs	r4, #0
    195a:	4622      	mov	r2, r4
    195c:	e005      	b.n	196a <fl_fopen+0x46>
    CHECK_FL_INIT();
    195e:	4bb3      	ldr	r3, [pc, #716]	; (1c2c <fl_fopen+0x308>)
    1960:	4798      	blx	r3
    1962:	e7e8      	b.n	1936 <fl_fopen+0x12>
            flags |= FILE_READ;
    1964:	f044 0401 	orr.w	r4, r4, #1
    for (i=0;i<(int)strlen(mode);i++)
    1968:	3201      	adds	r2, #1
    196a:	4282      	cmp	r2, r0
    196c:	f280 80be 	bge.w	1aec <fl_fopen+0x1c8>
        switch (mode[i])
    1970:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    1974:	3b2b      	subs	r3, #43	; 0x2b
    1976:	2b4c      	cmp	r3, #76	; 0x4c
    1978:	d8f6      	bhi.n	1968 <fl_fopen+0x44>
    197a:	a501      	add	r5, pc, #4	; (adr r5, 1980 <fl_fopen+0x5c>)
    197c:	f855 f023 	ldr.w	pc, [r5, r3, lsl #2]
    1980:	00001ac1 	.word	0x00001ac1
    1984:	00001969 	.word	0x00001969
    1988:	00001969 	.word	0x00001969
    198c:	00001969 	.word	0x00001969
    1990:	00001969 	.word	0x00001969
    1994:	00001969 	.word	0x00001969
    1998:	00001969 	.word	0x00001969
    199c:	00001969 	.word	0x00001969
    19a0:	00001969 	.word	0x00001969
    19a4:	00001969 	.word	0x00001969
    19a8:	00001969 	.word	0x00001969
    19ac:	00001969 	.word	0x00001969
    19b0:	00001969 	.word	0x00001969
    19b4:	00001969 	.word	0x00001969
    19b8:	00001969 	.word	0x00001969
    19bc:	00001969 	.word	0x00001969
    19c0:	00001969 	.word	0x00001969
    19c4:	00001969 	.word	0x00001969
    19c8:	00001969 	.word	0x00001969
    19cc:	00001969 	.word	0x00001969
    19d0:	00001969 	.word	0x00001969
    19d4:	00001969 	.word	0x00001969
    19d8:	00001abb 	.word	0x00001abb
    19dc:	00001ae7 	.word	0x00001ae7
    19e0:	00001969 	.word	0x00001969
    19e4:	00001969 	.word	0x00001969
    19e8:	00001969 	.word	0x00001969
    19ec:	00001969 	.word	0x00001969
    19f0:	00001969 	.word	0x00001969
    19f4:	00001969 	.word	0x00001969
    19f8:	00001969 	.word	0x00001969
    19fc:	00001969 	.word	0x00001969
    1a00:	00001969 	.word	0x00001969
    1a04:	00001969 	.word	0x00001969
    1a08:	00001969 	.word	0x00001969
    1a0c:	00001969 	.word	0x00001969
    1a10:	00001969 	.word	0x00001969
    1a14:	00001969 	.word	0x00001969
    1a18:	00001969 	.word	0x00001969
    1a1c:	00001965 	.word	0x00001965
    1a20:	00001969 	.word	0x00001969
    1a24:	00001969 	.word	0x00001969
    1a28:	00001969 	.word	0x00001969
    1a2c:	00001969 	.word	0x00001969
    1a30:	00001ab5 	.word	0x00001ab5
    1a34:	00001969 	.word	0x00001969
    1a38:	00001969 	.word	0x00001969
    1a3c:	00001969 	.word	0x00001969
    1a40:	00001969 	.word	0x00001969
    1a44:	00001969 	.word	0x00001969
    1a48:	00001969 	.word	0x00001969
    1a4c:	00001969 	.word	0x00001969
    1a50:	00001969 	.word	0x00001969
    1a54:	00001969 	.word	0x00001969
    1a58:	00001abb 	.word	0x00001abb
    1a5c:	00001ae7 	.word	0x00001ae7
    1a60:	00001969 	.word	0x00001969
    1a64:	00001969 	.word	0x00001969
    1a68:	00001969 	.word	0x00001969
    1a6c:	00001969 	.word	0x00001969
    1a70:	00001969 	.word	0x00001969
    1a74:	00001969 	.word	0x00001969
    1a78:	00001969 	.word	0x00001969
    1a7c:	00001969 	.word	0x00001969
    1a80:	00001969 	.word	0x00001969
    1a84:	00001969 	.word	0x00001969
    1a88:	00001969 	.word	0x00001969
    1a8c:	00001969 	.word	0x00001969
    1a90:	00001969 	.word	0x00001969
    1a94:	00001969 	.word	0x00001969
    1a98:	00001969 	.word	0x00001969
    1a9c:	00001965 	.word	0x00001965
    1aa0:	00001969 	.word	0x00001969
    1aa4:	00001969 	.word	0x00001969
    1aa8:	00001969 	.word	0x00001969
    1aac:	00001969 	.word	0x00001969
    1ab0:	00001ab5 	.word	0x00001ab5
            flags |= FILE_CREATE;
    1ab4:	f044 0432 	orr.w	r4, r4, #50	; 0x32
            break;
    1ab8:	e756      	b.n	1968 <fl_fopen+0x44>
            flags |= FILE_CREATE;
    1aba:	f044 0426 	orr.w	r4, r4, #38	; 0x26
            break;
    1abe:	e753      	b.n	1968 <fl_fopen+0x44>
            if (flags & FILE_READ)
    1ac0:	f014 0f01 	tst.w	r4, #1
    1ac4:	d002      	beq.n	1acc <fl_fopen+0x1a8>
                flags |= FILE_WRITE;
    1ac6:	f044 0402 	orr.w	r4, r4, #2
    1aca:	e74d      	b.n	1968 <fl_fopen+0x44>
            else if (flags & FILE_WRITE)
    1acc:	f014 0f02 	tst.w	r4, #2
    1ad0:	d002      	beq.n	1ad8 <fl_fopen+0x1b4>
                flags |= FILE_CREATE;
    1ad2:	f044 0431 	orr.w	r4, r4, #49	; 0x31
    1ad6:	e747      	b.n	1968 <fl_fopen+0x44>
            else if (flags & FILE_APPEND)
    1ad8:	f014 0f04 	tst.w	r4, #4
    1adc:	f43f af44 	beq.w	1968 <fl_fopen+0x44>
                flags |= FILE_CREATE;
    1ae0:	f044 0427 	orr.w	r4, r4, #39	; 0x27
    1ae4:	e740      	b.n	1968 <fl_fopen+0x44>
            flags |= FILE_BINARY;
    1ae6:	f044 0408 	orr.w	r4, r4, #8
            break;
    1aea:	e73d      	b.n	1968 <fl_fopen+0x44>
    if (!_fs.disk_io.write_media)
    1aec:	4b4d      	ldr	r3, [pc, #308]	; (1c24 <fl_fopen+0x300>)
    1aee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1af0:	b15b      	cbz	r3, 1b0a <fl_fopen+0x1e6>
    FL_LOCK(&_fs);
    1af2:	4b4c      	ldr	r3, [pc, #304]	; (1c24 <fl_fopen+0x300>)
    1af4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1af6:	b103      	cbz	r3, 1afa <fl_fopen+0x1d6>
    1af8:	4798      	blx	r3
    if (flags & FILE_READ)
    1afa:	f014 0901 	ands.w	r9, r4, #1
    1afe:	d107      	bne.n	1b10 <fl_fopen+0x1ec>
    if (!file && (flags & FILE_CREATE))
    1b00:	f014 0f20 	tst.w	r4, #32
    1b04:	d10c      	bne.n	1b20 <fl_fopen+0x1fc>
    1b06:	2500      	movs	r5, #0
    1b08:	e105      	b.n	1d16 <fl_fopen+0x3f2>
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
    1b0a:	f004 04d9 	and.w	r4, r4, #217	; 0xd9
    1b0e:	e7f0      	b.n	1af2 <fl_fopen+0x1ce>
        file = _open_file(path);
    1b10:	4640      	mov	r0, r8
    1b12:	4b47      	ldr	r3, [pc, #284]	; (1c30 <fl_fopen+0x30c>)
    1b14:	4798      	blx	r3
    if (!file && (flags & FILE_CREATE))
    1b16:	4605      	mov	r5, r0
    1b18:	2800      	cmp	r0, #0
    1b1a:	f040 80fa 	bne.w	1d12 <fl_fopen+0x3ee>
    1b1e:	e7ef      	b.n	1b00 <fl_fopen+0x1dc>
    if (!_fs.disk_io.write_media)
    1b20:	4b40      	ldr	r3, [pc, #256]	; (1c24 <fl_fopen+0x300>)
    1b22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1b24:	2b00      	cmp	r3, #0
    1b26:	f000 8106 	beq.w	1d36 <fl_fopen+0x412>
    file = _allocate_file();
    1b2a:	4b42      	ldr	r3, [pc, #264]	; (1c34 <fl_fopen+0x310>)
    1b2c:	4798      	blx	r3
    if (!file)
    1b2e:	4605      	mov	r5, r0
    1b30:	2800      	cmp	r0, #0
    1b32:	f000 8100 	beq.w	1d36 <fl_fopen+0x412>
    memset(file->path, '\0', sizeof(file->path));
    1b36:	f100 0b14 	add.w	fp, r0, #20
    1b3a:	f44f 7682 	mov.w	r6, #260	; 0x104
    1b3e:	4632      	mov	r2, r6
    1b40:	2100      	movs	r1, #0
    1b42:	4658      	mov	r0, fp
    1b44:	4f3c      	ldr	r7, [pc, #240]	; (1c38 <fl_fopen+0x314>)
    1b46:	47b8      	blx	r7
    memset(file->filename, '\0', sizeof(file->filename));
    1b48:	f505 7a8c 	add.w	sl, r5, #280	; 0x118
    1b4c:	4632      	mov	r2, r6
    1b4e:	2100      	movs	r1, #0
    1b50:	4650      	mov	r0, sl
    1b52:	47b8      	blx	r7
    if (fatfs_split_path((char*)filename, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
    1b54:	9600      	str	r6, [sp, #0]
    1b56:	4653      	mov	r3, sl
    1b58:	4632      	mov	r2, r6
    1b5a:	4659      	mov	r1, fp
    1b5c:	4640      	mov	r0, r8
    1b5e:	4e37      	ldr	r6, [pc, #220]	; (1c3c <fl_fopen+0x318>)
    1b60:	47b0      	blx	r6
    1b62:	f1b0 3fff 	cmp.w	r0, #4294967295
    1b66:	d042      	beq.n	1bee <fl_fopen+0x2ca>
    if (_check_file_open(file))
    1b68:	4628      	mov	r0, r5
    1b6a:	4b35      	ldr	r3, [pc, #212]	; (1c40 <fl_fopen+0x31c>)
    1b6c:	4798      	blx	r3
    1b6e:	4607      	mov	r7, r0
    1b70:	2800      	cmp	r0, #0
    1b72:	d140      	bne.n	1bf6 <fl_fopen+0x2d2>
    if (file->path[0] == 0)
    1b74:	7d2b      	ldrb	r3, [r5, #20]
    1b76:	2b00      	cmp	r3, #0
    1b78:	d141      	bne.n	1bfe <fl_fopen+0x2da>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    1b7a:	4832      	ldr	r0, [pc, #200]	; (1c44 <fl_fopen+0x320>)
    1b7c:	4b32      	ldr	r3, [pc, #200]	; (1c48 <fl_fopen+0x324>)
    1b7e:	4798      	blx	r3
    1b80:	6028      	str	r0, [r5, #0]
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry) == 1)
    1b82:	ab0a      	add	r3, sp, #40	; 0x28
    1b84:	4652      	mov	r2, sl
    1b86:	6829      	ldr	r1, [r5, #0]
    1b88:	482e      	ldr	r0, [pc, #184]	; (1c44 <fl_fopen+0x320>)
    1b8a:	4e30      	ldr	r6, [pc, #192]	; (1c4c <fl_fopen+0x328>)
    1b8c:	47b0      	blx	r6
    1b8e:	2801      	cmp	r0, #1
    1b90:	d03f      	beq.n	1c12 <fl_fopen+0x2ee>
    file->startcluster = 0;
    1b92:	462a      	mov	r2, r5
    1b94:	2300      	movs	r3, #0
    1b96:	f842 3f04 	str.w	r3, [r2, #4]!
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
    1b9a:	2301      	movs	r3, #1
    1b9c:	4619      	mov	r1, r3
    1b9e:	4829      	ldr	r0, [pc, #164]	; (1c44 <fl_fopen+0x320>)
    1ba0:	4e2b      	ldr	r6, [pc, #172]	; (1c50 <fl_fopen+0x32c>)
    1ba2:	47b0      	blx	r6
    1ba4:	2800      	cmp	r0, #0
    1ba6:	d038      	beq.n	1c1a <fl_fopen+0x2f6>
        fatfs_lfn_create_sfn(shortFilename, file->filename);
    1ba8:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 1c68 <fl_fopen+0x344>
    1bac:	4651      	mov	r1, sl
    1bae:	a807      	add	r0, sp, #28
    1bb0:	47d8      	blx	fp
        if (tailNum != 0)
    1bb2:	2f00      	cmp	r7, #0
    1bb4:	d05a      	beq.n	1c6c <fl_fopen+0x348>
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
    1bb6:	f505 7607 	add.w	r6, r5, #540	; 0x21c
    1bba:	463a      	mov	r2, r7
    1bbc:	a907      	add	r1, sp, #28
    1bbe:	4630      	mov	r0, r6
    1bc0:	4b24      	ldr	r3, [pc, #144]	; (1c54 <fl_fopen+0x330>)
    1bc2:	4798      	blx	r3
        if (fatfs_sfn_exists(&_fs, file->parentcluster, (char*)file->shortfilename) == 0)
    1bc4:	9605      	str	r6, [sp, #20]
    1bc6:	4632      	mov	r2, r6
    1bc8:	6829      	ldr	r1, [r5, #0]
    1bca:	481e      	ldr	r0, [pc, #120]	; (1c44 <fl_fopen+0x320>)
    1bcc:	4b22      	ldr	r3, [pc, #136]	; (1c58 <fl_fopen+0x334>)
    1bce:	4798      	blx	r3
    1bd0:	2800      	cmp	r0, #0
    1bd2:	d05e      	beq.n	1c92 <fl_fopen+0x36e>
        tailNum++;
    1bd4:	3701      	adds	r7, #1
    while (tailNum < 9999);
    1bd6:	f242 730f 	movw	r3, #9999	; 0x270f
    1bda:	429f      	cmp	r7, r3
    1bdc:	d1e6      	bne.n	1bac <fl_fopen+0x288>
        fatfs_free_cluster_chain(&_fs, file->startcluster);
    1bde:	6869      	ldr	r1, [r5, #4]
    1be0:	4818      	ldr	r0, [pc, #96]	; (1c44 <fl_fopen+0x320>)
    1be2:	4b1e      	ldr	r3, [pc, #120]	; (1c5c <fl_fopen+0x338>)
    1be4:	4798      	blx	r3
        _free_file(file);
    1be6:	4628      	mov	r0, r5
    1be8:	4b1d      	ldr	r3, [pc, #116]	; (1c60 <fl_fopen+0x33c>)
    1bea:	4798      	blx	r3
    1bec:	e087      	b.n	1cfe <fl_fopen+0x3da>
        _free_file(file);
    1bee:	4628      	mov	r0, r5
    1bf0:	4b1b      	ldr	r3, [pc, #108]	; (1c60 <fl_fopen+0x33c>)
    1bf2:	4798      	blx	r3
    1bf4:	e083      	b.n	1cfe <fl_fopen+0x3da>
        _free_file(file);
    1bf6:	4628      	mov	r0, r5
    1bf8:	4b19      	ldr	r3, [pc, #100]	; (1c60 <fl_fopen+0x33c>)
    1bfa:	4798      	blx	r3
    1bfc:	e07f      	b.n	1cfe <fl_fopen+0x3da>
        if (!_open_directory(file->path, &file->parentcluster))
    1bfe:	4629      	mov	r1, r5
    1c00:	4658      	mov	r0, fp
    1c02:	4b18      	ldr	r3, [pc, #96]	; (1c64 <fl_fopen+0x340>)
    1c04:	4798      	blx	r3
    1c06:	2800      	cmp	r0, #0
    1c08:	d1bb      	bne.n	1b82 <fl_fopen+0x25e>
            _free_file(file);
    1c0a:	4628      	mov	r0, r5
    1c0c:	4b14      	ldr	r3, [pc, #80]	; (1c60 <fl_fopen+0x33c>)
    1c0e:	4798      	blx	r3
    1c10:	e075      	b.n	1cfe <fl_fopen+0x3da>
        _free_file(file);
    1c12:	4628      	mov	r0, r5
    1c14:	4b12      	ldr	r3, [pc, #72]	; (1c60 <fl_fopen+0x33c>)
    1c16:	4798      	blx	r3
    1c18:	e071      	b.n	1cfe <fl_fopen+0x3da>
        _free_file(file);
    1c1a:	4628      	mov	r0, r5
    1c1c:	4b10      	ldr	r3, [pc, #64]	; (1c60 <fl_fopen+0x33c>)
    1c1e:	4798      	blx	r3
    1c20:	e06d      	b.n	1cfe <fl_fopen+0x3da>
    1c22:	bf00      	nop
    1c24:	20000468 	.word	0x20000468
    1c28:	00003c01 	.word	0x00003c01
    1c2c:	000018b9 	.word	0x000018b9
    1c30:	00001781 	.word	0x00001781
    1c34:	00001421 	.word	0x00001421
    1c38:	00003a71 	.word	0x00003a71
    1c3c:	00002569 	.word	0x00002569
    1c40:	00001469 	.word	0x00001469
    1c44:	20000478 	.word	0x20000478
    1c48:	00001121 	.word	0x00001121
    1c4c:	00001125 	.word	0x00001125
    1c50:	00002b39 	.word	0x00002b39
    1c54:	00002349 	.word	0x00002349
    1c58:	000012a5 	.word	0x000012a5
    1c5c:	00002a39 	.word	0x00002a39
    1c60:	0000173d 	.word	0x0000173d
    1c64:	000014c1 	.word	0x000014c1
    1c68:	00002275 	.word	0x00002275
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);
    1c6c:	f505 7207 	add.w	r2, r5, #540	; 0x21c
    1c70:	ab07      	add	r3, sp, #28
    1c72:	cb03      	ldmia	r3!, {r0, r1}
    1c74:	f8c5 021c 	str.w	r0, [r5, #540]	; 0x21c
    1c78:	6051      	str	r1, [r2, #4]
    1c7a:	8819      	ldrh	r1, [r3, #0]
    1c7c:	789b      	ldrb	r3, [r3, #2]
    1c7e:	8111      	strh	r1, [r2, #8]
    1c80:	7293      	strb	r3, [r2, #10]
        if (fatfs_sfn_exists(&_fs, file->parentcluster, (char*)file->shortfilename) == 0)
    1c82:	9205      	str	r2, [sp, #20]
    1c84:	6829      	ldr	r1, [r5, #0]
    1c86:	482f      	ldr	r0, [pc, #188]	; (1d44 <fl_fopen+0x420>)
    1c88:	4b2f      	ldr	r3, [pc, #188]	; (1d48 <fl_fopen+0x424>)
    1c8a:	4798      	blx	r3
    1c8c:	b108      	cbz	r0, 1c92 <fl_fopen+0x36e>
        tailNum++;
    1c8e:	3701      	adds	r7, #1
    1c90:	e78c      	b.n	1bac <fl_fopen+0x288>
    if (tailNum == 9999)
    1c92:	f242 730f 	movw	r3, #9999	; 0x270f
    1c96:	429f      	cmp	r7, r3
    1c98:	d0a1      	beq.n	1bde <fl_fopen+0x2ba>
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
    1c9a:	6829      	ldr	r1, [r5, #0]
    1c9c:	2300      	movs	r3, #0
    1c9e:	9302      	str	r3, [sp, #8]
    1ca0:	9301      	str	r3, [sp, #4]
    1ca2:	686b      	ldr	r3, [r5, #4]
    1ca4:	9300      	str	r3, [sp, #0]
    1ca6:	9b05      	ldr	r3, [sp, #20]
    1ca8:	4652      	mov	r2, sl
    1caa:	4826      	ldr	r0, [pc, #152]	; (1d44 <fl_fopen+0x420>)
    1cac:	4e27      	ldr	r6, [pc, #156]	; (1d4c <fl_fopen+0x428>)
    1cae:	47b0      	blx	r6
    1cb0:	b1f0      	cbz	r0, 1cf0 <fl_fopen+0x3cc>
    file->filelength = 0;
    1cb2:	2300      	movs	r3, #0
    1cb4:	60eb      	str	r3, [r5, #12]
    file->bytenum = 0;
    1cb6:	60ab      	str	r3, [r5, #8]
    file->file_data_address = 0xFFFFFFFF;
    1cb8:	f04f 32ff 	mov.w	r2, #4294967295
    1cbc:	f8c5 2430 	str.w	r2, [r5, #1072]	; 0x430
    file->file_data_dirty = 0;
    1cc0:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434
    file->filelength_changed = 0;
    1cc4:	612b      	str	r3, [r5, #16]
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    1cc6:	f8c5 2228 	str.w	r2, [r5, #552]	; 0x228
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
    1cca:	f8c5 222c 	str.w	r2, [r5, #556]	; 0x22c
    fatfs_cache_init(&_fs, file);
    1cce:	4e1d      	ldr	r6, [pc, #116]	; (1d44 <fl_fopen+0x420>)
    1cd0:	4629      	mov	r1, r5
    1cd2:	4630      	mov	r0, r6
    1cd4:	4b1e      	ldr	r3, [pc, #120]	; (1d50 <fl_fopen+0x42c>)
    1cd6:	4798      	blx	r3
    fatfs_fat_purge(&_fs);
    1cd8:	4630      	mov	r0, r6
    1cda:	4b1e      	ldr	r3, [pc, #120]	; (1d54 <fl_fopen+0x430>)
    1cdc:	4798      	blx	r3
    if (!(flags & FILE_READ))
    1cde:	f1b9 0f00 	cmp.w	r9, #0
    1ce2:	d116      	bne.n	1d12 <fl_fopen+0x3ee>
        if ((flags & FILE_CREATE) && !file)
    1ce4:	b9ad      	cbnz	r5, 1d12 <fl_fopen+0x3ee>
            if (flags & (FILE_WRITE | FILE_APPEND))
    1ce6:	f014 0f06 	tst.w	r4, #6
    1cea:	d10d      	bne.n	1d08 <fl_fopen+0x3e4>
    1cec:	2500      	movs	r5, #0
    1cee:	e012      	b.n	1d16 <fl_fopen+0x3f2>
        fatfs_free_cluster_chain(&_fs, file->startcluster);
    1cf0:	6869      	ldr	r1, [r5, #4]
    1cf2:	4814      	ldr	r0, [pc, #80]	; (1d44 <fl_fopen+0x420>)
    1cf4:	4b18      	ldr	r3, [pc, #96]	; (1d58 <fl_fopen+0x434>)
    1cf6:	4798      	blx	r3
        _free_file(file);
    1cf8:	4628      	mov	r0, r5
    1cfa:	4b18      	ldr	r3, [pc, #96]	; (1d5c <fl_fopen+0x438>)
    1cfc:	4798      	blx	r3
    if (!(flags & FILE_READ))
    1cfe:	f1b9 0f00 	cmp.w	r9, #0
    1d02:	d0f0      	beq.n	1ce6 <fl_fopen+0x3c2>
    1d04:	2500      	movs	r5, #0
    1d06:	e003      	b.n	1d10 <fl_fopen+0x3ec>
                file = _open_file(path);
    1d08:	4640      	mov	r0, r8
    1d0a:	4b15      	ldr	r3, [pc, #84]	; (1d60 <fl_fopen+0x43c>)
    1d0c:	4798      	blx	r3
    1d0e:	4605      	mov	r5, r0
    if (file)
    1d10:	b10d      	cbz	r5, 1d16 <fl_fopen+0x3f2>
        file->flags = flags;
    1d12:	f885 4438 	strb.w	r4, [r5, #1080]	; 0x438
    FL_UNLOCK(&_fs);
    1d16:	4b13      	ldr	r3, [pc, #76]	; (1d64 <fl_fopen+0x440>)
    1d18:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1d1a:	b153      	cbz	r3, 1d32 <fl_fopen+0x40e>
    1d1c:	4798      	blx	r3
    1d1e:	4628      	mov	r0, r5
}
    1d20:	b013      	add	sp, #76	; 0x4c
    1d22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return NULL;
    1d26:	2000      	movs	r0, #0
    1d28:	e7fa      	b.n	1d20 <fl_fopen+0x3fc>
        return NULL;
    1d2a:	2000      	movs	r0, #0
    1d2c:	e7f8      	b.n	1d20 <fl_fopen+0x3fc>
    1d2e:	2000      	movs	r0, #0
    1d30:	e7f6      	b.n	1d20 <fl_fopen+0x3fc>
    1d32:	4628      	mov	r0, r5
    1d34:	e7f4      	b.n	1d20 <fl_fopen+0x3fc>
    if (!(flags & FILE_READ))
    1d36:	2500      	movs	r5, #0
    1d38:	f1b9 0f00 	cmp.w	r9, #0
    1d3c:	d0d2      	beq.n	1ce4 <fl_fopen+0x3c0>
    1d3e:	2500      	movs	r5, #0
    1d40:	e7e9      	b.n	1d16 <fl_fopen+0x3f2>
    1d42:	bf00      	nop
    1d44:	20000478 	.word	0x20000478
    1d48:	000012a5 	.word	0x000012a5
    1d4c:	00002bcd 	.word	0x00002bcd
    1d50:	000013d9 	.word	0x000013d9
    1d54:	000027f1 	.word	0x000027f1
    1d58:	00002a39 	.word	0x00002a39
    1d5c:	0000173d 	.word	0x0000173d
    1d60:	00001781 	.word	0x00001781
    1d64:	20000468 	.word	0x20000468

00001d68 <fl_fflush>:
#endif
//-----------------------------------------------------------------------------
// fl_fflush: Flush un-written data to the file
//-----------------------------------------------------------------------------
int fl_fflush(void *f)
{
    1d68:	b538      	push	{r3, r4, r5, lr}
    1d6a:	4604      	mov	r4, r0
#if FATFS_INC_WRITE_SUPPORT
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
    1d6c:	4b11      	ldr	r3, [pc, #68]	; (1db4 <fl_fflush+0x4c>)
    1d6e:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1d72:	b16b      	cbz	r3, 1d90 <fl_fflush+0x28>

    if (file)
    1d74:	b154      	cbz	r4, 1d8c <fl_fflush+0x24>
    {
        FL_LOCK(&_fs);
    1d76:	4b0f      	ldr	r3, [pc, #60]	; (1db4 <fl_fflush+0x4c>)
    1d78:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1d7a:	b103      	cbz	r3, 1d7e <fl_fflush+0x16>
    1d7c:	4798      	blx	r3

        // If some write data still in buffer
        if (file->file_data_dirty)
    1d7e:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    1d82:	b943      	cbnz	r3, 1d96 <fl_fflush+0x2e>
            // Write back current sector before loading next
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
                file->file_data_dirty = 0;
        }

        FL_UNLOCK(&_fs);
    1d84:	4b0b      	ldr	r3, [pc, #44]	; (1db4 <fl_fflush+0x4c>)
    1d86:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1d88:	b103      	cbz	r3, 1d8c <fl_fflush+0x24>
    1d8a:	4798      	blx	r3
    }
#endif
    return 0;
}
    1d8c:	2000      	movs	r0, #0
    1d8e:	bd38      	pop	{r3, r4, r5, pc}
    CHECK_FL_INIT();
    1d90:	4b09      	ldr	r3, [pc, #36]	; (1db8 <fl_fflush+0x50>)
    1d92:	4798      	blx	r3
    1d94:	e7ee      	b.n	1d74 <fl_fflush+0xc>
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
    1d96:	2301      	movs	r3, #1
    1d98:	f504 720c 	add.w	r2, r4, #560	; 0x230
    1d9c:	f8d4 1430 	ldr.w	r1, [r4, #1072]	; 0x430
    1da0:	4620      	mov	r0, r4
    1da2:	4d06      	ldr	r5, [pc, #24]	; (1dbc <fl_fflush+0x54>)
    1da4:	47a8      	blx	r5
    1da6:	2800      	cmp	r0, #0
    1da8:	d0ec      	beq.n	1d84 <fl_fflush+0x1c>
                file->file_data_dirty = 0;
    1daa:	2300      	movs	r3, #0
    1dac:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
    1db0:	e7e8      	b.n	1d84 <fl_fflush+0x1c>
    1db2:	bf00      	nop
    1db4:	20000468 	.word	0x20000468
    1db8:	000018b9 	.word	0x000018b9
    1dbc:	00001555 	.word	0x00001555

00001dc0 <fl_fclose>:
//-----------------------------------------------------------------------------
// fl_fclose: Close an open file
//-----------------------------------------------------------------------------
void fl_fclose(void *f)
{
    1dc0:	b538      	push	{r3, r4, r5, lr}
    1dc2:	4604      	mov	r4, r0
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
    1dc4:	4b17      	ldr	r3, [pc, #92]	; (1e24 <fl_fclose+0x64>)
    1dc6:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1dca:	b303      	cbz	r3, 1e0e <fl_fclose+0x4e>

    if (file)
    1dcc:	b1f4      	cbz	r4, 1e0c <fl_fclose+0x4c>
    {
        FL_LOCK(&_fs);
    1dce:	4b15      	ldr	r3, [pc, #84]	; (1e24 <fl_fclose+0x64>)
    1dd0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1dd2:	b103      	cbz	r3, 1dd6 <fl_fclose+0x16>
    1dd4:	4798      	blx	r3

        // Flush un-written data to file
        fl_fflush(f);
    1dd6:	4620      	mov	r0, r4
    1dd8:	4b13      	ldr	r3, [pc, #76]	; (1e28 <fl_fclose+0x68>)
    1dda:	4798      	blx	r3

        // File size changed?
        if (file->filelength_changed)
    1ddc:	6923      	ldr	r3, [r4, #16]
    1dde:	b9cb      	cbnz	r3, 1e14 <fl_fclose+0x54>
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
    1de0:	2300      	movs	r3, #0
    1de2:	60a3      	str	r3, [r4, #8]
        file->filelength = 0;
    1de4:	60e3      	str	r3, [r4, #12]
        file->startcluster = 0;
    1de6:	6063      	str	r3, [r4, #4]
        file->file_data_address = 0xFFFFFFFF;
    1de8:	f04f 32ff 	mov.w	r2, #4294967295
    1dec:	f8c4 2430 	str.w	r2, [r4, #1072]	; 0x430
        file->file_data_dirty = 0;
    1df0:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
        file->filelength_changed = 0;
    1df4:	6123      	str	r3, [r4, #16]

        // Free file handle
        _free_file(file);
    1df6:	4620      	mov	r0, r4
    1df8:	4b0c      	ldr	r3, [pc, #48]	; (1e2c <fl_fclose+0x6c>)
    1dfa:	4798      	blx	r3

        fatfs_fat_purge(&_fs);
    1dfc:	4c09      	ldr	r4, [pc, #36]	; (1e24 <fl_fclose+0x64>)
    1dfe:	f104 0010 	add.w	r0, r4, #16
    1e02:	4b0b      	ldr	r3, [pc, #44]	; (1e30 <fl_fclose+0x70>)
    1e04:	4798      	blx	r3

        FL_UNLOCK(&_fs);
    1e06:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    1e08:	b103      	cbz	r3, 1e0c <fl_fclose+0x4c>
    1e0a:	4798      	blx	r3
    1e0c:	bd38      	pop	{r3, r4, r5, pc}
    CHECK_FL_INIT();
    1e0e:	4b09      	ldr	r3, [pc, #36]	; (1e34 <fl_fclose+0x74>)
    1e10:	4798      	blx	r3
    1e12:	e7db      	b.n	1dcc <fl_fclose+0xc>
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
    1e14:	68e3      	ldr	r3, [r4, #12]
    1e16:	f504 7207 	add.w	r2, r4, #540	; 0x21c
    1e1a:	6821      	ldr	r1, [r4, #0]
    1e1c:	4806      	ldr	r0, [pc, #24]	; (1e38 <fl_fclose+0x78>)
    1e1e:	4d07      	ldr	r5, [pc, #28]	; (1e3c <fl_fclose+0x7c>)
    1e20:	47a8      	blx	r5
    1e22:	e7dd      	b.n	1de0 <fl_fclose+0x20>
    1e24:	20000468 	.word	0x20000468
    1e28:	00001d69 	.word	0x00001d69
    1e2c:	0000173d 	.word	0x0000173d
    1e30:	000027f1 	.word	0x000027f1
    1e34:	000018b9 	.word	0x000018b9
    1e38:	20000478 	.word	0x20000478
    1e3c:	0000132d 	.word	0x0000132d

00001e40 <fl_fwrite>:
//-----------------------------------------------------------------------------
// fl_fwrite: Write a block of data to the stream
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fl_fwrite(const void * data, int size, int count, void *f )
{
    1e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1e44:	b085      	sub	sp, #20
    1e46:	4682      	mov	sl, r0
    1e48:	460c      	mov	r4, r1
    1e4a:	4616      	mov	r6, r2
    1e4c:	461d      	mov	r5, r3
    uint8 *buffer = (uint8 *)data;
    uint32 bytesWritten = 0;
    uint32 copyCount;

    // If first call to library, initialise
    CHECK_FL_INIT();
    1e4e:	4b60      	ldr	r3, [pc, #384]	; (1fd0 <fl_fwrite+0x190>)
    1e50:	f8d3 3cfc 	ldr.w	r3, [r3, #3324]	; 0xcfc
    1e54:	b1ab      	cbz	r3, 1e82 <fl_fwrite+0x42>

    if (!file)
    1e56:	2d00      	cmp	r5, #0
    1e58:	f000 80b1 	beq.w	1fbe <fl_fwrite+0x17e>
        return -1;

    FL_LOCK(&_fs);
    1e5c:	4b5c      	ldr	r3, [pc, #368]	; (1fd0 <fl_fwrite+0x190>)
    1e5e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1e60:	b103      	cbz	r3, 1e64 <fl_fwrite+0x24>
    1e62:	4798      	blx	r3

    // No write permissions
    if (!(file->flags & FILE_WRITE))
    1e64:	f895 3438 	ldrb.w	r3, [r5, #1080]	; 0x438
    1e68:	f013 0f02 	tst.w	r3, #2
    1e6c:	d10c      	bne.n	1e88 <fl_fwrite+0x48>
    {
        FL_UNLOCK(&_fs);
    1e6e:	4b58      	ldr	r3, [pc, #352]	; (1fd0 <fl_fwrite+0x190>)
    1e70:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1e72:	2b00      	cmp	r3, #0
    1e74:	f000 80a7 	beq.w	1fc6 <fl_fwrite+0x186>
    1e78:	4798      	blx	r3
        return -1;
    1e7a:	f04f 33ff 	mov.w	r3, #4294967295
    1e7e:	9303      	str	r3, [sp, #12]
    1e80:	e08e      	b.n	1fa0 <fl_fwrite+0x160>
    CHECK_FL_INIT();
    1e82:	4b54      	ldr	r3, [pc, #336]	; (1fd4 <fl_fwrite+0x194>)
    1e84:	4798      	blx	r3
    1e86:	e7e6      	b.n	1e56 <fl_fwrite+0x16>
    uint32 length = (size*count);
    1e88:	fb06 f204 	mul.w	r2, r6, r4
    1e8c:	9203      	str	r2, [sp, #12]
    1e8e:	4691      	mov	r9, r2
    }

    // Append writes to end of file
    if (file->flags & FILE_APPEND)
    1e90:	f013 0f04 	tst.w	r3, #4
    1e94:	d006      	beq.n	1ea4 <fl_fwrite+0x64>
        file->bytenum = file->filelength;
    1e96:	68eb      	ldr	r3, [r5, #12]
    1e98:	60ab      	str	r3, [r5, #8]
    // Else write to current position

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;
    1e9a:	0a5f      	lsrs	r7, r3, #9

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
    1e9c:	f3c3 0808 	ubfx	r8, r3, #0, #9

    while (bytesWritten < length)
    1ea0:	b93a      	cbnz	r2, 1eb2 <fl_fwrite+0x72>
    1ea2:	e079      	b.n	1f98 <fl_fwrite+0x158>
    sector = file->bytenum / FAT_SECTOR_SIZE;
    1ea4:	68ab      	ldr	r3, [r5, #8]
    1ea6:	0a5f      	lsrs	r7, r3, #9
    offset = file->bytenum % FAT_SECTOR_SIZE;
    1ea8:	f3c3 0808 	ubfx	r8, r3, #0, #9
    while (bytesWritten < length)
    1eac:	9b03      	ldr	r3, [sp, #12]
    1eae:	2b00      	cmp	r3, #0
    1eb0:	d06b      	beq.n	1f8a <fl_fwrite+0x14a>
{
    1eb2:	2600      	movs	r6, #0
                file->file_data_address = sector;
                file->file_data_dirty = 0;
            }

            // Copy from application buffer into sector buffer
            memcpy((uint8*)(file->file_data_sector + offset), (uint8*)(buffer + bytesWritten), copyCount);
    1eb4:	f8df b130 	ldr.w	fp, [pc, #304]	; 1fe8 <fl_fwrite+0x1a8>
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);
    1eb8:	9701      	str	r7, [sp, #4]
    1eba:	e03c      	b.n	1f36 <fl_fwrite+0xf6>
                    fl_fflush(file);
    1ebc:	4628      	mov	r0, r5
    1ebe:	4b46      	ldr	r3, [pc, #280]	; (1fd8 <fl_fwrite+0x198>)
    1ec0:	4798      	blx	r3
    1ec2:	e049      	b.n	1f58 <fl_fwrite+0x118>
            copyCount = FAT_SECTOR_SIZE - offset;
    1ec4:	f5c8 7400 	rsb	r4, r8, #512	; 0x200
            if (copyCount > (length - bytesWritten))
    1ec8:	eba9 0306 	sub.w	r3, r9, r6
    1ecc:	429c      	cmp	r4, r3
    1ece:	bf28      	it	cs
    1ed0:	461c      	movcs	r4, r3
            if (file->file_data_address != sector)
    1ed2:	f8d5 3430 	ldr.w	r3, [r5, #1072]	; 0x430
    1ed6:	9a01      	ldr	r2, [sp, #4]
    1ed8:	4293      	cmp	r3, r2
    1eda:	d017      	beq.n	1f0c <fl_fwrite+0xcc>
                if (file->file_data_dirty)
    1edc:	f8d5 3434 	ldr.w	r3, [r5, #1076]	; 0x434
    1ee0:	2b00      	cmp	r3, #0
    1ee2:	d161      	bne.n	1fa8 <fl_fwrite+0x168>
                if (copyCount != FAT_SECTOR_SIZE)
    1ee4:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    1ee8:	d00a      	beq.n	1f00 <fl_fwrite+0xc0>
                    if (!_read_sectors(file, sector, file->file_data_sector, 1))
    1eea:	f505 730c 	add.w	r3, r5, #560	; 0x230
    1eee:	461a      	mov	r2, r3
    1ef0:	9302      	str	r3, [sp, #8]
    1ef2:	2301      	movs	r3, #1
    1ef4:	9901      	ldr	r1, [sp, #4]
    1ef6:	4628      	mov	r0, r5
    1ef8:	4f38      	ldr	r7, [pc, #224]	; (1fdc <fl_fwrite+0x19c>)
    1efa:	47b8      	blx	r7
    1efc:	2800      	cmp	r0, #0
    1efe:	d057      	beq.n	1fb0 <fl_fwrite+0x170>
                file->file_data_address = sector;
    1f00:	9b01      	ldr	r3, [sp, #4]
    1f02:	f8c5 3430 	str.w	r3, [r5, #1072]	; 0x430
                file->file_data_dirty = 0;
    1f06:	2300      	movs	r3, #0
    1f08:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434
            memcpy((uint8*)(file->file_data_sector + offset), (uint8*)(buffer + bytesWritten), copyCount);
    1f0c:	f505 700c 	add.w	r0, r5, #560	; 0x230
    1f10:	4622      	mov	r2, r4
    1f12:	eb0a 0106 	add.w	r1, sl, r6
    1f16:	4440      	add	r0, r8
    1f18:	47d8      	blx	fp

            // Mark buffer as dirty
            file->file_data_dirty = 1;
    1f1a:	2301      	movs	r3, #1
    1f1c:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434

            // Increase total read count
            bytesWritten += copyCount;
    1f20:	4426      	add	r6, r4

            // Increment file pointer
            file->bytenum += copyCount;
    1f22:	68ab      	ldr	r3, [r5, #8]
    1f24:	441c      	add	r4, r3
    1f26:	60ac      	str	r4, [r5, #8]

            // Move onto next sector and reset copy offset
            sector++;
    1f28:	9b01      	ldr	r3, [sp, #4]
    1f2a:	3301      	adds	r3, #1
    1f2c:	9301      	str	r3, [sp, #4]
    1f2e:	f04f 0800 	mov.w	r8, #0
    while (bytesWritten < length)
    1f32:	454e      	cmp	r6, r9
    1f34:	d229      	bcs.n	1f8a <fl_fwrite+0x14a>
        if ((offset == 0) && ((length - bytesWritten) >= FAT_SECTOR_SIZE))
    1f36:	f1b8 0f00 	cmp.w	r8, #0
    1f3a:	d1c3      	bne.n	1ec4 <fl_fwrite+0x84>
    1f3c:	eba9 0406 	sub.w	r4, r9, r6
    1f40:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    1f44:	d3be      	bcc.n	1ec4 <fl_fwrite+0x84>
            if (file->file_data_address != 0xFFFFFFFF)
    1f46:	f8d5 3430 	ldr.w	r3, [r5, #1072]	; 0x430
    1f4a:	f1b3 3fff 	cmp.w	r3, #4294967295
    1f4e:	d00a      	beq.n	1f66 <fl_fwrite+0x126>
                if (file->file_data_dirty)
    1f50:	f8d5 3434 	ldr.w	r3, [r5, #1076]	; 0x434
    1f54:	2b00      	cmp	r3, #0
    1f56:	d1b1      	bne.n	1ebc <fl_fwrite+0x7c>
                file->file_data_address = 0xFFFFFFFF;
    1f58:	f04f 33ff 	mov.w	r3, #4294967295
    1f5c:	f8c5 3430 	str.w	r3, [r5, #1072]	; 0x430
                file->file_data_dirty = 0;
    1f60:	2300      	movs	r3, #0
    1f62:	f8c5 3434 	str.w	r3, [r5, #1076]	; 0x434
            sectorsWrote = _write_sectors(file, sector, (uint8*)(buffer + bytesWritten), (length - bytesWritten) / FAT_SECTOR_SIZE);
    1f66:	0a63      	lsrs	r3, r4, #9
    1f68:	eb0a 0206 	add.w	r2, sl, r6
    1f6c:	9f01      	ldr	r7, [sp, #4]
    1f6e:	4639      	mov	r1, r7
    1f70:	4628      	mov	r0, r5
    1f72:	4c1b      	ldr	r4, [pc, #108]	; (1fe0 <fl_fwrite+0x1a0>)
    1f74:	47a0      	blx	r4
            copyCount = FAT_SECTOR_SIZE * sectorsWrote;
    1f76:	0242      	lsls	r2, r0, #9
            bytesWritten += copyCount;
    1f78:	4416      	add	r6, r2
            file->bytenum += copyCount;
    1f7a:	68ab      	ldr	r3, [r5, #8]
    1f7c:	4413      	add	r3, r2
    1f7e:	60ab      	str	r3, [r5, #8]
            sector+= sectorsWrote;
    1f80:	463b      	mov	r3, r7
    1f82:	4403      	add	r3, r0
    1f84:	9301      	str	r3, [sp, #4]
            if (!sectorsWrote)
    1f86:	2800      	cmp	r0, #0
    1f88:	d1d1      	bne.n	1f2e <fl_fwrite+0xee>
            offset = 0;
        }
    }

    // Write increased extent of the file?
    if (file->bytenum > file->filelength)
    1f8a:	68ab      	ldr	r3, [r5, #8]
    1f8c:	68ea      	ldr	r2, [r5, #12]
    1f8e:	4293      	cmp	r3, r2
    1f90:	d902      	bls.n	1f98 <fl_fwrite+0x158>
    {
        // Increase file size to new point
        file->filelength = file->bytenum;
    1f92:	60eb      	str	r3, [r5, #12]

        // We are changing the file length and this
        // will need to be writen back at some point
        file->filelength_changed = 1;
    1f94:	2301      	movs	r3, #1
    1f96:	612b      	str	r3, [r5, #16]
    // If time & date support is enabled, always force directory entry to be
    // written in-order to update file modify / access time & date.
    file->filelength_changed = 1;
#endif

    FL_UNLOCK(&_fs);
    1f98:	4b0d      	ldr	r3, [pc, #52]	; (1fd0 <fl_fwrite+0x190>)
    1f9a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1f9c:	b103      	cbz	r3, 1fa0 <fl_fwrite+0x160>
    1f9e:	4798      	blx	r3

    return (size*count);
}
    1fa0:	9803      	ldr	r0, [sp, #12]
    1fa2:	b005      	add	sp, #20
    1fa4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    fl_fflush(file);
    1fa8:	4628      	mov	r0, r5
    1faa:	4b0b      	ldr	r3, [pc, #44]	; (1fd8 <fl_fwrite+0x198>)
    1fac:	4798      	blx	r3
    1fae:	e799      	b.n	1ee4 <fl_fwrite+0xa4>
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);
    1fb0:	f44f 7200 	mov.w	r2, #512	; 0x200
    1fb4:	2100      	movs	r1, #0
    1fb6:	9802      	ldr	r0, [sp, #8]
    1fb8:	4b0a      	ldr	r3, [pc, #40]	; (1fe4 <fl_fwrite+0x1a4>)
    1fba:	4798      	blx	r3
    1fbc:	e7a0      	b.n	1f00 <fl_fwrite+0xc0>
        return -1;
    1fbe:	f04f 33ff 	mov.w	r3, #4294967295
    1fc2:	9303      	str	r3, [sp, #12]
    1fc4:	e7ec      	b.n	1fa0 <fl_fwrite+0x160>
        return -1;
    1fc6:	f04f 33ff 	mov.w	r3, #4294967295
    1fca:	9303      	str	r3, [sp, #12]
    1fcc:	e7e8      	b.n	1fa0 <fl_fwrite+0x160>
    1fce:	bf00      	nop
    1fd0:	20000468 	.word	0x20000468
    1fd4:	000018b9 	.word	0x000018b9
    1fd8:	00001d69 	.word	0x00001d69
    1fdc:	00001661 	.word	0x00001661
    1fe0:	00001555 	.word	0x00001555
    1fe4:	00003a71 	.word	0x00003a71
    1fe8:	0000393d 	.word	0x0000393d

00001fec <fatfs_lfn_cache_init>:
//-----------------------------------------------------------------------------
void fatfs_lfn_cache_init(struct lfn_cache *lfn, int wipeTable)
{
    int i = 0;

    lfn->no_of_strings = 0;
    1fec:	2300      	movs	r3, #0
    1fee:	f880 3105 	strb.w	r3, [r0, #261]	; 0x105

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
    1ff2:	b151      	cbz	r1, 200a <fatfs_lfn_cache_init+0x1e>
    1ff4:	4603      	mov	r3, r0
    1ff6:	f500 7082 	add.w	r0, r0, #260	; 0x104
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
            memset(lfn->String[i], 0x00, MAX_LFN_ENTRY_LENGTH);
    1ffa:	2200      	movs	r2, #0
    1ffc:	601a      	str	r2, [r3, #0]
    1ffe:	605a      	str	r2, [r3, #4]
    2000:	609a      	str	r2, [r3, #8]
    2002:	731a      	strb	r2, [r3, #12]
    2004:	330d      	adds	r3, #13
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
    2006:	4283      	cmp	r3, r0
    2008:	d1f8      	bne.n	1ffc <fatfs_lfn_cache_init+0x10>
    200a:	4770      	bx	lr

0000200c <fatfs_lfn_cache_entry>:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;
    200c:	780b      	ldrb	r3, [r1, #0]
    200e:	f003 031f 	and.w	r3, r3, #31
    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
        return ;

    // This is an error condition
    if (LFNIndex == 0)
    2012:	1e5a      	subs	r2, r3, #1
    2014:	b2d2      	uxtb	r2, r2
    2016:	2a13      	cmp	r2, #19
    2018:	d830      	bhi.n	207c <fatfs_lfn_cache_entry+0x70>
{
    201a:	b410      	push	{r4}
        return ;

    if (lfn->no_of_strings == 0)
    201c:	f890 2105 	ldrb.w	r2, [r0, #261]	; 0x105
    2020:	b90a      	cbnz	r2, 2026 <fatfs_lfn_cache_entry+0x1a>
        lfn->no_of_strings = LFNIndex;
    2022:	f880 3105 	strb.w	r3, [r0, #261]	; 0x105

    lfn->String[LFNIndex-1][0] = entryBuffer[1];
    2026:	3b01      	subs	r3, #1
    2028:	784c      	ldrb	r4, [r1, #1]
    202a:	eb03 0243 	add.w	r2, r3, r3, lsl #1
    202e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    2032:	1883      	adds	r3, r0, r2
    2034:	5484      	strb	r4, [r0, r2]
    lfn->String[LFNIndex-1][1] = entryBuffer[3];
    2036:	78cc      	ldrb	r4, [r1, #3]
    2038:	705c      	strb	r4, [r3, #1]
    lfn->String[LFNIndex-1][2] = entryBuffer[5];
    203a:	794c      	ldrb	r4, [r1, #5]
    203c:	709c      	strb	r4, [r3, #2]
    lfn->String[LFNIndex-1][3] = entryBuffer[7];
    203e:	79cc      	ldrb	r4, [r1, #7]
    2040:	70dc      	strb	r4, [r3, #3]
    lfn->String[LFNIndex-1][4] = entryBuffer[9];
    2042:	7a4c      	ldrb	r4, [r1, #9]
    2044:	711c      	strb	r4, [r3, #4]
    lfn->String[LFNIndex-1][5] = entryBuffer[0x0E];
    2046:	7b8c      	ldrb	r4, [r1, #14]
    2048:	715c      	strb	r4, [r3, #5]
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
    204a:	7c0c      	ldrb	r4, [r1, #16]
    204c:	719c      	strb	r4, [r3, #6]
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    204e:	7c8c      	ldrb	r4, [r1, #18]
    2050:	71dc      	strb	r4, [r3, #7]
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    2052:	7d0c      	ldrb	r4, [r1, #20]
    2054:	721c      	strb	r4, [r3, #8]
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    2056:	7d8c      	ldrb	r4, [r1, #22]
    2058:	725c      	strb	r4, [r3, #9]
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];
    205a:	7e0c      	ldrb	r4, [r1, #24]
    205c:	729c      	strb	r4, [r3, #10]
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    205e:	7f0c      	ldrb	r4, [r1, #28]
    2060:	72dc      	strb	r4, [r3, #11]
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
    2062:	7f89      	ldrb	r1, [r1, #30]
    2064:	7319      	strb	r1, [r3, #12]
    2066:	320d      	adds	r2, #13
    2068:	4410      	add	r0, r2

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF)
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
    206a:	2120      	movs	r1, #32
        if (lfn->String[LFNIndex-1][i]==0xFF)
    206c:	781a      	ldrb	r2, [r3, #0]
    206e:	2aff      	cmp	r2, #255	; 0xff
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
    2070:	bf08      	it	eq
    2072:	7019      	strbeq	r1, [r3, #0]
    2074:	3301      	adds	r3, #1
    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
    2076:	4283      	cmp	r3, r0
    2078:	d1f8      	bne.n	206c <fatfs_lfn_cache_entry+0x60>
}
    207a:	bc10      	pop	{r4}
    207c:	4770      	bx	lr

0000207e <fatfs_lfn_cache_get>:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
    207e:	f890 3105 	ldrb.w	r3, [r0, #261]	; 0x105
    2082:	2b14      	cmp	r3, #20
    2084:	d003      	beq.n	208e <fatfs_lfn_cache_get+0x10>
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
    2086:	b933      	cbnz	r3, 2096 <fatfs_lfn_cache_get+0x18>
        lfn->String[lfn->no_of_strings][0] = '\0';
    else
        lfn->String[0][0] = '\0';
    2088:	2300      	movs	r3, #0
    208a:	7003      	strb	r3, [r0, #0]

    return (char*)&lfn->String[0][0];
}
    208c:	4770      	bx	lr
        lfn->Null = '\0';
    208e:	2300      	movs	r3, #0
    2090:	f880 3104 	strb.w	r3, [r0, #260]	; 0x104
    2094:	4770      	bx	lr
        lfn->String[lfn->no_of_strings][0] = '\0';
    2096:	eb03 0243 	add.w	r2, r3, r3, lsl #1
    209a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    209e:	2200      	movs	r2, #0
    20a0:	54c2      	strb	r2, [r0, r3]
    20a2:	4770      	bx	lr

000020a4 <fatfs_entry_lfn_text>:
// fatfs_entry_lfn_text: If LFN text entry found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_text(struct fat_dir_entry *entry)
{
    if ((entry->Attr & FILE_ATTR_LFN_TEXT) == FILE_ATTR_LFN_TEXT)
    20a4:	7ac0      	ldrb	r0, [r0, #11]
    20a6:	f000 000f 	and.w	r0, r0, #15
        return 1;
    else
        return 0;
}
    20aa:	280f      	cmp	r0, #15
    20ac:	bf14      	ite	ne
    20ae:	2000      	movne	r0, #0
    20b0:	2001      	moveq	r0, #1
    20b2:	4770      	bx	lr

000020b4 <fatfs_entry_lfn_invalid>:
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  ||
    20b4:	7803      	ldrb	r3, [r0, #0]
    20b6:	b153      	cbz	r3, 20ce <fatfs_entry_lfn_invalid+0x1a>
    20b8:	2be5      	cmp	r3, #229	; 0xe5
    20ba:	d00a      	beq.n	20d2 <fatfs_entry_lfn_invalid+0x1e>
         (entry->Name[0]==FILE_HEADER_DELETED)||
         (entry->Attr==FILE_ATTR_VOLUME_ID) ||
    20bc:	7ac3      	ldrb	r3, [r0, #11]
         (entry->Name[0]==FILE_HEADER_DELETED)||
    20be:	2b08      	cmp	r3, #8
    20c0:	d009      	beq.n	20d6 <fatfs_entry_lfn_invalid+0x22>
         (entry->Attr==FILE_ATTR_VOLUME_ID) ||
    20c2:	f013 0f06 	tst.w	r3, #6
    20c6:	bf14      	ite	ne
    20c8:	2001      	movne	r0, #1
    20ca:	2000      	moveq	r0, #0
    20cc:	4770      	bx	lr
         (entry->Attr & FILE_ATTR_SYSHID) )
        return 1;
    20ce:	2001      	movs	r0, #1
    20d0:	4770      	bx	lr
    20d2:	2001      	movs	r0, #1
    20d4:	4770      	bx	lr
    20d6:	2001      	movs	r0, #1
    else
        return 0;
}
    20d8:	4770      	bx	lr

000020da <fatfs_entry_lfn_exists>:
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    20da:	7acb      	ldrb	r3, [r1, #11]
    20dc:	2b0f      	cmp	r3, #15
    20de:	d00e      	beq.n	20fe <fatfs_entry_lfn_exists+0x24>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    20e0:	780a      	ldrb	r2, [r1, #0]
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    20e2:	b172      	cbz	r2, 2102 <fatfs_entry_lfn_exists+0x28>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    20e4:	2ae5      	cmp	r2, #229	; 0xe5
    20e6:	d00e      	beq.n	2106 <fatfs_entry_lfn_exists+0x2c>
         (entry->Name[0]!=FILE_HEADER_DELETED) &&
    20e8:	2b08      	cmp	r3, #8
    20ea:	d00e      	beq.n	210a <fatfs_entry_lfn_exists+0x30>
         (entry->Attr!=FILE_ATTR_VOLUME_ID) &&
    20ec:	f013 0f06 	tst.w	r3, #6
    20f0:	d10d      	bne.n	210e <fatfs_entry_lfn_exists+0x34>
         (!(entry->Attr&FILE_ATTR_SYSHID)) &&
    20f2:	f890 0105 	ldrb.w	r0, [r0, #261]	; 0x105
    20f6:	3000      	adds	r0, #0
    20f8:	bf18      	it	ne
    20fa:	2001      	movne	r0, #1
    20fc:	4770      	bx	lr
         (lfn->no_of_strings) )
        return 1;
    else
        return 0;
    20fe:	2000      	movs	r0, #0
    2100:	4770      	bx	lr
    2102:	2000      	movs	r0, #0
    2104:	4770      	bx	lr
    2106:	2000      	movs	r0, #0
    2108:	4770      	bx	lr
    210a:	2000      	movs	r0, #0
    210c:	4770      	bx	lr
    210e:	2000      	movs	r0, #0
}
    2110:	4770      	bx	lr

00002112 <fatfs_entry_sfn_only>:
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    2112:	7ac3      	ldrb	r3, [r0, #11]
    2114:	2b0f      	cmp	r3, #15
    2116:	d00b      	beq.n	2130 <fatfs_entry_sfn_only+0x1e>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    2118:	7802      	ldrb	r2, [r0, #0]
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) &&
    211a:	b15a      	cbz	r2, 2134 <fatfs_entry_sfn_only+0x22>
         (entry->Name[0]!=FILE_HEADER_BLANK) &&
    211c:	2ae5      	cmp	r2, #229	; 0xe5
    211e:	d00b      	beq.n	2138 <fatfs_entry_sfn_only+0x26>
         (entry->Name[0]!=FILE_HEADER_DELETED) &&
    2120:	2b08      	cmp	r3, #8
    2122:	d00b      	beq.n	213c <fatfs_entry_sfn_only+0x2a>
         (entry->Attr!=FILE_ATTR_VOLUME_ID) &&
    2124:	f013 0f06 	tst.w	r3, #6
    2128:	bf0c      	ite	eq
    212a:	2001      	moveq	r0, #1
    212c:	2000      	movne	r0, #0
    212e:	4770      	bx	lr
         (!(entry->Attr&FILE_ATTR_SYSHID)) )
        return 1;
    else
        return 0;
    2130:	2000      	movs	r0, #0
    2132:	4770      	bx	lr
    2134:	2000      	movs	r0, #0
    2136:	4770      	bx	lr
    2138:	2000      	movs	r0, #0
    213a:	4770      	bx	lr
    213c:	2000      	movs	r0, #0
}
    213e:	4770      	bx	lr

00002140 <fatfs_entry_is_dir>:
//-----------------------------------------------------------------------------
// fatfs_entry_is_dir: Returns 1 if a directory
//-----------------------------------------------------------------------------
int fatfs_entry_is_dir(struct fat_dir_entry *entry)
{
    if (entry->Attr & FILE_TYPE_DIR)
    2140:	7ac0      	ldrb	r0, [r0, #11]
        return 1;
    else
        return 0;
}
    2142:	f3c0 1000 	ubfx	r0, r0, #4, #1
    2146:	4770      	bx	lr

00002148 <fatfs_entry_is_file>:
//-----------------------------------------------------------------------------
// fatfs_entry_is_file: Returns 1 is a file entry
//-----------------------------------------------------------------------------
int fatfs_entry_is_file(struct fat_dir_entry *entry)
{
    if (entry->Attr & FILE_TYPE_FILE)
    2148:	7ac0      	ldrb	r0, [r0, #11]
        return 1;
    else
        return 0;
}
    214a:	f3c0 1040 	ubfx	r0, r0, #5, #1
    214e:	4770      	bx	lr

00002150 <fatfs_lfn_entries_required>:
//-----------------------------------------------------------------------------
// fatfs_lfn_entries_required: Calculate number of 13 characters entries
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_lfn_entries_required(char *filename)
{
    2150:	b508      	push	{r3, lr}
    int length = (int)strlen(filename);
    2152:	4b06      	ldr	r3, [pc, #24]	; (216c <fatfs_lfn_entries_required+0x1c>)
    2154:	4798      	blx	r3
    2156:	4603      	mov	r3, r0

    if (length)
    2158:	b130      	cbz	r0, 2168 <fatfs_lfn_entries_required+0x18>
        return (length + MAX_LFN_ENTRY_LENGTH - 1) / MAX_LFN_ENTRY_LENGTH;
    215a:	300c      	adds	r0, #12
    215c:	4b04      	ldr	r3, [pc, #16]	; (2170 <fatfs_lfn_entries_required+0x20>)
    215e:	fb83 2300 	smull	r2, r3, r3, r0
    2162:	17c0      	asrs	r0, r0, #31
    2164:	ebc0 03a3 	rsb	r3, r0, r3, asr #2
    else
        return 0;
}
    2168:	4618      	mov	r0, r3
    216a:	bd08      	pop	{r3, pc}
    216c:	00003c01 	.word	0x00003c01
    2170:	4ec4ec4f 	.word	0x4ec4ec4f

00002174 <fatfs_filename_to_lfn>:
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
    2174:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2178:	b08e      	sub	sp, #56	; 0x38
    217a:	4606      	mov	r6, r0
    217c:	460c      	mov	r4, r1
    217e:	4690      	mov	r8, r2
    2180:	4699      	mov	r9, r3
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
    2182:	ad01      	add	r5, sp, #4
    2184:	4f24      	ldr	r7, [pc, #144]	; (2218 <fatfs_filename_to_lfn+0xa4>)
    2186:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    2188:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    218a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    218c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    218e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    2190:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2192:	683b      	ldr	r3, [r7, #0]
    2194:	602b      	str	r3, [r5, #0]

    // 13 characters entries
    int length = (int)strlen(filename);
    2196:	4630      	mov	r0, r6
    2198:	4b20      	ldr	r3, [pc, #128]	; (221c <fatfs_filename_to_lfn+0xa8>)
    219a:	4798      	blx	r3
    219c:	4605      	mov	r5, r0
    int entriesRequired = fatfs_lfn_entries_required(filename);
    219e:	4630      	mov	r0, r6
    21a0:	4b1f      	ldr	r3, [pc, #124]	; (2220 <fatfs_filename_to_lfn+0xac>)
    21a2:	4798      	blx	r3
    21a4:	4682      	mov	sl, r0

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
    21a6:	eb08 0048 	add.w	r0, r8, r8, lsl #1
    21aa:	eb08 0780 	add.w	r7, r8, r0, lsl #2

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
    21ae:	2220      	movs	r2, #32
    21b0:	2100      	movs	r1, #0
    21b2:	4620      	mov	r0, r4
    21b4:	4b1b      	ldr	r3, [pc, #108]	; (2224 <fatfs_filename_to_lfn+0xb0>)
    21b6:	4798      	blx	r3

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
    21b8:	f10a 3aff 	add.w	sl, sl, #4294967295
    21bc:	45d0      	cmp	r8, sl
    21be:	f108 0801 	add.w	r8, r8, #1
    21c2:	bf08      	it	eq
    21c4:	f048 0840 	orreq.w	r8, r8, #64	; 0x40
    21c8:	fa5f f888 	uxtb.w	r8, r8
    21cc:	f884 8000 	strb.w	r8, [r4]

    // LFN flag
    buffer[11] = 0x0F;
    21d0:	230f      	movs	r3, #15
    21d2:	72e3      	strb	r3, [r4, #11]

    // Checksum of short filename
    buffer[13] = sfnChk;
    21d4:	f884 900d 	strb.w	r9, [r4, #13]
    21d8:	463b      	mov	r3, r7
    21da:	aa01      	add	r2, sp, #4
    21dc:	f107 000d 	add.w	r0, r7, #13
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
    21e0:	27ff      	movs	r7, #255	; 0xff
            buffer[nameIndexes[i]] = 0x00;
    21e2:	f04f 0c00 	mov.w	ip, #0
    21e6:	e00b      	b.n	2200 <fatfs_filename_to_lfn+0x8c>
        else if ( (start+i) == length )
    21e8:	429d      	cmp	r5, r3
            buffer[nameIndexes[i]] = 0x00;
    21ea:	6811      	ldr	r1, [r2, #0]
    21ec:	bf0f      	iteee	eq
    21ee:	f804 c001 	strbeq.w	ip, [r4, r1]
            buffer[nameIndexes[i]] = 0xFF;
    21f2:	5467      	strbne	r7, [r4, r1]
            buffer[nameIndexes[i]+1] = 0xFF;
    21f4:	1909      	addne	r1, r1, r4
    21f6:	704f      	strbne	r7, [r1, #1]
    21f8:	3301      	adds	r3, #1
    21fa:	3204      	adds	r2, #4
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    21fc:	4283      	cmp	r3, r0
    21fe:	d007      	beq.n	2210 <fatfs_filename_to_lfn+0x9c>
        if ( (start+i) < length )
    2200:	429d      	cmp	r5, r3
    2202:	ddf1      	ble.n	21e8 <fatfs_filename_to_lfn+0x74>
            buffer[nameIndexes[i]] = filename[start+i];
    2204:	f816 e003 	ldrb.w	lr, [r6, r3]
    2208:	6811      	ldr	r1, [r2, #0]
    220a:	f804 e001 	strb.w	lr, [r4, r1]
    220e:	e7f3      	b.n	21f8 <fatfs_filename_to_lfn+0x84>
        }
    }
}
    2210:	b00e      	add	sp, #56	; 0x38
    2212:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2216:	bf00      	nop
    2218:	00003f20 	.word	0x00003f20
    221c:	00003c01 	.word	0x00003c01
    2220:	00002151 	.word	0x00002151
    2224:	00003a71 	.word	0x00003a71

00002228 <fatfs_sfn_create_entry>:
//-----------------------------------------------------------------------------
// fatfs_sfn_create_entry: Create the short filename directory entry
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
{
    2228:	b4f0      	push	{r4, r5, r6, r7}
    222a:	9f04      	ldr	r7, [sp, #16]
    222c:	1e44      	subs	r4, r0, #1
    222e:	1e5d      	subs	r5, r3, #1
    2230:	300a      	adds	r0, #10
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];
    2232:	f814 6f01 	ldrb.w	r6, [r4, #1]!
    2236:	f805 6f01 	strb.w	r6, [r5, #1]!
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
    223a:	4284      	cmp	r4, r0
    223c:	d1f9      	bne.n	2232 <fatfs_sfn_create_entry+0xa>

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    223e:	2000      	movs	r0, #0
    2240:	7358      	strb	r0, [r3, #13]
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    2242:	7398      	strb	r0, [r3, #14]
    2244:	73d8      	strb	r0, [r3, #15]
    entry->CrtDate[1] = 0x00;
    2246:	7458      	strb	r0, [r3, #17]
    entry->CrtDate[0] = 0x20;
    2248:	2420      	movs	r4, #32
    224a:	741c      	strb	r4, [r3, #16]
    entry->LstAccDate[1] = 0x00;
    224c:	74d8      	strb	r0, [r3, #19]
    entry->LstAccDate[0] = 0x20;
    224e:	749c      	strb	r4, [r3, #18]
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    2250:	7598      	strb	r0, [r3, #22]
    2252:	75d8      	strb	r0, [r3, #23]
    entry->WrtDate[1] = 0x00;
    2254:	7658      	strb	r0, [r3, #25]
    entry->WrtDate[0] = 0x20;
    2256:	761c      	strb	r4, [r3, #24]

    if (!dir)
    2258:	b14f      	cbz	r7, 226e <fatfs_sfn_create_entry+0x46>
        entry->Attr = FILE_TYPE_FILE;
    else
        entry->Attr = FILE_TYPE_DIR;
    225a:	2010      	movs	r0, #16
    225c:	72d8      	strb	r0, [r3, #11]

    entry->NTRes = 0x00;
    225e:	2000      	movs	r0, #0
    2260:	7318      	strb	r0, [r3, #12]

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    2262:	0c10      	lsrs	r0, r2, #16
    2264:	8298      	strh	r0, [r3, #20]
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
    2266:	835a      	strh	r2, [r3, #26]
    entry->FileSize = FAT_HTONL(size);
    2268:	61d9      	str	r1, [r3, #28]
}
    226a:	bcf0      	pop	{r4, r5, r6, r7}
    226c:	4770      	bx	lr
        entry->Attr = FILE_TYPE_FILE;
    226e:	72dc      	strb	r4, [r3, #11]
    2270:	e7f5      	b.n	225e <fatfs_sfn_create_entry+0x36>
	...

00002274 <fatfs_lfn_create_sfn>:
//-----------------------------------------------------------------------------
// fatfs_lfn_create_sfn: Create a padded SFN
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_create_sfn(char *sfn_output, char *filename)
{
    2274:	b5f0      	push	{r4, r5, r6, r7, lr}
    2276:	b083      	sub	sp, #12
    2278:	4606      	mov	r6, r0
    227a:	460c      	mov	r4, r1
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
    227c:	4608      	mov	r0, r1
    227e:	4b31      	ldr	r3, [pc, #196]	; (2344 <fatfs_lfn_create_sfn+0xd0>)
    2280:	4798      	blx	r3

    // Invalid to start with .
    if (filename[0]=='.')
    2282:	7823      	ldrb	r3, [r4, #0]
    2284:	2b2e      	cmp	r3, #46	; 0x2e
    2286:	d058      	beq.n	233a <fatfs_lfn_create_sfn+0xc6>
    int len = (int)strlen(filename);
    2288:	4605      	mov	r5, r0
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
    228a:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
    228e:	6033      	str	r3, [r6, #0]
    2290:	6073      	str	r3, [r6, #4]
    2292:	f8c6 3007 	str.w	r3, [r6, #7]
    memset(ext, ' ', 3);
    2296:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    229a:	f8ad 3004 	strh.w	r3, [sp, #4]
    229e:	f88d 3006 	strb.w	r3, [sp, #6]

    // Find dot seperator
    for (i = 0; i< len; i++)
    22a2:	2800      	cmp	r0, #0
    22a4:	dd36      	ble.n	2314 <fatfs_lfn_create_sfn+0xa0>
    22a6:	1e61      	subs	r1, r4, #1
    22a8:	f04f 32ff 	mov.w	r2, #4294967295
    22ac:	2300      	movs	r3, #0
    {
        if (filename[i]=='.')
    22ae:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    22b2:	282e      	cmp	r0, #46	; 0x2e
    22b4:	bf08      	it	eq
    22b6:	461a      	moveq	r2, r3
    for (i = 0; i< len; i++)
    22b8:	3301      	adds	r3, #1
    22ba:	429d      	cmp	r5, r3
    22bc:	d1f7      	bne.n	22ae <fatfs_lfn_create_sfn+0x3a>
            dotPos = i;
    }

    // Extract extensions
    if (dotPos!=-1)
    22be:	f1b2 3fff 	cmp.w	r2, #4294967295
    22c2:	d03c      	beq.n	233e <fatfs_lfn_create_sfn+0xca>
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
    22c4:	1c51      	adds	r1, r2, #1
    22c6:	1d10      	adds	r0, r2, #4
    22c8:	4281      	cmp	r1, r0
    22ca:	da09      	bge.n	22e0 <fatfs_lfn_create_sfn+0x6c>
    22cc:	a801      	add	r0, sp, #4
    22ce:	1d15      	adds	r5, r2, #4
            if (i<len)
    22d0:	428b      	cmp	r3, r1
                ext[i-(dotPos+1)] = filename[i];
    22d2:	bfc4      	itt	gt
    22d4:	5c67      	ldrbgt	r7, [r4, r1]
    22d6:	7007      	strbgt	r7, [r0, #0]
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
    22d8:	3101      	adds	r1, #1
    22da:	3001      	adds	r0, #1
    22dc:	42a9      	cmp	r1, r5
    22de:	d1f7      	bne.n	22d0 <fatfs_lfn_create_sfn+0x5c>
        len = dotPos;
    }

    // Add filename part
    pos = 0;
    for (i=0;i<len;i++)
    22e0:	2a00      	cmp	r2, #0
    22e2:	dd17      	ble.n	2314 <fatfs_lfn_create_sfn+0xa0>
    22e4:	1e61      	subs	r1, r4, #1
    int len = (int)strlen(filename);
    22e6:	2500      	movs	r5, #0
    22e8:	462c      	mov	r4, r5
    22ea:	e004      	b.n	22f6 <fatfs_lfn_create_sfn+0x82>
            else
                sfn_output[pos++] = filename[i];
        }

        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
    22ec:	2d08      	cmp	r5, #8
    22ee:	d011      	beq.n	2314 <fatfs_lfn_create_sfn+0xa0>
    for (i=0;i<len;i++)
    22f0:	3401      	adds	r4, #1
    22f2:	4294      	cmp	r4, r2
    22f4:	da0e      	bge.n	2314 <fatfs_lfn_create_sfn+0xa0>
        if ( (filename[i]!=' ') && (filename[i]!='.') )
    22f6:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    22fa:	2b20      	cmp	r3, #32
    22fc:	d0f6      	beq.n	22ec <fatfs_lfn_create_sfn+0x78>
    22fe:	2b2e      	cmp	r3, #46	; 0x2e
    2300:	d0f4      	beq.n	22ec <fatfs_lfn_create_sfn+0x78>
            if (filename[i] >= 'a' && filename[i] <= 'z')
    2302:	f1a3 0061 	sub.w	r0, r3, #97	; 0x61
    2306:	b2c0      	uxtb	r0, r0
    2308:	2819      	cmp	r0, #25
                sfn_output[pos++] = filename[i] - 'a' + 'A';
    230a:	bf98      	it	ls
    230c:	3b20      	subls	r3, #32
                sfn_output[pos++] = filename[i];
    230e:	5573      	strb	r3, [r6, r5]
    2310:	3501      	adds	r5, #1
    2312:	e7eb      	b.n	22ec <fatfs_lfn_create_sfn+0x78>
    2314:	a801      	add	r0, sp, #4
    2316:	f106 0308 	add.w	r3, r6, #8
    231a:	360b      	adds	r6, #11
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
    231c:	f810 2b01 	ldrb.w	r2, [r0], #1
    2320:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
    2324:	b2c9      	uxtb	r1, r1
    2326:	2919      	cmp	r1, #25
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
    2328:	bf98      	it	ls
    232a:	3a20      	subls	r2, #32
        else
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL];
    232c:	701a      	strb	r2, [r3, #0]
    232e:	3301      	adds	r3, #1
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    2330:	42b3      	cmp	r3, r6
    2332:	d1f3      	bne.n	231c <fatfs_lfn_create_sfn+0xa8>
    }

    return 1;
    2334:	2001      	movs	r0, #1
}
    2336:	b003      	add	sp, #12
    2338:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 0;
    233a:	2000      	movs	r0, #0
    233c:	e7fb      	b.n	2336 <fatfs_lfn_create_sfn+0xc2>
    int len = (int)strlen(filename);
    233e:	461a      	mov	r2, r3
    2340:	e7d0      	b.n	22e4 <fatfs_lfn_create_sfn+0x70>
    2342:	bf00      	nop
    2344:	00003c01 	.word	0x00003c01

00002348 <fatfs_lfn_generate_tail>:
int fatfs_lfn_generate_tail(char *sfn_output, char *sfn_input, uint32 tailNum)
{
    int tail_chars;
    char tail_str[12];

    if (tailNum > 99999)
    2348:	4b2b      	ldr	r3, [pc, #172]	; (23f8 <fatfs_lfn_generate_tail+0xb0>)
    234a:	429a      	cmp	r2, r3
    234c:	d901      	bls.n	2352 <fatfs_lfn_generate_tail+0xa>
        return 0;
    234e:	2000      	movs	r0, #0
    2350:	4770      	bx	lr
{
    2352:	b5f0      	push	{r4, r5, r6, r7, lr}
    2354:	b08d      	sub	sp, #52	; 0x34
    2356:	4605      	mov	r5, r0
    2358:	460e      	mov	r6, r1
    235a:	4614      	mov	r4, r2

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str));
    235c:	2300      	movs	r3, #0
    235e:	9309      	str	r3, [sp, #36]	; 0x24
    2360:	930a      	str	r3, [sp, #40]	; 0x28
    2362:	930b      	str	r3, [sp, #44]	; 0x2c
    tail_str[0] = '~';
    2364:	237e      	movs	r3, #126	; 0x7e
    2366:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    const char digits[] = "0123456789ABCDEF";
    236a:	af04      	add	r7, sp, #16
    236c:	f8df e098 	ldr.w	lr, [pc, #152]	; 2408 <fatfs_lfn_generate_tail+0xc0>
    2370:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2374:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    2376:	f8de 3000 	ldr.w	r3, [lr]
    237a:	703b      	strb	r3, [r7, #0]
    cp = outbuf;
    237c:	a801      	add	r0, sp, #4
        *cp++ = digits[(int)(num % 10)];
    237e:	4f1f      	ldr	r7, [pc, #124]	; (23fc <fatfs_lfn_generate_tail+0xb4>)
    2380:	e000      	b.n	2384 <fatfs_lfn_generate_tail+0x3c>
    2382:	4608      	mov	r0, r1
    2384:	4601      	mov	r1, r0
    2386:	fba7 2304 	umull	r2, r3, r7, r4
    238a:	08db      	lsrs	r3, r3, #3
    238c:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    2390:	eba4 0242 	sub.w	r2, r4, r2, lsl #1
    2394:	ac0c      	add	r4, sp, #48	; 0x30
    2396:	4422      	add	r2, r4
    2398:	f812 2c20 	ldrb.w	r2, [r2, #-32]
    239c:	f801 2b01 	strb.w	r2, [r1], #1
    while ((num /= 10) > 0);
    23a0:	461c      	mov	r4, r3
    23a2:	2b00      	cmp	r3, #0
    23a4:	d1ed      	bne.n	2382 <fatfs_lfn_generate_tail+0x3a>
    *cp-- = 0;
    23a6:	700b      	strb	r3, [r1, #0]
    while (cp >= outbuf)
    23a8:	ab01      	add	r3, sp, #4
    23aa:	4298      	cmp	r0, r3
    23ac:	d321      	bcc.n	23f2 <fatfs_lfn_generate_tail+0xaa>
    23ae:	460b      	mov	r3, r1
    23b0:	f10d 0225 	add.w	r2, sp, #37	; 0x25
    23b4:	ac01      	add	r4, sp, #4
        *s++ = *cp--;
    23b6:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    23ba:	f802 1b01 	strb.w	r1, [r2], #1
    while (cp >= outbuf)
    23be:	42a3      	cmp	r3, r4
    23c0:	d1f9      	bne.n	23b6 <fatfs_lfn_generate_tail+0x6e>
    23c2:	3022      	adds	r0, #34	; 0x22
    *s = 0;
    23c4:	2300      	movs	r3, #0
    23c6:	7003      	strb	r3, [r0, #0]
    fatfs_itoa(tailNum, tail_str+1);

    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
    23c8:	6832      	ldr	r2, [r6, #0]
    23ca:	6873      	ldr	r3, [r6, #4]
    23cc:	602a      	str	r2, [r5, #0]
    23ce:	606b      	str	r3, [r5, #4]
    23d0:	8932      	ldrh	r2, [r6, #8]
    23d2:	7ab3      	ldrb	r3, [r6, #10]
    23d4:	812a      	strh	r2, [r5, #8]
    23d6:	72ab      	strb	r3, [r5, #10]

    // Overwrite with tail
    tail_chars = (int)strlen(tail_str);
    23d8:	a809      	add	r0, sp, #36	; 0x24
    23da:	4b09      	ldr	r3, [pc, #36]	; (2400 <fatfs_lfn_generate_tail+0xb8>)
    23dc:	4798      	blx	r3
    23de:	4602      	mov	r2, r0
    memcpy(sfn_output+(FAT_SFN_SIZE_PARTIAL-tail_chars), tail_str, tail_chars);
    23e0:	f1c0 0008 	rsb	r0, r0, #8
    23e4:	a909      	add	r1, sp, #36	; 0x24
    23e6:	4428      	add	r0, r5
    23e8:	4b06      	ldr	r3, [pc, #24]	; (2404 <fatfs_lfn_generate_tail+0xbc>)
    23ea:	4798      	blx	r3

    return 1;
    23ec:	2001      	movs	r0, #1
}
    23ee:	b00d      	add	sp, #52	; 0x34
    23f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    while (cp >= outbuf)
    23f2:	f10d 0025 	add.w	r0, sp, #37	; 0x25
    23f6:	e7e5      	b.n	23c4 <fatfs_lfn_generate_tail+0x7c>
    23f8:	0001869f 	.word	0x0001869f
    23fc:	cccccccd 	.word	0xcccccccd
    2400:	00003c01 	.word	0x00003c01
    2404:	0000393d 	.word	0x0000393d
    2408:	00003f54 	.word	0x00003f54

0000240c <FileString_StrCmpNoCase>:
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
    240c:	b302      	cbz	r2, 2450 <FileString_StrCmpNoCase+0x44>
{
    240e:	b470      	push	{r4, r5, r6}
    2410:	1e46      	subs	r6, r0, #1
    2412:	3901      	subs	r1, #1
    {
        a = *s1;
    2414:	f816 4f01 	ldrb.w	r4, [r6, #1]!
        b = *s2;
    2418:	f811 5f01 	ldrb.w	r5, [r1, #1]!

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
    241c:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
    2420:	b2db      	uxtb	r3, r3
    2422:	2b19      	cmp	r3, #25
            a+= 32;
    2424:	bf9a      	itte	ls
    2426:	f104 0020 	addls.w	r0, r4, #32
    242a:	b2c0      	uxtbls	r0, r0
        a = *s1;
    242c:	4620      	movhi	r0, r4
        if ((b>='A') && (b<='Z'))
    242e:	f1a5 0341 	sub.w	r3, r5, #65	; 0x41
    2432:	b2db      	uxtb	r3, r3
    2434:	2b19      	cmp	r3, #25
            b+= 32;
    2436:	bf9a      	itte	ls
    2438:	f105 0320 	addls.w	r3, r5, #32
    243c:	b2db      	uxtbls	r3, r3
        b = *s2;
    243e:	462b      	movhi	r3, r5

        diff = a - b;

        // If different
        if (diff)
    2440:	1ac0      	subs	r0, r0, r3
    2442:	d103      	bne.n	244c <FileString_StrCmpNoCase+0x40>
            return diff;

        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
    2444:	b114      	cbz	r4, 244c <FileString_StrCmpNoCase+0x40>
    2446:	b10d      	cbz	r5, 244c <FileString_StrCmpNoCase+0x40>
    while (n--)
    2448:	3a01      	subs	r2, #1
    244a:	d1e3      	bne.n	2414 <FileString_StrCmpNoCase+0x8>

        s1++;
        s2++;
    }
    return 0;
}
    244c:	bc70      	pop	{r4, r5, r6}
    244e:	4770      	bx	lr
    return 0;
    2450:	4610      	mov	r0, r2
    2452:	4770      	bx	lr

00002454 <FileString_GetExtension>:
//-----------------------------------------------------------------------------
// FileString_GetExtension: Get index to extension within filename
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_GetExtension(char *str)
{
    2454:	4601      	mov	r1, r0
    int dotPos = -1;
    char *strSrc = str;

    // Find last '.' in string (if at all)
    while (*strSrc)
    2456:	7803      	ldrb	r3, [r0, #0]
    2458:	b153      	cbz	r3, 2470 <FileString_GetExtension+0x1c>
    245a:	4602      	mov	r2, r0
    245c:	f04f 30ff 	mov.w	r0, #4294967295
    {
        if (*strSrc=='.')
    2460:	2b2e      	cmp	r3, #46	; 0x2e
    2462:	bf08      	it	eq
    2464:	1a50      	subeq	r0, r2, r1
    while (*strSrc)
    2466:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    246a:	2b00      	cmp	r3, #0
    246c:	d1f8      	bne.n	2460 <FileString_GetExtension+0xc>
    246e:	4770      	bx	lr
    int dotPos = -1;
    2470:	f04f 30ff 	mov.w	r0, #4294967295

        strSrc++;
    }

    return dotPos;
}
    2474:	4770      	bx	lr

00002476 <fatfs_total_path_levels>:
    if (!path)
    2476:	4602      	mov	r2, r0
    2478:	b1f8      	cbz	r0, 24ba <fatfs_total_path_levels+0x44>
    if (*path == '/')
    247a:	7801      	ldrb	r1, [r0, #0]
    247c:	292f      	cmp	r1, #47	; 0x2f
    247e:	d00c      	beq.n	249a <fatfs_total_path_levels+0x24>
    else if (path[1] == ':' || path[2] == '\\')
    2480:	7843      	ldrb	r3, [r0, #1]
    2482:	2b3a      	cmp	r3, #58	; 0x3a
    2484:	d002      	beq.n	248c <fatfs_total_path_levels+0x16>
    2486:	7883      	ldrb	r3, [r0, #2]
    2488:	2b5c      	cmp	r3, #92	; 0x5c
    248a:	d119      	bne.n	24c0 <fatfs_total_path_levels+0x4a>
        path += 3;
    248c:	3203      	adds	r2, #3
        expectedchar = '\\';
    248e:	215c      	movs	r1, #92	; 0x5c
    while (*path)
    2490:	7813      	ldrb	r3, [r2, #0]
    2492:	2000      	movs	r0, #0
    2494:	b1c3      	cbz	r3, 24c8 <fatfs_total_path_levels+0x52>
    2496:	2000      	movs	r0, #0
    2498:	e006      	b.n	24a8 <fatfs_total_path_levels+0x32>
        path++;
    249a:	3201      	adds	r2, #1
    249c:	e7f8      	b.n	2490 <fatfs_total_path_levels+0x1a>
            if (*path == expectedchar) { path++; break; }
    249e:	4613      	mov	r3, r2
    24a0:	1c5a      	adds	r2, r3, #1
        levels++;
    24a2:	3001      	adds	r0, #1
    while (*path)
    24a4:	785b      	ldrb	r3, [r3, #1]
    24a6:	b17b      	cbz	r3, 24c8 <fatfs_total_path_levels+0x52>
            if (*path == expectedchar) { path++; break; }
    24a8:	4299      	cmp	r1, r3
    24aa:	d0f8      	beq.n	249e <fatfs_total_path_levels+0x28>
        for (; *path; )
    24ac:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    24b0:	b14b      	cbz	r3, 24c6 <fatfs_total_path_levels+0x50>
            if (*path == expectedchar) { path++; break; }
    24b2:	4299      	cmp	r1, r3
    24b4:	d1fa      	bne.n	24ac <fatfs_total_path_levels+0x36>
            path++;
    24b6:	4613      	mov	r3, r2
    24b8:	e7f2      	b.n	24a0 <fatfs_total_path_levels+0x2a>
        return -1;
    24ba:	f04f 30ff 	mov.w	r0, #4294967295
    24be:	4770      	bx	lr
        return -1;
    24c0:	f04f 30ff 	mov.w	r0, #4294967295
    24c4:	4770      	bx	lr
        levels++;
    24c6:	3001      	adds	r0, #1
    return levels-1;
    24c8:	3801      	subs	r0, #1
    24ca:	4770      	bx	lr

000024cc <fatfs_get_substring>:
    if (!path || max_len <= 0)
    24cc:	2800      	cmp	r0, #0
    24ce:	d03d      	beq.n	254c <fatfs_get_substring+0x80>
{
    24d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    24d4:	4605      	mov	r5, r0
    if (!path || max_len <= 0)
    24d6:	2b00      	cmp	r3, #0
    24d8:	dd3b      	ble.n	2552 <fatfs_get_substring+0x86>
    if (*path == '/')
    24da:	7806      	ldrb	r6, [r0, #0]
    24dc:	2e2f      	cmp	r6, #47	; 0x2f
    24de:	d016      	beq.n	250e <fatfs_get_substring+0x42>
    else if (path[1] == ':' || path[2] == '\\')
    24e0:	7840      	ldrb	r0, [r0, #1]
    24e2:	283a      	cmp	r0, #58	; 0x3a
    24e4:	d002      	beq.n	24ec <fatfs_get_substring+0x20>
    24e6:	78a8      	ldrb	r0, [r5, #2]
    24e8:	285c      	cmp	r0, #92	; 0x5c
    24ea:	d136      	bne.n	255a <fatfs_get_substring+0x8e>
        path += 3;
    24ec:	3503      	adds	r5, #3
        expectedchar = '\\';
    24ee:	265c      	movs	r6, #92	; 0x5c
    24f0:	4699      	mov	r9, r3
    24f2:	4690      	mov	r8, r2
    24f4:	460f      	mov	r7, r1
    pathlen = (int)strlen (path);
    24f6:	4628      	mov	r0, r5
    24f8:	4b1a      	ldr	r3, [pc, #104]	; (2564 <fatfs_get_substring+0x98>)
    24fa:	4798      	blx	r3
    for (i = 0; i<pathlen; i++)
    24fc:	2800      	cmp	r0, #0
    24fe:	dd19      	ble.n	2534 <fatfs_get_substring+0x68>
    2500:	462c      	mov	r4, r5
    2502:	4428      	add	r0, r5
    2504:	2100      	movs	r1, #0
    2506:	460d      	mov	r5, r1
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1)))
    2508:	f109 32ff 	add.w	r2, r9, #4294967295
    250c:	e004      	b.n	2518 <fatfs_get_substring+0x4c>
        path++;
    250e:	3501      	adds	r5, #1
    2510:	e7ee      	b.n	24f0 <fatfs_get_substring+0x24>
        if (*path == expectedchar) levels++;
    2512:	3501      	adds	r5, #1
    for (i = 0; i<pathlen; i++)
    2514:	4284      	cmp	r4, r0
    2516:	d00e      	beq.n	2536 <fatfs_get_substring+0x6a>
        if (*path == expectedchar) levels++;
    2518:	f814 3b01 	ldrb.w	r3, [r4], #1
    251c:	429e      	cmp	r6, r3
    251e:	d0f8      	beq.n	2512 <fatfs_get_substring+0x46>
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1)))
    2520:	42af      	cmp	r7, r5
    2522:	d1f7      	bne.n	2514 <fatfs_get_substring+0x48>
    2524:	428a      	cmp	r2, r1
            output[copypnt++] = *path;
    2526:	bfc3      	ittte	gt
    2528:	f808 3001 	strbgt.w	r3, [r8, r1]
    252c:	463d      	movgt	r5, r7
    252e:	3101      	addgt	r1, #1
    2530:	463d      	movle	r5, r7
    2532:	e7ef      	b.n	2514 <fatfs_get_substring+0x48>
    int copypnt=0;
    2534:	2100      	movs	r1, #0
    output[copypnt] = '\0';
    2536:	2300      	movs	r3, #0
    2538:	f808 3001 	strb.w	r3, [r8, r1]
    if (output[0] != '\0')
    253c:	f898 0000 	ldrb.w	r0, [r8]
    2540:	fab0 f080 	clz	r0, r0
    2544:	0940      	lsrs	r0, r0, #5
    2546:	4240      	negs	r0, r0
    2548:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return -1;
    254c:	f04f 30ff 	mov.w	r0, #4294967295
    2550:	4770      	bx	lr
    2552:	f04f 30ff 	mov.w	r0, #4294967295
    2556:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return -1;
    255a:	f04f 30ff 	mov.w	r0, #4294967295
    255e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2562:	bf00      	nop
    2564:	00003c01 	.word	0x00003c01

00002568 <fatfs_split_path>:
{
    2568:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    256c:	4607      	mov	r7, r0
    256e:	460e      	mov	r6, r1
    2570:	4692      	mov	sl, r2
    2572:	4699      	mov	r9, r3
    int levels = fatfs_total_path_levels(full_path);
    2574:	4b16      	ldr	r3, [pc, #88]	; (25d0 <fatfs_split_path+0x68>)
    2576:	4798      	blx	r3
    2578:	4604      	mov	r4, r0
    if (levels == -1)
    257a:	f1b0 3fff 	cmp.w	r0, #4294967295
    257e:	d022      	beq.n	25c6 <fatfs_split_path+0x5e>
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
    2580:	9b08      	ldr	r3, [sp, #32]
    2582:	464a      	mov	r2, r9
    2584:	4601      	mov	r1, r0
    2586:	4638      	mov	r0, r7
    2588:	4d12      	ldr	r5, [pc, #72]	; (25d4 <fatfs_split_path+0x6c>)
    258a:	47a8      	blx	r5
    258c:	4680      	mov	r8, r0
    258e:	b9e0      	cbnz	r0, 25ca <fatfs_split_path+0x62>
    if (levels == 0)
    2590:	b1ac      	cbz	r4, 25be <fatfs_split_path+0x56>
        strindex = (int)strlen(full_path) - (int)strlen(filename);
    2592:	4638      	mov	r0, r7
    2594:	4c10      	ldr	r4, [pc, #64]	; (25d8 <fatfs_split_path+0x70>)
    2596:	47a0      	blx	r4
    2598:	4605      	mov	r5, r0
    259a:	4648      	mov	r0, r9
    259c:	47a0      	blx	r4
    259e:	1a2c      	subs	r4, r5, r0
        memcpy(path, full_path, strindex);
    25a0:	4554      	cmp	r4, sl
    25a2:	bfa8      	it	ge
    25a4:	4654      	movge	r4, sl
    25a6:	4622      	mov	r2, r4
    25a8:	4639      	mov	r1, r7
    25aa:	4630      	mov	r0, r6
    25ac:	4b0b      	ldr	r3, [pc, #44]	; (25dc <fatfs_split_path+0x74>)
    25ae:	4798      	blx	r3
        path[strindex-1] = '\0';
    25b0:	4434      	add	r4, r6
    25b2:	2300      	movs	r3, #0
    25b4:	f804 3c01 	strb.w	r3, [r4, #-1]
}
    25b8:	4640      	mov	r0, r8
    25ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        path[0] = '\0';
    25be:	2300      	movs	r3, #0
    25c0:	7033      	strb	r3, [r6, #0]
    return 0;
    25c2:	46a0      	mov	r8, r4
    25c4:	e7f8      	b.n	25b8 <fatfs_split_path+0x50>
        return -1;
    25c6:	4680      	mov	r8, r0
    25c8:	e7f6      	b.n	25b8 <fatfs_split_path+0x50>
        return -1;
    25ca:	f04f 38ff 	mov.w	r8, #4294967295
    25ce:	e7f3      	b.n	25b8 <fatfs_split_path+0x50>
    25d0:	00002477 	.word	0x00002477
    25d4:	000024cd 	.word	0x000024cd
    25d8:	00003c01 	.word	0x00003c01
    25dc:	0000393d 	.word	0x0000393d

000025e0 <fatfs_compare_names>:
//-----------------------------------------------------------------------------
// fatfs_compare_names: Compare two filenames (without copying or changing origonals)
// Returns 1 if match, 0 if not
//-----------------------------------------------------------------------------
int fatfs_compare_names(char* strA, char* strB)
{
    25e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    25e4:	4607      	mov	r7, r0
    25e6:	460e      	mov	r6, r1
    char *ext2 = NULL;
    int ext1Pos, ext2Pos;
    int file1Len, file2Len;

    // Get both files extension
    ext1Pos = FileString_GetExtension(strA);
    25e8:	4d3a      	ldr	r5, [pc, #232]	; (26d4 <fatfs_compare_names+0xf4>)
    25ea:	47a8      	blx	r5
    25ec:	4604      	mov	r4, r0
    ext2Pos = FileString_GetExtension(strB);
    25ee:	4630      	mov	r0, r6
    25f0:	47a8      	blx	r5
    25f2:	4605      	mov	r5, r0

    // NOTE: Extension position can be different for matching
    // filename if trailing space are present before it!
    // Check that if one has an extension, so does the other
    if ((ext1Pos==-1) && (ext2Pos!=-1))
    25f4:	f1b4 3fff 	cmp.w	r4, #4294967295
    25f8:	d015      	beq.n	2626 <fatfs_compare_names+0x46>
        return 0;
    if ((ext2Pos==-1) && (ext1Pos!=-1))
    25fa:	f1b0 3fff 	cmp.w	r0, #4294967295
    25fe:	d04f      	beq.n	26a0 <fatfs_compare_names+0xc0>

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
    2600:	f104 0801 	add.w	r8, r4, #1
    2604:	44b8      	add	r8, r7
        ext2 = strB+ext2Pos+1;
    2606:	f105 0901 	add.w	r9, r5, #1
    260a:	44b1      	add	r9, r6

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
    260c:	4640      	mov	r0, r8
    260e:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 26dc <fatfs_compare_names+0xfc>
    2612:	47d0      	blx	sl
    2614:	4683      	mov	fp, r0
    2616:	4648      	mov	r0, r9
    2618:	47d0      	blx	sl
    261a:	4583      	cmp	fp, r0
    261c:	d008      	beq.n	2630 <fatfs_compare_names+0x50>
            return 0;
    261e:	2500      	movs	r5, #0
    // Compare main part of filenames
    if (FileString_StrCmpNoCase(strA, strB, file1Len)!=0)
        return 0;
    else
        return 1;
}
    2620:	4628      	mov	r0, r5
    2622:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((ext1Pos==-1) && (ext2Pos!=-1))
    2626:	f1b0 3fff 	cmp.w	r0, #4294967295
    262a:	d009      	beq.n	2640 <fatfs_compare_names+0x60>
        return 0;
    262c:	2500      	movs	r5, #0
    262e:	e7f7      	b.n	2620 <fatfs_compare_names+0x40>
        if (FileString_StrCmpNoCase(ext1, ext2, (int)strlen(ext1))!=0)
    2630:	465a      	mov	r2, fp
    2632:	4649      	mov	r1, r9
    2634:	4640      	mov	r0, r8
    2636:	4b28      	ldr	r3, [pc, #160]	; (26d8 <fatfs_compare_names+0xf8>)
    2638:	4798      	blx	r3
    263a:	b140      	cbz	r0, 264e <fatfs_compare_names+0x6e>
            return 0;
    263c:	2500      	movs	r5, #0
    263e:	e7ef      	b.n	2620 <fatfs_compare_names+0x40>
        file1Len = (int)strlen(strA);
    2640:	4638      	mov	r0, r7
    2642:	4d26      	ldr	r5, [pc, #152]	; (26dc <fatfs_compare_names+0xfc>)
    2644:	47a8      	blx	r5
    2646:	4604      	mov	r4, r0
        file2Len = (int)strlen(strB);
    2648:	4630      	mov	r0, r6
    264a:	47a8      	blx	r5
    264c:	4605      	mov	r5, r0
    char *strSrc = str+strLen-1;
    264e:	1e62      	subs	r2, r4, #1
    2650:	18b9      	adds	r1, r7, r2
    while (strLen != 0)
    2652:	b33c      	cbz	r4, 26a4 <fatfs_compare_names+0xc4>
        if (*strSrc == ' ')
    2654:	5cba      	ldrb	r2, [r7, r2]
    2656:	2a20      	cmp	r2, #32
    2658:	d136      	bne.n	26c8 <fatfs_compare_names+0xe8>
    265a:	4608      	mov	r0, r1
    265c:	f1c4 0301 	rsb	r3, r4, #1
    2660:	4419      	add	r1, r3
    while (strLen != 0)
    2662:	4288      	cmp	r0, r1
    2664:	d006      	beq.n	2674 <fatfs_compare_names+0x94>
    2666:	1e42      	subs	r2, r0, #1
        if (*strSrc == ' ')
    2668:	f810 3c01 	ldrb.w	r3, [r0, #-1]
    266c:	2b20      	cmp	r3, #32
    266e:	d101      	bne.n	2674 <fatfs_compare_names+0x94>
    2670:	4610      	mov	r0, r2
    2672:	e7f6      	b.n	2662 <fatfs_compare_names+0x82>
            length = (int)(strSrc - str);
    2674:	1bc4      	subs	r4, r0, r7
    char *strSrc = str+strLen-1;
    2676:	1e69      	subs	r1, r5, #1
    2678:	4431      	add	r1, r6
    while (strLen != 0)
    267a:	b16d      	cbz	r5, 2698 <fatfs_compare_names+0xb8>
        if (*strSrc == ' ')
    267c:	780b      	ldrb	r3, [r1, #0]
    267e:	2b20      	cmp	r3, #32
    2680:	d10a      	bne.n	2698 <fatfs_compare_names+0xb8>
    2682:	460b      	mov	r3, r1
    2684:	f1c5 0501 	rsb	r5, r5, #1
    2688:	4429      	add	r1, r5
    268a:	1b9d      	subs	r5, r3, r6
    while (strLen != 0)
    268c:	428b      	cmp	r3, r1
    268e:	d003      	beq.n	2698 <fatfs_compare_names+0xb8>
        if (*strSrc == ' ')
    2690:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    2694:	2a20      	cmp	r2, #32
    2696:	d0f8      	beq.n	268a <fatfs_compare_names+0xaa>
    if (file1Len!=file2Len)
    2698:	42a5      	cmp	r5, r4
    269a:	d00c      	beq.n	26b6 <fatfs_compare_names+0xd6>
        return 0;
    269c:	2500      	movs	r5, #0
    269e:	e7bf      	b.n	2620 <fatfs_compare_names+0x40>
        return 0;
    26a0:	2500      	movs	r5, #0
    26a2:	e7bd      	b.n	2620 <fatfs_compare_names+0x40>
    char *strSrc = str+strLen-1;
    26a4:	1e6b      	subs	r3, r5, #1
    26a6:	18f1      	adds	r1, r6, r3
    while (strLen != 0)
    26a8:	b125      	cbz	r5, 26b4 <fatfs_compare_names+0xd4>
        if (*strSrc == ' ')
    26aa:	5cf3      	ldrb	r3, [r6, r3]
    26ac:	2b20      	cmp	r3, #32
    26ae:	d0e8      	beq.n	2682 <fatfs_compare_names+0xa2>
        return 0;
    26b0:	4625      	mov	r5, r4
    26b2:	e7b5      	b.n	2620 <fatfs_compare_names+0x40>
    int length = strLen;
    26b4:	462c      	mov	r4, r5
    if (FileString_StrCmpNoCase(strA, strB, file1Len)!=0)
    26b6:	4622      	mov	r2, r4
    26b8:	4631      	mov	r1, r6
    26ba:	4638      	mov	r0, r7
    26bc:	4b06      	ldr	r3, [pc, #24]	; (26d8 <fatfs_compare_names+0xf8>)
    26be:	4798      	blx	r3
    26c0:	fab0 f580 	clz	r5, r0
    26c4:	096d      	lsrs	r5, r5, #5
    26c6:	e7ab      	b.n	2620 <fatfs_compare_names+0x40>
    char *strSrc = str+strLen-1;
    26c8:	1e69      	subs	r1, r5, #1
    26ca:	4431      	add	r1, r6
    while (strLen != 0)
    26cc:	2d00      	cmp	r5, #0
    26ce:	d1d5      	bne.n	267c <fatfs_compare_names+0x9c>
    26d0:	e7a6      	b.n	2620 <fatfs_compare_names+0x40>
    26d2:	bf00      	nop
    26d4:	00002455 	.word	0x00002455
    26d8:	0000240d 	.word	0x0000240d
    26dc:	00003c01 	.word	0x00003c01

000026e0 <fatfs_fat_writeback>:
}
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
    26e0:	b538      	push	{r3, r4, r5, lr}
    if (pcur)
    26e2:	b1d1      	cbz	r1, 271a <fatfs_fat_writeback+0x3a>
    26e4:	460c      	mov	r4, r1
    {
        // Writeback sector if changed
        if (pcur->dirty)
    26e6:	f8d1 2204 	ldr.w	r2, [r1, #516]	; 0x204
    26ea:	b1c2      	cbz	r2, 271e <fatfs_fat_writeback+0x3e>
    26ec:	4603      	mov	r3, r0
        {
            if (fs->disk_io.write_media)
    26ee:	6b45      	ldr	r5, [r0, #52]	; 0x34
    26f0:	b16d      	cbz	r5, 270e <fatfs_fat_writeback+0x2e>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
    26f2:	f8d1 0200 	ldr.w	r0, [r1, #512]	; 0x200
    26f6:	695a      	ldr	r2, [r3, #20]
    26f8:	1a81      	subs	r1, r0, r2

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
    26fa:	6a1a      	ldr	r2, [r3, #32]
    26fc:	1c4b      	adds	r3, r1, #1
    26fe:	4293      	cmp	r3, r2
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
    2700:	bf8c      	ite	hi
    2702:	1a52      	subhi	r2, r2, r1
                    sectors = FAT_BUFFER_SECTORS;
    2704:	2201      	movls	r2, #1

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
    2706:	4621      	mov	r1, r4
    2708:	47a8      	blx	r5
    270a:	4603      	mov	r3, r0
    270c:	b118      	cbz	r0, 2716 <fatfs_fat_writeback+0x36>
                    return 0;
            }

            pcur->dirty = 0;
    270e:	2300      	movs	r3, #0
    2710:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
        }

        return 1;
    2714:	2301      	movs	r3, #1
    }
    else
        return 0;
}
    2716:	4618      	mov	r0, r3
    2718:	bd38      	pop	{r3, r4, r5, pc}
        return 0;
    271a:	2300      	movs	r3, #0
    271c:	e7fb      	b.n	2716 <fatfs_fat_writeback+0x36>
        return 1;
    271e:	2301      	movs	r3, #1
    2720:	e7f9      	b.n	2716 <fatfs_fat_writeback+0x36>
	...

00002724 <fatfs_fat_read_sector>:
//-----------------------------------------------------------------------------
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
    2724:	b570      	push	{r4, r5, r6, lr}
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
    2726:	f8d0 4250 	ldr.w	r4, [r0, #592]	; 0x250

    // Itterate through sector buffer list
    while (pcur)
    272a:	b1ec      	cbz	r4, 2768 <fatfs_fat_read_sector+0x44>
    272c:	2200      	movs	r2, #0
            // Remove buffer from list
            if (last)
                last->next = NULL;
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
    272e:	4616      	mov	r6, r2
    2730:	e004      	b.n	273c <fatfs_fat_read_sector+0x18>
        if (pcur->next == NULL)
    2732:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
    2736:	b183      	cbz	r3, 275a <fatfs_fat_read_sector+0x36>
    while (pcur)
    2738:	4622      	mov	r2, r4
    273a:	461c      	mov	r4, r3
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
    273c:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
    2740:	428b      	cmp	r3, r1
    2742:	d8f6      	bhi.n	2732 <fatfs_fat_read_sector+0xe>
    2744:	1c5d      	adds	r5, r3, #1
    2746:	42a9      	cmp	r1, r5
    2748:	d2f3      	bcs.n	2732 <fatfs_fat_read_sector+0xe>
        last = pcur;
        pcur = pcur->next;
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    274a:	b354      	cbz	r4, 27a2 <fatfs_fat_read_sector+0x7e>
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
    274c:	1acb      	subs	r3, r1, r3
    274e:	eb04 2343 	add.w	r3, r4, r3, lsl #9
    2752:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
        return NULL;
    }

    pcur->ptr = pcur->sector;
    return pcur;
}
    2756:	4620      	mov	r0, r4
    2758:	bd70      	pop	{r4, r5, r6, pc}
            if (last)
    275a:	b1fa      	cbz	r2, 279c <fatfs_fat_read_sector+0x78>
                last->next = NULL;
    275c:	f8c2 620c 	str.w	r6, [r2, #524]	; 0x20c
        pcur = pcur->next;
    2760:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
    while (pcur)
    2764:	2b00      	cmp	r3, #0
    2766:	d1e7      	bne.n	2738 <fatfs_fat_read_sector+0x14>
    2768:	460d      	mov	r5, r1
    276a:	4606      	mov	r6, r0
    pcur->next = fs->fat_buffer_head;
    276c:	f8d0 3250 	ldr.w	r3, [r0, #592]	; 0x250
    2770:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
    fs->fat_buffer_head = pcur;
    2774:	f8c0 4250 	str.w	r4, [r0, #592]	; 0x250
    if (pcur->dirty)
    2778:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
    277c:	b11b      	cbz	r3, 2786 <fatfs_fat_read_sector+0x62>
        if (!fatfs_fat_writeback(fs, pcur))
    277e:	4621      	mov	r1, r4
    2780:	4b0d      	ldr	r3, [pc, #52]	; (27b8 <fatfs_fat_read_sector+0x94>)
    2782:	4798      	blx	r3
    2784:	b1a8      	cbz	r0, 27b2 <fatfs_fat_read_sector+0x8e>
    pcur->address = sector;
    2786:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    278a:	6b33      	ldr	r3, [r6, #48]	; 0x30
    278c:	2201      	movs	r2, #1
    278e:	4621      	mov	r1, r4
    2790:	4628      	mov	r0, r5
    2792:	4798      	blx	r3
    2794:	b138      	cbz	r0, 27a6 <fatfs_fat_read_sector+0x82>
    pcur->ptr = pcur->sector;
    2796:	f8c4 4208 	str.w	r4, [r4, #520]	; 0x208
    return pcur;
    279a:	e7dc      	b.n	2756 <fatfs_fat_read_sector+0x32>
                fs->fat_buffer_head = NULL;
    279c:	f8c0 6250 	str.w	r6, [r0, #592]	; 0x250
    27a0:	e7de      	b.n	2760 <fatfs_fat_read_sector+0x3c>
    27a2:	4614      	mov	r4, r2
    27a4:	e7e0      	b.n	2768 <fatfs_fat_read_sector+0x44>
        pcur->address = FAT32_INVALID_CLUSTER;
    27a6:	f04f 33ff 	mov.w	r3, #4294967295
    27aa:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        return NULL;
    27ae:	2400      	movs	r4, #0
    27b0:	e7d1      	b.n	2756 <fatfs_fat_read_sector+0x32>
            return 0;
    27b2:	2400      	movs	r4, #0
    27b4:	e7cf      	b.n	2756 <fatfs_fat_read_sector+0x32>
    27b6:	bf00      	nop
    27b8:	000026e1 	.word	0x000026e1

000027bc <fatfs_fat_init>:
{
    27bc:	b570      	push	{r4, r5, r6, lr}
    27be:	4604      	mov	r4, r0
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
    27c0:	f04f 33ff 	mov.w	r3, #4294967295
    27c4:	f8c0 3454 	str.w	r3, [r0, #1108]	; 0x454
        fs->fat_buffers[i].dirty = 0;
    27c8:	2500      	movs	r5, #0
    27ca:	f8c0 5458 	str.w	r5, [r0, #1112]	; 0x458
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
    27ce:	f500 7615 	add.w	r6, r0, #596	; 0x254
    27d2:	f44f 7200 	mov.w	r2, #512	; 0x200
    27d6:	4629      	mov	r1, r5
    27d8:	4630      	mov	r0, r6
    27da:	4b04      	ldr	r3, [pc, #16]	; (27ec <fatfs_fat_init+0x30>)
    27dc:	4798      	blx	r3
        fs->fat_buffers[i].ptr = NULL;
    27de:	f8c4 545c 	str.w	r5, [r4, #1116]	; 0x45c
        fs->fat_buffers[i].next = fs->fat_buffer_head;
    27e2:	f8c4 5460 	str.w	r5, [r4, #1120]	; 0x460
        fs->fat_buffer_head = &fs->fat_buffers[i];
    27e6:	f8c4 6250 	str.w	r6, [r4, #592]	; 0x250
    27ea:	bd70      	pop	{r4, r5, r6, pc}
    27ec:	00003a71 	.word	0x00003a71

000027f0 <fatfs_fat_purge>:
//-----------------------------------------------------------------------------
// fatfs_fat_purge: Purge 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
int fatfs_fat_purge(struct fatfs *fs)
{
    27f0:	b570      	push	{r4, r5, r6, lr}
    struct fat_buffer *pcur = fs->fat_buffer_head;
    27f2:	f8d0 4250 	ldr.w	r4, [r0, #592]	; 0x250

    // Itterate through sector buffer list
    while (pcur)
    27f6:	b19c      	cbz	r4, 2820 <fatfs_fat_purge+0x30>
    27f8:	4605      	mov	r5, r0
    {
        // Writeback sector if changed
        if (pcur->dirty)
            if (!fatfs_fat_writeback(fs, pcur))
    27fa:	4e0a      	ldr	r6, [pc, #40]	; (2824 <fatfs_fat_purge+0x34>)
    27fc:	e002      	b.n	2804 <fatfs_fat_purge+0x14>
                return 0;

        pcur = pcur->next;
    27fe:	f8d4 420c 	ldr.w	r4, [r4, #524]	; 0x20c
    while (pcur)
    2802:	b154      	cbz	r4, 281a <fatfs_fat_purge+0x2a>
        if (pcur->dirty)
    2804:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
    2808:	2b00      	cmp	r3, #0
    280a:	d0f8      	beq.n	27fe <fatfs_fat_purge+0xe>
            if (!fatfs_fat_writeback(fs, pcur))
    280c:	4621      	mov	r1, r4
    280e:	4628      	mov	r0, r5
    2810:	47b0      	blx	r6
    2812:	4603      	mov	r3, r0
    2814:	2800      	cmp	r0, #0
    2816:	d1f2      	bne.n	27fe <fatfs_fat_purge+0xe>
    2818:	e000      	b.n	281c <fatfs_fat_purge+0x2c>
    }

    return 1;
    281a:	2301      	movs	r3, #1
}
    281c:	4618      	mov	r0, r3
    281e:	bd70      	pop	{r4, r5, r6, pc}
    return 1;
    2820:	2301      	movs	r3, #1
    2822:	e7fb      	b.n	281c <fatfs_fat_purge+0x2c>
    2824:	000026e1 	.word	0x000026e1

00002828 <fatfs_find_next_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_next_cluster: Return cluster number of next cluster in chain by
// reading FAT table and traversing it. Return 0xffffffff for end of chain.
//-----------------------------------------------------------------------------
uint32 fatfs_find_next_cluster(struct fatfs *fs, uint32 current_cluster)
{
    2828:	b570      	push	{r4, r5, r6, lr}
    282a:	4606      	mov	r6, r0
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0)
    282c:	1e0c      	subs	r4, r1, #0
        current_cluster = 2;
    282e:	bf08      	it	eq
    2830:	2402      	moveq	r4, #2

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
    2832:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    2836:	b9e3      	cbnz	r3, 2872 <fatfs_find_next_cluster+0x4a>
        fat_sector_offset = current_cluster / 256;
    2838:	0a25      	lsrs	r5, r4, #8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    283a:	6971      	ldr	r1, [r6, #20]
    283c:	4429      	add	r1, r5
    283e:	4630      	mov	r0, r6
    2840:	4b1c      	ldr	r3, [pc, #112]	; (28b4 <fatfs_find_next_cluster+0x8c>)
    2842:	4798      	blx	r3
    if (!pbuf)
    2844:	b390      	cbz	r0, 28ac <fatfs_find_next_cluster+0x84>
        return (FAT32_LAST_CLUSTER);

    if (fs->fat_type == FAT_TYPE_16)
    2846:	f896 202d 	ldrb.w	r2, [r6, #45]	; 0x2d
    284a:	b9a2      	cbnz	r2, 2876 <fatfs_find_next_cluster+0x4e>
    {
        // Find 32 bit entry of current sector relating to cluster number
        position = (current_cluster - (fat_sector_offset * 256)) * 2;

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    284c:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
        position = (current_cluster - (fat_sector_offset * 256)) * 2;
    2850:	eba4 2405 	sub.w	r4, r4, r5, lsl #8
    2854:	0064      	lsls	r4, r4, #1
    2856:	b2a4      	uxth	r4, r4
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    2858:	191a      	adds	r2, r3, r4
    285a:	7852      	ldrb	r2, [r2, #1]
    285c:	5d18      	ldrb	r0, [r3, r4]
    285e:	eb00 2002 	add.w	r0, r0, r2, lsl #8

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF)
    2862:	f5a0 437f 	sub.w	r3, r0, #65280	; 0xff00
    2866:	3bf8      	subs	r3, #248	; 0xf8
            return (FAT32_LAST_CLUSTER);
    2868:	2b07      	cmp	r3, #7
    286a:	bf98      	it	ls
    286c:	f04f 30ff 	movls.w	r0, #4294967295
    2870:	bd70      	pop	{r4, r5, r6, pc}
        fat_sector_offset = current_cluster / 128;
    2872:	09e5      	lsrs	r5, r4, #7
    2874:	e7e1      	b.n	283a <fatfs_find_next_cluster+0x12>
    {
        // Find 32 bit entry of current sector relating to cluster number
        position = (current_cluster - (fat_sector_offset * 128)) * 4;

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    2876:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
        position = (current_cluster - (fat_sector_offset * 128)) * 4;
    287a:	eba4 14c5 	sub.w	r4, r4, r5, lsl #7
    287e:	00a4      	lsls	r4, r4, #2
    2880:	b2a4      	uxth	r4, r4
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    2882:	1913      	adds	r3, r2, r4
    2884:	78d9      	ldrb	r1, [r3, #3]
    2886:	7898      	ldrb	r0, [r3, #2]
    2888:	0400      	lsls	r0, r0, #16
    288a:	eb00 6001 	add.w	r0, r0, r1, lsl #24
    288e:	5d12      	ldrb	r2, [r2, r4]
    2890:	4410      	add	r0, r2
    2892:	785b      	ldrb	r3, [r3, #1]
    2894:	eb00 2003 	add.w	r0, r0, r3, lsl #8

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;
    2898:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF)
    289c:	f100 4370 	add.w	r3, r0, #4026531840	; 0xf0000000
    28a0:	3308      	adds	r3, #8
            return (FAT32_LAST_CLUSTER);
    28a2:	2b07      	cmp	r3, #7
    28a4:	bf98      	it	ls
    28a6:	f04f 30ff 	movls.w	r0, #4294967295
    28aa:	bd70      	pop	{r4, r5, r6, pc}
        return (FAT32_LAST_CLUSTER);
    28ac:	f04f 30ff 	mov.w	r0, #4294967295
    }

    // Else return next cluster
    return (nextcluster);
}
    28b0:	bd70      	pop	{r4, r5, r6, pc}
    28b2:	bf00      	nop
    28b4:	00002725 	.word	0x00002725

000028b8 <fatfs_set_fs_info_next_free_cluster>:
//-----------------------------------------------------------------------------
// fatfs_set_fs_info_next_free_cluster: Write the next free cluster to the FSINFO table
//-----------------------------------------------------------------------------
void fatfs_set_fs_info_next_free_cluster(struct fatfs *fs, uint32 newValue)
{
    if (fs->fat_type == FAT_TYPE_16)
    28b8:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    28bc:	b903      	cbnz	r3, 28c0 <fatfs_set_fs_info_next_free_cluster+0x8>
    28be:	4770      	bx	lr
{
    28c0:	b570      	push	{r4, r5, r6, lr}
    28c2:	460e      	mov	r6, r1
    28c4:	4605      	mov	r5, r0
        ;
    else
    {
        // Load sector to change it
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
    28c6:	8b01      	ldrh	r1, [r0, #24]
    28c8:	69c3      	ldr	r3, [r0, #28]
    28ca:	4419      	add	r1, r3
    28cc:	4b14      	ldr	r3, [pc, #80]	; (2920 <fatfs_set_fs_info_next_free_cluster+0x68>)
    28ce:	4798      	blx	r3
        if (!pbuf)
    28d0:	4604      	mov	r4, r0
    28d2:	b320      	cbz	r0, 291e <fatfs_set_fs_info_next_free_cluster+0x66>
            return ;

        // Change
        FAT32_SET_32BIT_WORD(pbuf, 492, newValue);
    28d4:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    28d8:	f883 61ec 	strb.w	r6, [r3, #492]	; 0x1ec
    28dc:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    28e0:	0a32      	lsrs	r2, r6, #8
    28e2:	f883 21ed 	strb.w	r2, [r3, #493]	; 0x1ed
    28e6:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    28ea:	0c32      	lsrs	r2, r6, #16
    28ec:	f883 21ee 	strb.w	r2, [r3, #494]	; 0x1ee
    28f0:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    28f4:	0e32      	lsrs	r2, r6, #24
    28f6:	f883 21ef 	strb.w	r2, [r3, #495]	; 0x1ef
    28fa:	2301      	movs	r3, #1
    28fc:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
        fs->next_free_cluster = newValue;
    2900:	626e      	str	r6, [r5, #36]	; 0x24

        // Write back FSINFO sector to disk
        if (fs->disk_io.write_media)
    2902:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    2904:	b123      	cbz	r3, 2910 <fatfs_set_fs_info_next_free_cluster+0x58>
            fs->disk_io.write_media(pbuf->address, pbuf->sector, 1);
    2906:	2201      	movs	r2, #1
    2908:	4601      	mov	r1, r0
    290a:	f8d0 0200 	ldr.w	r0, [r0, #512]	; 0x200
    290e:	4798      	blx	r3

        // Invalidate cache entry
        pbuf->address = FAT32_INVALID_CLUSTER;
    2910:	f04f 33ff 	mov.w	r3, #4294967295
    2914:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        pbuf->dirty = 0;
    2918:	2300      	movs	r3, #0
    291a:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
    291e:	bd70      	pop	{r4, r5, r6, pc}
    2920:	00002725 	.word	0x00002725

00002924 <fatfs_find_blank_cluster>:
//-----------------------------------------------------------------------------
// fatfs_find_blank_cluster: Find a free cluster entry by reading the FAT
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_find_blank_cluster(struct fatfs *fs, uint32 start_cluster, uint32 *free_cluster)
{
    2924:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2928:	4605      	mov	r5, r0
    292a:	460e      	mov	r6, r1
    292c:	4690      	mov	r8, r2
            fat_sector_offset = current_cluster / 128;

        if ( fat_sector_offset < fs->fat_sectors)
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    292e:	4f1f      	ldr	r7, [pc, #124]	; (29ac <fatfs_find_blank_cluster+0x88>)
        if (fs->fat_type == FAT_TYPE_16)
    2930:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
    2934:	b9cb      	cbnz	r3, 296a <fatfs_find_blank_cluster+0x46>
            fat_sector_offset = current_cluster / 256;
    2936:	0a34      	lsrs	r4, r6, #8
        if ( fat_sector_offset < fs->fat_sectors)
    2938:	6a2b      	ldr	r3, [r5, #32]
    293a:	429c      	cmp	r4, r3
    293c:	d22b      	bcs.n	2996 <fatfs_find_blank_cluster+0x72>
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    293e:	6969      	ldr	r1, [r5, #20]
    2940:	4421      	add	r1, r4
    2942:	4628      	mov	r0, r5
    2944:	47b8      	blx	r7
            if (!pbuf)
    2946:	b348      	cbz	r0, 299c <fatfs_find_blank_cluster+0x78>
                return 0;

            if (fs->fat_type == FAT_TYPE_16)
    2948:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
    294c:	b97a      	cbnz	r2, 296e <fatfs_find_blank_cluster+0x4a>
            {
                // Find 32 bit entry of current sector relating to cluster number
                position = (current_cluster - (fat_sector_offset * 256)) * 2;

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    294e:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
                position = (current_cluster - (fat_sector_offset * 256)) * 2;
    2952:	eba6 2404 	sub.w	r4, r6, r4, lsl #8
    2956:	0064      	lsls	r4, r4, #1
    2958:	b2a4      	uxth	r4, r4
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);
    295a:	1913      	adds	r3, r2, r4
    295c:	7859      	ldrb	r1, [r3, #1]
    295e:	5d13      	ldrb	r3, [r2, r4]
    2960:	eb03 2301 	add.w	r3, r3, r1, lsl #8

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;
            }

            if (nextcluster !=0 )
    2964:	b1eb      	cbz	r3, 29a2 <fatfs_find_blank_cluster+0x7e>
                current_cluster++;
    2966:	3601      	adds	r6, #1
    2968:	e7e2      	b.n	2930 <fatfs_find_blank_cluster+0xc>
            fat_sector_offset = current_cluster / 128;
    296a:	09f4      	lsrs	r4, r6, #7
    296c:	e7e4      	b.n	2938 <fatfs_find_blank_cluster+0x14>
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    296e:	f8d0 1208 	ldr.w	r1, [r0, #520]	; 0x208
                position = (current_cluster - (fat_sector_offset * 128)) * 4;
    2972:	eba6 14c4 	sub.w	r4, r6, r4, lsl #7
    2976:	00a4      	lsls	r4, r4, #2
    2978:	b2a4      	uxth	r4, r4
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);
    297a:	190a      	adds	r2, r1, r4
    297c:	78d0      	ldrb	r0, [r2, #3]
    297e:	7893      	ldrb	r3, [r2, #2]
    2980:	041b      	lsls	r3, r3, #16
    2982:	eb03 6300 	add.w	r3, r3, r0, lsl #24
    2986:	5d09      	ldrb	r1, [r1, r4]
    2988:	440b      	add	r3, r1
    298a:	7852      	ldrb	r2, [r2, #1]
    298c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
                nextcluster = nextcluster & 0x0FFFFFFF;
    2990:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    2994:	e7e6      	b.n	2964 <fatfs_find_blank_cluster+0x40>
        }
        else
            // Otherwise, run out of FAT sectors to check...
            return 0;
    2996:	2000      	movs	r0, #0
    2998:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                return 0;
    299c:	2000      	movs	r0, #0
    299e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    while (nextcluster != 0x0);

    // Found blank entry
    *free_cluster = current_cluster;
    29a2:	f8c8 6000 	str.w	r6, [r8]
    return 1;
    29a6:	2001      	movs	r0, #1
}
    29a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    29ac:	00002725 	.word	0x00002725

000029b0 <fatfs_fat_set_cluster>:
// fatfs_fat_set_cluster: Set a cluster link in the chain. NOTE: Immediate
// write (slow).
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_fat_set_cluster(struct fatfs *fs, uint32 cluster, uint32 next_cluster)
{
    29b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    29b2:	4607      	mov	r7, r0
    29b4:	460c      	mov	r4, r1
    29b6:	4615      	mov	r5, r2
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
    29b8:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    29bc:	bb23      	cbnz	r3, 2a08 <fatfs_fat_set_cluster+0x58>
        fat_sector_offset = cluster / 256;
    29be:	0a0e      	lsrs	r6, r1, #8
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
    29c0:	6979      	ldr	r1, [r7, #20]
    29c2:	4431      	add	r1, r6
    29c4:	4638      	mov	r0, r7
    29c6:	4b1b      	ldr	r3, [pc, #108]	; (2a34 <fatfs_fat_set_cluster+0x84>)
    29c8:	4798      	blx	r3
    if (!pbuf)
    29ca:	4603      	mov	r3, r0
    29cc:	b378      	cbz	r0, 2a2e <fatfs_fat_set_cluster+0x7e>
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
    29ce:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
    29d2:	b1da      	cbz	r2, 2a0c <fatfs_fat_set_cluster+0x5c>
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));
    }
    else
    {
        // Find 32 bit entry of current sector relating to cluster number
        position = (cluster - (fat_sector_offset * 128)) * 4;
    29d4:	eba4 14c6 	sub.w	r4, r4, r6, lsl #7
    29d8:	00a4      	lsls	r4, r4, #2
    29da:	b2a4      	uxth	r4, r4

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);
    29dc:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    29e0:	5515      	strb	r5, [r2, r4]
    29e2:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    29e6:	4422      	add	r2, r4
    29e8:	0a29      	lsrs	r1, r5, #8
    29ea:	7051      	strb	r1, [r2, #1]
    29ec:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    29f0:	4422      	add	r2, r4
    29f2:	0c29      	lsrs	r1, r5, #16
    29f4:	7091      	strb	r1, [r2, #2]
    29f6:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    29fa:	4414      	add	r4, r2
    29fc:	0e2d      	lsrs	r5, r5, #24
    29fe:	70e5      	strb	r5, [r4, #3]
    2a00:	2001      	movs	r0, #1
    2a02:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
    2a06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        fat_sector_offset = cluster / 128;
    2a08:	09ce      	lsrs	r6, r1, #7
    2a0a:	e7d9      	b.n	29c0 <fatfs_fat_set_cluster+0x10>
        position = (cluster - (fat_sector_offset * 256)) * 2;
    2a0c:	eba4 2406 	sub.w	r4, r4, r6, lsl #8
    2a10:	0064      	lsls	r4, r4, #1
    2a12:	b2a4      	uxth	r4, r4
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));
    2a14:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
    2a18:	5515      	strb	r5, [r2, r4]
    2a1a:	f8d0 6208 	ldr.w	r6, [r0, #520]	; 0x208
    2a1e:	4434      	add	r4, r6
    2a20:	f3c5 2507 	ubfx	r5, r5, #8, #8
    2a24:	7065      	strb	r5, [r4, #1]
    2a26:	2001      	movs	r0, #1
    2a28:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
    2a2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
    2a2e:	2000      	movs	r0, #0
    }

    return 1;
}
    2a30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2a32:	bf00      	nop
    2a34:	00002725 	.word	0x00002725

00002a38 <fatfs_free_cluster_chain>:
//-----------------------------------------------------------------------------
// fatfs_free_cluster_chain: Follow a chain marking each element as free
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_free_cluster_chain(struct fatfs *fs, uint32 start_cluster)
{
    2a38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;

    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
    2a3c:	1e4b      	subs	r3, r1, #1
    2a3e:	f113 0f03 	cmn.w	r3, #3
    2a42:	d812      	bhi.n	2a6a <fatfs_free_cluster_chain+0x32>
    2a44:	4681      	mov	r9, r0
    2a46:	460d      	mov	r5, r1
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    2a48:	4e09      	ldr	r6, [pc, #36]	; (2a70 <fatfs_free_cluster_chain+0x38>)

        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
    2a4a:	f04f 0800 	mov.w	r8, #0
    2a4e:	4f09      	ldr	r7, [pc, #36]	; (2a74 <fatfs_free_cluster_chain+0x3c>)
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    2a50:	4629      	mov	r1, r5
    2a52:	4648      	mov	r0, r9
    2a54:	47b0      	blx	r6
    2a56:	4604      	mov	r4, r0
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
    2a58:	4642      	mov	r2, r8
    2a5a:	4629      	mov	r1, r5
    2a5c:	4648      	mov	r0, r9
    2a5e:	47b8      	blx	r7
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    2a60:	4625      	mov	r5, r4
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
    2a62:	3c01      	subs	r4, #1
    2a64:	f114 0f03 	cmn.w	r4, #3
    2a68:	d9f2      	bls.n	2a50 <fatfs_free_cluster_chain+0x18>
    }

    return 1;
}
    2a6a:	2001      	movs	r0, #1
    2a6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2a70:	00002829 	.word	0x00002829
    2a74:	000029b1 	.word	0x000029b1

00002a78 <fatfs_fat_add_cluster_to_chain>:
int fatfs_fat_add_cluster_to_chain(struct fatfs *fs, uint32 start_cluster, uint32 newEntry)
{
    uint32 last_cluster = FAT32_LAST_CLUSTER;
    uint32 next_cluster = start_cluster;

    if (start_cluster == FAT32_LAST_CLUSTER)
    2a78:	f1b1 3fff 	cmp.w	r1, #4294967295
    2a7c:	d01a      	beq.n	2ab4 <fatfs_fat_add_cluster_to_chain+0x3c>
{
    2a7e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2a80:	4605      	mov	r5, r0
    2a82:	460c      	mov	r4, r1
    2a84:	4617      	mov	r7, r2
    while ( next_cluster != FAT32_LAST_CLUSTER )
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
    2a86:	4e0d      	ldr	r6, [pc, #52]	; (2abc <fatfs_fat_add_cluster_to_chain+0x44>)
    2a88:	e000      	b.n	2a8c <fatfs_fat_add_cluster_to_chain+0x14>
    2a8a:	461c      	mov	r4, r3
    2a8c:	4621      	mov	r1, r4
    2a8e:	4628      	mov	r0, r5
    2a90:	47b0      	blx	r6
        if (!next_cluster)
    2a92:	4603      	mov	r3, r0
    2a94:	b180      	cbz	r0, 2ab8 <fatfs_fat_add_cluster_to_chain+0x40>
    while ( next_cluster != FAT32_LAST_CLUSTER )
    2a96:	f1b0 3fff 	cmp.w	r0, #4294967295
    2a9a:	d1f6      	bne.n	2a8a <fatfs_fat_add_cluster_to_chain+0x12>
            return 0;
    }

    // Add link in for new cluster
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);
    2a9c:	463a      	mov	r2, r7
    2a9e:	4621      	mov	r1, r4
    2aa0:	4628      	mov	r0, r5
    2aa2:	4c07      	ldr	r4, [pc, #28]	; (2ac0 <fatfs_fat_add_cluster_to_chain+0x48>)
    2aa4:	47a0      	blx	r4

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);
    2aa6:	f04f 32ff 	mov.w	r2, #4294967295
    2aaa:	4639      	mov	r1, r7
    2aac:	4628      	mov	r0, r5
    2aae:	47a0      	blx	r4

    return 1;
    2ab0:	2001      	movs	r0, #1
    2ab2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
    2ab4:	2000      	movs	r0, #0
    2ab6:	4770      	bx	lr
            return 0;
    2ab8:	2000      	movs	r0, #0
}
    2aba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2abc:	00002829 	.word	0x00002829
    2ac0:	000029b1 	.word	0x000029b1

00002ac4 <fatfs_add_free_space>:
//-----------------------------------------------------------------------------
// fatfs_add_free_space: Allocate another cluster of free space to the end
// of a files cluster chain.
//-----------------------------------------------------------------------------
int fatfs_add_free_space(struct fatfs *fs, uint32 *startCluster, uint32 clusters)
{
    2ac4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2ac8:	b082      	sub	sp, #8
    2aca:	4604      	mov	r4, r0
    2acc:	468a      	mov	sl, r1
    2ace:	4690      	mov	r8, r2
    uint32 i;
    uint32 nextcluster;
    uint32 start = *startCluster;
    2ad0:	680e      	ldr	r6, [r1, #0]

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
    2ad2:	6a43      	ldr	r3, [r0, #36]	; 0x24
    2ad4:	f1b3 3fff 	cmp.w	r3, #4294967295
    2ad8:	d003      	beq.n	2ae2 <fatfs_add_free_space+0x1e>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER);
    2ada:	f04f 31ff 	mov.w	r1, #4294967295
    2ade:	4b13      	ldr	r3, [pc, #76]	; (2b2c <fatfs_add_free_space+0x68>)
    2ae0:	4798      	blx	r3

    for (i=0;i<clusters;i++)
    2ae2:	f1b8 0f00 	cmp.w	r8, #0
    2ae6:	d01f      	beq.n	2b28 <fatfs_add_free_space+0x64>
    2ae8:	2500      	movs	r5, #0
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
    2aea:	f8df 9048 	ldr.w	r9, [pc, #72]	; 2b34 <fatfs_add_free_space+0x70>
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
    2aee:	4f10      	ldr	r7, [pc, #64]	; (2b30 <fatfs_add_free_space+0x6c>)
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
    2af0:	aa01      	add	r2, sp, #4
    2af2:	68a1      	ldr	r1, [r4, #8]
    2af4:	4620      	mov	r0, r4
    2af6:	47c8      	blx	r9
    2af8:	4603      	mov	r3, r0
    2afa:	b170      	cbz	r0, 2b1a <fatfs_add_free_space+0x56>
            fatfs_fat_set_cluster(fs, start, nextcluster);
    2afc:	9a01      	ldr	r2, [sp, #4]
    2afe:	4631      	mov	r1, r6
    2b00:	4620      	mov	r0, r4
    2b02:	47b8      	blx	r7

            // Point this to end of file
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
    2b04:	f04f 32ff 	mov.w	r2, #4294967295
    2b08:	9901      	ldr	r1, [sp, #4]
    2b0a:	4620      	mov	r0, r4
    2b0c:	47b8      	blx	r7

            // Adjust argument reference
            start = nextcluster;
    2b0e:	9e01      	ldr	r6, [sp, #4]
            if (i == 0)
    2b10:	b13d      	cbz	r5, 2b22 <fatfs_add_free_space+0x5e>
    for (i=0;i<clusters;i++)
    2b12:	3501      	adds	r5, #1
    2b14:	45a8      	cmp	r8, r5
    2b16:	d1eb      	bne.n	2af0 <fatfs_add_free_space+0x2c>
        }
        else
            return 0;
    }

    return 1;
    2b18:	2301      	movs	r3, #1
}
    2b1a:	4618      	mov	r0, r3
    2b1c:	b002      	add	sp, #8
    2b1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                *startCluster = nextcluster;
    2b22:	f8ca 6000 	str.w	r6, [sl]
    2b26:	e7f4      	b.n	2b12 <fatfs_add_free_space+0x4e>
    return 1;
    2b28:	2301      	movs	r3, #1
    2b2a:	e7f6      	b.n	2b1a <fatfs_add_free_space+0x56>
    2b2c:	000028b9 	.word	0x000028b9
    2b30:	000029b1 	.word	0x000029b1
    2b34:	00002925 	.word	0x00002925

00002b38 <fatfs_allocate_free_space>:
{
    uint32 clusterSize;
    uint32 clusterCount;
    uint32 nextcluster;

    if (size==0)
    2b38:	2b00      	cmp	r3, #0
    2b3a:	d03c      	beq.n	2bb6 <fatfs_allocate_free_space+0x7e>
{
    2b3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2b40:	b082      	sub	sp, #8
    2b42:	461d      	mov	r5, r3
    2b44:	4690      	mov	r8, r2
    2b46:	460e      	mov	r6, r1
    2b48:	4604      	mov	r4, r0
        return 0;

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
    2b4a:	6a43      	ldr	r3, [r0, #36]	; 0x24
    2b4c:	f1b3 3fff 	cmp.w	r3, #4294967295
    2b50:	d003      	beq.n	2b5a <fatfs_allocate_free_space+0x22>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER);
    2b52:	f04f 31ff 	mov.w	r1, #4294967295
    2b56:	4b19      	ldr	r3, [pc, #100]	; (2bbc <fatfs_allocate_free_space+0x84>)
    2b58:	4798      	blx	r3

    // Work out size and clusters
    clusterSize = fs->sectors_per_cluster * FAT_SECTOR_SIZE;
    2b5a:	7820      	ldrb	r0, [r4, #0]
    2b5c:	0240      	lsls	r0, r0, #9
    clusterCount = (size / clusterSize);
    2b5e:	fbb5 f7f0 	udiv	r7, r5, r0

    // If any left over
    if (size-(clusterSize*clusterCount))
    2b62:	fb07 f000 	mul.w	r0, r7, r0
    2b66:	4285      	cmp	r5, r0
        clusterCount++;
    2b68:	bf18      	it	ne
    2b6a:	3701      	addne	r7, #1

    // Allocated first link in the chain if a new file
    if (newFile)
    2b6c:	b976      	cbnz	r6, 2b8c <fatfs_allocate_free_space+0x54>
            return 1;
        }
    }
    // Allocate from end of current chain (startCluster is end of chain)
    else
        nextcluster = *startCluster;
    2b6e:	f8d8 3000 	ldr.w	r3, [r8]
    2b72:	9301      	str	r3, [sp, #4]

    if (!fatfs_add_free_space(fs, &nextcluster, clusterCount))
    2b74:	463a      	mov	r2, r7
    2b76:	a901      	add	r1, sp, #4
    2b78:	4620      	mov	r0, r4
    2b7a:	4b11      	ldr	r3, [pc, #68]	; (2bc0 <fatfs_allocate_free_space+0x88>)
    2b7c:	4798      	blx	r3
    2b7e:	1c03      	adds	r3, r0, #0
    2b80:	bf18      	it	ne
    2b82:	2301      	movne	r3, #1
            return 0;

    return 1;
}
    2b84:	4618      	mov	r0, r3
    2b86:	b002      	add	sp, #8
    2b88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
    2b8c:	aa01      	add	r2, sp, #4
    2b8e:	68a1      	ldr	r1, [r4, #8]
    2b90:	4620      	mov	r0, r4
    2b92:	4b0c      	ldr	r3, [pc, #48]	; (2bc4 <fatfs_allocate_free_space+0x8c>)
    2b94:	4798      	blx	r3
    2b96:	4603      	mov	r3, r0
    2b98:	2800      	cmp	r0, #0
    2b9a:	d0f3      	beq.n	2b84 <fatfs_allocate_free_space+0x4c>
        if (clusterCount==1)
    2b9c:	2f01      	cmp	r7, #1
    2b9e:	d1e9      	bne.n	2b74 <fatfs_allocate_free_space+0x3c>
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
    2ba0:	f04f 32ff 	mov.w	r2, #4294967295
    2ba4:	9901      	ldr	r1, [sp, #4]
    2ba6:	4620      	mov	r0, r4
    2ba8:	4b07      	ldr	r3, [pc, #28]	; (2bc8 <fatfs_allocate_free_space+0x90>)
    2baa:	4798      	blx	r3
            *startCluster = nextcluster;
    2bac:	9b01      	ldr	r3, [sp, #4]
    2bae:	f8c8 3000 	str.w	r3, [r8]
            return 1;
    2bb2:	2301      	movs	r3, #1
    2bb4:	e7e6      	b.n	2b84 <fatfs_allocate_free_space+0x4c>
        return 0;
    2bb6:	2300      	movs	r3, #0
}
    2bb8:	4618      	mov	r0, r3
    2bba:	4770      	bx	lr
    2bbc:	000028b9 	.word	0x000028b9
    2bc0:	00002ac5 	.word	0x00002ac5
    2bc4:	00002925 	.word	0x00002925
    2bc8:	000029b1 	.word	0x000029b1

00002bcc <fatfs_add_file_entry>:
}
//-----------------------------------------------------------------------------
// fatfs_add_file_entry: Add a directory entry to a location found by FindFreeOffset
//-----------------------------------------------------------------------------
int fatfs_add_file_entry(struct fatfs *fs, uint32 dirCluster, char *filename, char *shortfilename, uint32 startCluster, uint32 size, int dir)
{
    2bcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2bd0:	b097      	sub	sp, #92	; 0x5c

    uint8 checksum;
    uint8 *pSname;

    // No write access?
    if (!fs->disk_io.write_media)
    2bd2:	6b44      	ldr	r4, [r0, #52]	; 0x34
    2bd4:	2c00      	cmp	r4, #0
    2bd6:	f000 80d3 	beq.w	2d80 <fatfs_add_file_entry+0x1b4>
    2bda:	930a      	str	r3, [sp, #40]	; 0x28
    2bdc:	9207      	str	r2, [sp, #28]
    2bde:	9109      	str	r1, [sp, #36]	; 0x24
    2be0:	9008      	str	r0, [sp, #32]
        return 0;

#if FATFS_INC_LFN_SUPPORT
    // How many LFN entries are required?
    // NOTE: We always request one LFN even if it would fit in a SFN!
    entryCount = fatfs_lfn_entries_required(filename);
    2be2:	4610      	mov	r0, r2
    2be4:	4b89      	ldr	r3, [pc, #548]	; (2e0c <fatfs_add_file_entry+0x240>)
    2be6:	4798      	blx	r3
    if (!entryCount)
    2be8:	4607      	mov	r7, r0
    2bea:	b918      	cbnz	r0, 2bf4 <fatfs_add_file_entry+0x28>
        else
            return 0;
    } // End of while loop

    return 0;
}
    2bec:	4638      	mov	r0, r7
    2bee:	b017      	add	sp, #92	; 0x5c
    2bf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (entryCount == 0)
    2bf4:	f110 0b01 	adds.w	fp, r0, #1
    2bf8:	f000 80c4 	beq.w	2d84 <fatfs_add_file_entry+0x1b8>
    2bfc:	2300      	movs	r3, #0
    2bfe:	9305      	str	r3, [sp, #20]
    2c00:	9303      	str	r3, [sp, #12]
    2c02:	461e      	mov	r6, r3
                if (fatfs_entry_lfn_text(directoryEntry))
    2c04:	f8df 9220 	ldr.w	r9, [pc, #544]	; 2e28 <fatfs_add_file_entry+0x25c>
    2c08:	4698      	mov	r8, r3
    2c0a:	9306      	str	r3, [sp, #24]
    2c0c:	900b      	str	r0, [sp, #44]	; 0x2c
    2c0e:	e04e      	b.n	2cae <fatfs_add_file_entry+0xe2>
                    possible_spaces++;
    2c10:	3601      	adds	r6, #1
    2c12:	3401      	adds	r4, #1
    2c14:	3520      	adds	r5, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    2c16:	2c10      	cmp	r4, #16
    2c18:	d047      	beq.n	2caa <fatfs_add_file_entry+0xde>
    2c1a:	b2e7      	uxtb	r7, r4
                if (fatfs_entry_lfn_text(directoryEntry))
    2c1c:	4628      	mov	r0, r5
    2c1e:	47c8      	blx	r9
    2c20:	b138      	cbz	r0, 2c32 <fatfs_add_file_entry+0x66>
                    if (possible_spaces == 0)
    2c22:	2e00      	cmp	r6, #0
    2c24:	d1f4      	bne.n	2c10 <fatfs_add_file_entry+0x44>
    2c26:	9705      	str	r7, [sp, #20]
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2c28:	9b04      	ldr	r3, [sp, #16]
    2c2a:	9306      	str	r3, [sp, #24]
                        start_recorded = 1;
    2c2c:	f8cd a00c 	str.w	sl, [sp, #12]
    2c30:	e7ee      	b.n	2c10 <fatfs_add_file_entry+0x44>
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
    2c32:	782a      	ldrb	r2, [r5, #0]
    2c34:	2ae5      	cmp	r2, #229	; 0xe5
    2c36:	d028      	beq.n	2c8a <fatfs_add_file_entry+0xbe>
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
    2c38:	bba2      	cbnz	r2, 2ca4 <fatfs_add_file_entry+0xd8>
                        if (possible_spaces == 0)
    2c3a:	b926      	cbnz	r6, 2c46 <fatfs_add_file_entry+0x7a>
    2c3c:	9705      	str	r7, [sp, #20]
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2c3e:	9b04      	ldr	r3, [sp, #16]
    2c40:	9306      	str	r3, [sp, #24]
                            start_recorded = 1;
    2c42:	f8cd a00c 	str.w	sl, [sp, #12]
                        possible_spaces++;
    2c46:	3601      	adds	r6, #1
                        if (possible_spaces >= entryCount)
    2c48:	45b3      	cmp	fp, r6
    2c4a:	dce2      	bgt.n	2c12 <fatfs_add_file_entry+0x46>
    2c4c:	f8dd a018 	ldr.w	sl, [sp, #24]
    2c50:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    2c52:	990a      	ldr	r1, [sp, #40]	; 0x28
    2c54:	f101 000b 	add.w	r0, r1, #11
            for (i=0;i<fs->sectors_per_cluster;i++)
    2c58:	2500      	movs	r5, #0
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
    2c5a:	f005 0201 	and.w	r2, r5, #1
    2c5e:	f811 3b01 	ldrb.w	r3, [r1], #1
    2c62:	eb03 0355 	add.w	r3, r3, r5, lsr #1
    2c66:	eb03 13c2 	add.w	r3, r3, r2, lsl #7
    2c6a:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    2c6e:	4281      	cmp	r1, r0
    2c70:	d1f3      	bne.n	2c5a <fatfs_add_file_entry+0x8e>
    2c72:	46d1      	mov	r9, sl
    2c74:	f04f 0800 	mov.w	r8, #0
    2c78:	f8cd 800c 	str.w	r8, [sp, #12]
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum);
    2c7c:	f8df b1ac 	ldr.w	fp, [pc, #428]	; 2e2c <fatfs_add_file_entry+0x260>
    2c80:	9506      	str	r5, [sp, #24]
    2c82:	4646      	mov	r6, r8
    2c84:	f8dd 8014 	ldr.w	r8, [sp, #20]
    2c88:	e05f      	b.n	2d4a <fatfs_add_file_entry+0x17e>
                        if (possible_spaces == 0)
    2c8a:	b926      	cbnz	r6, 2c96 <fatfs_add_file_entry+0xca>
    2c8c:	9705      	str	r7, [sp, #20]
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2c8e:	9b04      	ldr	r3, [sp, #16]
    2c90:	9306      	str	r3, [sp, #24]
                            start_recorded = 1;
    2c92:	f8cd a00c 	str.w	sl, [sp, #12]
                        possible_spaces++;
    2c96:	3601      	adds	r6, #1
                        if (possible_spaces >= entryCount)
    2c98:	45b3      	cmp	fp, r6
    2c9a:	dcba      	bgt.n	2c12 <fatfs_add_file_entry+0x46>
    2c9c:	f8dd a018 	ldr.w	sl, [sp, #24]
    2ca0:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    2ca2:	e7d6      	b.n	2c52 <fatfs_add_file_entry+0x86>
                        start_recorded = 0;
    2ca4:	9003      	str	r0, [sp, #12]
                        possible_spaces = 0;
    2ca6:	4606      	mov	r6, r0
    2ca8:	e7b3      	b.n	2c12 <fatfs_add_file_entry+0x46>
    2caa:	f108 0801 	add.w	r8, r8, #1
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2cae:	f8cd 8010 	str.w	r8, [sp, #16]
    2cb2:	2300      	movs	r3, #0
    2cb4:	4642      	mov	r2, r8
    2cb6:	9909      	ldr	r1, [sp, #36]	; 0x24
    2cb8:	9d08      	ldr	r5, [sp, #32]
    2cba:	4628      	mov	r0, r5
    2cbc:	4c54      	ldr	r4, [pc, #336]	; (2e10 <fatfs_add_file_entry+0x244>)
    2cbe:	47a0      	blx	r4
    2cc0:	4604      	mov	r4, r0
    2cc2:	b120      	cbz	r0, 2cce <fatfs_add_file_entry+0x102>
    2cc4:	3540      	adds	r5, #64	; 0x40
    2cc6:	2400      	movs	r4, #0
                            start_recorded = 1;
    2cc8:	f04f 0a01 	mov.w	sl, #1
    2ccc:	e7a5      	b.n	2c1a <fatfs_add_file_entry+0x4e>
    2cce:	f8dd a018 	ldr.w	sl, [sp, #24]
    2cd2:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
            if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &newCluster))
    2cd4:	aa0d      	add	r2, sp, #52	; 0x34
    2cd6:	9808      	ldr	r0, [sp, #32]
    2cd8:	6881      	ldr	r1, [r0, #8]
    2cda:	4b4e      	ldr	r3, [pc, #312]	; (2e14 <fatfs_add_file_entry+0x248>)
    2cdc:	4798      	blx	r3
    2cde:	b908      	cbnz	r0, 2ce4 <fatfs_add_file_entry+0x118>
        return 0;
    2ce0:	4627      	mov	r7, r4
    2ce2:	e783      	b.n	2bec <fatfs_add_file_entry+0x20>
            if (!fatfs_fat_add_cluster_to_chain(fs, dirCluster, newCluster))
    2ce4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    2ce6:	9909      	ldr	r1, [sp, #36]	; 0x24
    2ce8:	9808      	ldr	r0, [sp, #32]
    2cea:	4b4b      	ldr	r3, [pc, #300]	; (2e18 <fatfs_add_file_entry+0x24c>)
    2cec:	4798      	blx	r3
    2cee:	2800      	cmp	r0, #0
    2cf0:	d0f6      	beq.n	2ce0 <fatfs_add_file_entry+0x114>
            memset(fs->currentsector.sector, 0x00, FAT_SECTOR_SIZE);
    2cf2:	f44f 7200 	mov.w	r2, #512	; 0x200
    2cf6:	2100      	movs	r1, #0
    2cf8:	9d08      	ldr	r5, [sp, #32]
    2cfa:	f105 0040 	add.w	r0, r5, #64	; 0x40
    2cfe:	4b47      	ldr	r3, [pc, #284]	; (2e1c <fatfs_add_file_entry+0x250>)
    2d00:	4798      	blx	r3
            for (i=0;i<fs->sectors_per_cluster;i++)
    2d02:	782b      	ldrb	r3, [r5, #0]
    2d04:	b18b      	cbz	r3, 2d2a <fatfs_add_file_entry+0x15e>
    2d06:	2500      	movs	r5, #0
                if (!fatfs_write_sector(fs, newCluster, i, 0))
    2d08:	46a8      	mov	r8, r5
    2d0a:	4e45      	ldr	r6, [pc, #276]	; (2e20 <fatfs_add_file_entry+0x254>)
    2d0c:	4643      	mov	r3, r8
    2d0e:	462a      	mov	r2, r5
    2d10:	990d      	ldr	r1, [sp, #52]	; 0x34
    2d12:	f8dd 9020 	ldr.w	r9, [sp, #32]
    2d16:	4648      	mov	r0, r9
    2d18:	47b0      	blx	r6
    2d1a:	2800      	cmp	r0, #0
    2d1c:	d0e0      	beq.n	2ce0 <fatfs_add_file_entry+0x114>
            for (i=0;i<fs->sectors_per_cluster;i++)
    2d1e:	3501      	adds	r5, #1
    2d20:	b2ed      	uxtb	r5, r5
    2d22:	f899 3000 	ldrb.w	r3, [r9]
    2d26:	42ab      	cmp	r3, r5
    2d28:	d8f0      	bhi.n	2d0c <fatfs_add_file_entry+0x140>
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2d2a:	9b04      	ldr	r3, [sp, #16]
    2d2c:	4619      	mov	r1, r3
    2d2e:	9a03      	ldr	r2, [sp, #12]
    2d30:	2a00      	cmp	r2, #0
    2d32:	bf08      	it	eq
    2d34:	468a      	moveq	sl, r1
    2d36:	2a00      	cmp	r2, #0
    2d38:	9b05      	ldr	r3, [sp, #20]
    2d3a:	bf08      	it	eq
    2d3c:	2300      	moveq	r3, #0
    2d3e:	9305      	str	r3, [sp, #20]
    2d40:	e787      	b.n	2c52 <fatfs_add_file_entry+0x86>
            if (dirtySector)
    2d42:	9b03      	ldr	r3, [sp, #12]
    2d44:	b973      	cbnz	r3, 2d64 <fatfs_add_file_entry+0x198>
        if (fatfs_sector_reader(fs, dirCluster, x++, 0))
    2d46:	f109 0901 	add.w	r9, r9, #1
    2d4a:	2300      	movs	r3, #0
    2d4c:	464a      	mov	r2, r9
    2d4e:	9909      	ldr	r1, [sp, #36]	; 0x24
    2d50:	9d08      	ldr	r5, [sp, #32]
    2d52:	4628      	mov	r0, r5
    2d54:	4c2e      	ldr	r4, [pc, #184]	; (2e10 <fatfs_add_file_entry+0x244>)
    2d56:	47a0      	blx	r4
    2d58:	b1b0      	cbz	r0, 2d88 <fatfs_add_file_entry+0x1bc>
    2d5a:	3540      	adds	r5, #64	; 0x40
    2d5c:	2400      	movs	r4, #0
                        dirtySector = 1;
    2d5e:	2301      	movs	r3, #1
    2d60:	9304      	str	r3, [sp, #16]
    2d62:	e023      	b.n	2dac <fatfs_add_file_entry+0x1e0>
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
    2d64:	9808      	ldr	r0, [sp, #32]
    2d66:	6b43      	ldr	r3, [r0, #52]	; 0x34
    2d68:	2201      	movs	r2, #1
    2d6a:	4601      	mov	r1, r0
    2d6c:	3140      	adds	r1, #64	; 0x40
    2d6e:	f8d0 0240 	ldr.w	r0, [r0, #576]	; 0x240
    2d72:	4798      	blx	r3
    2d74:	b110      	cbz	r0, 2d7c <fatfs_add_file_entry+0x1b0>
                dirtySector = 0;
    2d76:	2300      	movs	r3, #0
    2d78:	9303      	str	r3, [sp, #12]
    2d7a:	e7e4      	b.n	2d46 <fatfs_add_file_entry+0x17a>
                    return 0;
    2d7c:	4607      	mov	r7, r0
    2d7e:	e735      	b.n	2bec <fatfs_add_file_entry+0x20>
        return 0;
    2d80:	2700      	movs	r7, #0
    2d82:	e733      	b.n	2bec <fatfs_add_file_entry+0x20>
        return 0;
    2d84:	465f      	mov	r7, fp
    2d86:	e731      	b.n	2bec <fatfs_add_file_entry+0x20>
            return 0;
    2d88:	4607      	mov	r7, r0
    2d8a:	e72f      	b.n	2bec <fatfs_add_file_entry+0x20>
    2d8c:	0163      	lsls	r3, r4, #5
    2d8e:	b29b      	uxth	r3, r3
                    if (entryCount==0)
    2d90:	b1a7      	cbz	r7, 2dbc <fatfs_add_file_entry+0x1f0>
                        entryCount--;
    2d92:	3f01      	subs	r7, #1
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum);
    2d94:	9b06      	ldr	r3, [sp, #24]
    2d96:	463a      	mov	r2, r7
    2d98:	4629      	mov	r1, r5
    2d9a:	9807      	ldr	r0, [sp, #28]
    2d9c:	47d8      	blx	fp
    2d9e:	2601      	movs	r6, #1
                        dirtySector = 1;
    2da0:	9b04      	ldr	r3, [sp, #16]
    2da2:	9303      	str	r3, [sp, #12]
    2da4:	3401      	adds	r4, #1
    2da6:	3520      	adds	r5, #32
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
    2da8:	2c10      	cmp	r4, #16
    2daa:	d0ca      	beq.n	2d42 <fatfs_add_file_entry+0x176>
                if (foundEnd==0)
    2dac:	2e00      	cmp	r6, #0
    2dae:	d1ed      	bne.n	2d8c <fatfs_add_file_entry+0x1c0>
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
    2db0:	45d1      	cmp	r9, sl
    2db2:	d1f7      	bne.n	2da4 <fatfs_add_file_entry+0x1d8>
    2db4:	b2e3      	uxtb	r3, r4
    2db6:	4598      	cmp	r8, r3
    2db8:	d1f4      	bne.n	2da4 <fatfs_add_file_entry+0x1d8>
    2dba:	e7e7      	b.n	2d8c <fatfs_add_file_entry+0x1c0>
    2dbc:	4698      	mov	r8, r3
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
    2dbe:	9b22      	ldr	r3, [sp, #136]	; 0x88
    2dc0:	9300      	str	r3, [sp, #0]
    2dc2:	ab0e      	add	r3, sp, #56	; 0x38
    2dc4:	9a20      	ldr	r2, [sp, #128]	; 0x80
    2dc6:	9921      	ldr	r1, [sp, #132]	; 0x84
    2dc8:	980a      	ldr	r0, [sp, #40]	; 0x28
    2dca:	4c16      	ldr	r4, [pc, #88]	; (2e24 <fatfs_add_file_entry+0x258>)
    2dcc:	47a0      	blx	r4
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));
    2dce:	9e08      	ldr	r6, [sp, #32]
    2dd0:	44b0      	add	r8, r6
    2dd2:	ac0e      	add	r4, sp, #56	; 0x38
    2dd4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    2dd6:	f8c8 0040 	str.w	r0, [r8, #64]	; 0x40
    2dda:	f8c8 1044 	str.w	r1, [r8, #68]	; 0x44
    2dde:	f8c8 2048 	str.w	r2, [r8, #72]	; 0x48
    2de2:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
    2de6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    2de8:	f8c8 0050 	str.w	r0, [r8, #80]	; 0x50
    2dec:	f8c8 1054 	str.w	r1, [r8, #84]	; 0x54
    2df0:	f8c8 2058 	str.w	r2, [r8, #88]	; 0x58
    2df4:	f8c8 305c 	str.w	r3, [r8, #92]	; 0x5c
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
    2df8:	6b73      	ldr	r3, [r6, #52]	; 0x34
    2dfa:	2201      	movs	r2, #1
    2dfc:	4631      	mov	r1, r6
    2dfe:	3140      	adds	r1, #64	; 0x40
    2e00:	f8d6 0240 	ldr.w	r0, [r6, #576]	; 0x240
    2e04:	4798      	blx	r3
    2e06:	4607      	mov	r7, r0
    2e08:	e6f0      	b.n	2bec <fatfs_add_file_entry+0x20>
    2e0a:	bf00      	nop
    2e0c:	00002151 	.word	0x00002151
    2e10:	00001021 	.word	0x00001021
    2e14:	00002925 	.word	0x00002925
    2e18:	00002a79 	.word	0x00002a79
    2e1c:	00003a71 	.word	0x00003a71
    2e20:	000010b1 	.word	0x000010b1
    2e24:	00002229 	.word	0x00002229
    2e28:	000020a5 	.word	0x000020a5
    2e2c:	00002175 	.word	0x00002175

00002e30 <media_read>:
	throw_error();
}

int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
	unsigned long i;
	for (i=0;i<sector_count;i++){
    2e30:	b17a      	cbz	r2, 2e52 <media_read+0x22>
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
    2e32:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e34:	4604      	mov	r4, r0
    2e36:	460d      	mov	r5, r1
    2e38:	4616      	mov	r6, r2
    2e3a:	4406      	add	r6, r0
		SD_read_single_block(sector, buffer);
    2e3c:	4f06      	ldr	r7, [pc, #24]	; (2e58 <media_read+0x28>)
    2e3e:	4629      	mov	r1, r5
    2e40:	4620      	mov	r0, r4
    2e42:	47b8      	blx	r7
		sector ++;
    2e44:	3401      	adds	r4, #1
		buffer += 512;
    2e46:	f505 7500 	add.w	r5, r5, #512	; 0x200
	for (i=0;i<sector_count;i++){
    2e4a:	42a6      	cmp	r6, r4
    2e4c:	d1f7      	bne.n	2e3e <media_read+0xe>
	}
	return 1;
}
    2e4e:	2001      	movs	r0, #1
    2e50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2e52:	2001      	movs	r0, #1
    2e54:	4770      	bx	lr
    2e56:	bf00      	nop
    2e58:	00000709 	.word	0x00000709

00002e5c <media_write>:

int media_write(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
	unsigned long i;
	for (i=0;i<sector_count;i++){
    2e5c:	b17a      	cbz	r2, 2e7e <media_write+0x22>
int media_write(unsigned long sector, unsigned char *buffer, unsigned long sector_count){
    2e5e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e60:	4604      	mov	r4, r0
    2e62:	460d      	mov	r5, r1
    2e64:	4616      	mov	r6, r2
    2e66:	4406      	add	r6, r0
		SD_write_single_block(sector, buffer);
    2e68:	4f06      	ldr	r7, [pc, #24]	; (2e84 <media_write+0x28>)
    2e6a:	4629      	mov	r1, r5
    2e6c:	4620      	mov	r0, r4
    2e6e:	47b8      	blx	r7
		sector ++;
    2e70:	3401      	adds	r4, #1
		buffer += 512;
    2e72:	f505 7500 	add.w	r5, r5, #512	; 0x200
	for (i=0;i<sector_count;i++){
    2e76:	42a6      	cmp	r6, r4
    2e78:	d1f7      	bne.n	2e6a <media_write+0xe>
	}
	return 1;
    2e7a:	2001      	movs	r0, #1
    2e7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2e7e:	2001      	movs	r0, #1
    2e80:	4770      	bx	lr
    2e82:	bf00      	nop
    2e84:	000006a5 	.word	0x000006a5

00002e88 <main>:
int main(void){
    2e88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e8c:	b089      	sub	sp, #36	; 0x24
    2e8e:	af00      	add	r7, sp, #0
	SystemInit();
    2e90:	4b53      	ldr	r3, [pc, #332]	; (2fe0 <main+0x158>)
    2e92:	4798      	blx	r3
	PM_init();
    2e94:	4b53      	ldr	r3, [pc, #332]	; (2fe4 <main+0x15c>)
    2e96:	4798      	blx	r3
	RCFAST_init();
    2e98:	4b53      	ldr	r3, [pc, #332]	; (2fe8 <main+0x160>)
    2e9a:	4798      	blx	r3
	USART_init(Tx, Rx);
    2e9c:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
    2ea0:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    2ea4:	4b51      	ldr	r3, [pc, #324]	; (2fec <main+0x164>)
    2ea6:	4798      	blx	r3
	USART_newline();
    2ea8:	4c51      	ldr	r4, [pc, #324]	; (2ff0 <main+0x168>)
    2eaa:	47a0      	blx	r4
	USART_printf("System initialization...");
    2eac:	4851      	ldr	r0, [pc, #324]	; (2ff4 <main+0x16c>)
    2eae:	4b52      	ldr	r3, [pc, #328]	; (2ff8 <main+0x170>)
    2eb0:	4798      	blx	r3
	USART_newline();
    2eb2:	47a0      	blx	r4
	TWI_init(SCL, SDA);
    2eb4:	4b51      	ldr	r3, [pc, #324]	; (2ffc <main+0x174>)
    2eb6:	6819      	ldr	r1, [r3, #0]
    2eb8:	6858      	ldr	r0, [r3, #4]
    2eba:	4b51      	ldr	r3, [pc, #324]	; (3000 <main+0x178>)
    2ebc:	4798      	blx	r3
	SPI_init();
    2ebe:	4b51      	ldr	r3, [pc, #324]	; (3004 <main+0x17c>)
    2ec0:	4798      	blx	r3
	SD_init();
    2ec2:	4b51      	ldr	r3, [pc, #324]	; (3008 <main+0x180>)
    2ec4:	4798      	blx	r3
	fl_init();
    2ec6:	4b51      	ldr	r3, [pc, #324]	; (300c <main+0x184>)
    2ec8:	4798      	blx	r3
	if (fl_attach_media(media_read, media_write) != FAT_INIT_OK)
    2eca:	4951      	ldr	r1, [pc, #324]	; (3010 <main+0x188>)
    2ecc:	4851      	ldr	r0, [pc, #324]	; (3014 <main+0x18c>)
    2ece:	4b52      	ldr	r3, [pc, #328]	; (3018 <main+0x190>)
    2ed0:	4798      	blx	r3
    2ed2:	b958      	cbnz	r0, 2eec <main+0x64>
	set_config_register(I2C_Address, config);
    2ed4:	2160      	movs	r1, #96	; 0x60
    2ed6:	4b49      	ldr	r3, [pc, #292]	; (2ffc <main+0x174>)
    2ed8:	7a18      	ldrb	r0, [r3, #8]
    2eda:	4b50      	ldr	r3, [pc, #320]	; (301c <main+0x194>)
    2edc:	4798      	blx	r3
		file = fl_fopen("/temp_log.csv", "a"); //open log file in append mode
    2ede:	f8df 9188 	ldr.w	r9, [pc, #392]	; 3068 <main+0x1e0>
		volatile float float_temp = (float)temp_reading*.0625;
    2ee2:	f04f 5b76 	mov.w	fp, #1031798784	; 0x3d800000
		fpart = fpart*1000;
    2ee6:	f8df a184 	ldr.w	sl, [pc, #388]	; 306c <main+0x1e4>
    2eea:	e01a      	b.n	2f22 <main+0x9a>
		USART_printf("ERROR: Media attach failed");
    2eec:	484c      	ldr	r0, [pc, #304]	; (3020 <main+0x198>)
    2eee:	4b42      	ldr	r3, [pc, #264]	; (2ff8 <main+0x170>)
    2ef0:	4798      	blx	r3
		USART_newline();
    2ef2:	47a0      	blx	r4
		throw_error();
    2ef4:	4b4b      	ldr	r3, [pc, #300]	; (3024 <main+0x19c>)
    2ef6:	4798      	blx	r3
    2ef8:	e7ec      	b.n	2ed4 <main+0x4c>
			USART_printf("ERROR: Failed to open file");
    2efa:	484b      	ldr	r0, [pc, #300]	; (3028 <main+0x1a0>)
    2efc:	4b3e      	ldr	r3, [pc, #248]	; (2ff8 <main+0x170>)
    2efe:	4798      	blx	r3
			USART_newline();
    2f00:	4b3b      	ldr	r3, [pc, #236]	; (2ff0 <main+0x168>)
    2f02:	4798      	blx	r3
			delay_ms_2(1000);
    2f04:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    2f08:	2100      	movs	r1, #0
    2f0a:	4b48      	ldr	r3, [pc, #288]	; (302c <main+0x1a4>)
    2f0c:	4798      	blx	r3
    2f0e:	e008      	b.n	2f22 <main+0x9a>
		fl_fclose(file);
    2f10:	4628      	mov	r0, r5
    2f12:	4b47      	ldr	r3, [pc, #284]	; (3030 <main+0x1a8>)
    2f14:	4798      	blx	r3
		delay_ms_2(1000);
    2f16:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    2f1a:	2100      	movs	r1, #0
    2f1c:	4b43      	ldr	r3, [pc, #268]	; (302c <main+0x1a4>)
    2f1e:	4798      	blx	r3
    2f20:	46c5      	mov	sp, r8
	while(1){
    2f22:	46e8      	mov	r8, sp
		file = fl_fopen("/temp_log.csv", "a"); //open log file in append mode
    2f24:	4649      	mov	r1, r9
    2f26:	4843      	ldr	r0, [pc, #268]	; (3034 <main+0x1ac>)
    2f28:	4b43      	ldr	r3, [pc, #268]	; (3038 <main+0x1b0>)
    2f2a:	4798      	blx	r3
		if (!file){
    2f2c:	4605      	mov	r5, r0
    2f2e:	2800      	cmp	r0, #0
    2f30:	d0e3      	beq.n	2efa <main+0x72>
		volatile uint16_t  temp_reading = get_temp_12bit(I2C_Address);
    2f32:	4b32      	ldr	r3, [pc, #200]	; (2ffc <main+0x174>)
    2f34:	7a18      	ldrb	r0, [r3, #8]
    2f36:	4b41      	ldr	r3, [pc, #260]	; (303c <main+0x1b4>)
    2f38:	4798      	blx	r3
    2f3a:	8178      	strh	r0, [r7, #10]
		volatile float float_temp = (float)temp_reading*.0625;
    2f3c:	8978      	ldrh	r0, [r7, #10]
    2f3e:	b280      	uxth	r0, r0
    2f40:	4b3f      	ldr	r3, [pc, #252]	; (3040 <main+0x1b8>)
    2f42:	4798      	blx	r3
    2f44:	4e3f      	ldr	r6, [pc, #252]	; (3044 <main+0x1bc>)
    2f46:	4659      	mov	r1, fp
    2f48:	47b0      	blx	r6
    2f4a:	60f8      	str	r0, [r7, #12]
		volatile int ipart = (int)float_temp; 
    2f4c:	68f8      	ldr	r0, [r7, #12]
    2f4e:	4c3e      	ldr	r4, [pc, #248]	; (3048 <main+0x1c0>)
    2f50:	47a0      	blx	r4
    2f52:	6138      	str	r0, [r7, #16]
		volatile float fpart = float_temp - (float)ipart; 
    2f54:	68fb      	ldr	r3, [r7, #12]
    2f56:	607b      	str	r3, [r7, #4]
    2f58:	6938      	ldr	r0, [r7, #16]
    2f5a:	4b3c      	ldr	r3, [pc, #240]	; (304c <main+0x1c4>)
    2f5c:	4798      	blx	r3
    2f5e:	4601      	mov	r1, r0
    2f60:	6878      	ldr	r0, [r7, #4]
    2f62:	4b3b      	ldr	r3, [pc, #236]	; (3050 <main+0x1c8>)
    2f64:	4798      	blx	r3
    2f66:	6178      	str	r0, [r7, #20]
		fpart = fpart*1000;
    2f68:	6978      	ldr	r0, [r7, #20]
    2f6a:	4651      	mov	r1, sl
    2f6c:	47b0      	blx	r6
    2f6e:	6178      	str	r0, [r7, #20]
		USART_printf("%d.%d",ipart,(int)fpart);
    2f70:	693e      	ldr	r6, [r7, #16]
    2f72:	6978      	ldr	r0, [r7, #20]
    2f74:	47a0      	blx	r4
    2f76:	4602      	mov	r2, r0
    2f78:	4631      	mov	r1, r6
    2f7a:	4836      	ldr	r0, [pc, #216]	; (3054 <main+0x1cc>)
    2f7c:	4b1e      	ldr	r3, [pc, #120]	; (2ff8 <main+0x170>)
    2f7e:	4798      	blx	r3
		USART_newline();
    2f80:	4b1b      	ldr	r3, [pc, #108]	; (2ff0 <main+0x168>)
    2f82:	4798      	blx	r3
		itoa(ipart, tmp, 10);
    2f84:	6938      	ldr	r0, [r7, #16]
    2f86:	220a      	movs	r2, #10
    2f88:	f107 0108 	add.w	r1, r7, #8
    2f8c:	4b32      	ldr	r3, [pc, #200]	; (3058 <main+0x1d0>)
    2f8e:	4798      	blx	r3
		strcpy(&data_packet[j], tmp);
    2f90:	f107 0108 	add.w	r1, r7, #8
    2f94:	f107 0018 	add.w	r0, r7, #24
    2f98:	4e30      	ldr	r6, [pc, #192]	; (305c <main+0x1d4>)
    2f9a:	47b0      	blx	r6
		data_packet[j] =  46; //period
    2f9c:	232e      	movs	r3, #46	; 0x2e
    2f9e:	76bb      	strb	r3, [r7, #26]
		itoa((int)fpart, tmp, 10);
    2fa0:	6978      	ldr	r0, [r7, #20]
    2fa2:	47a0      	blx	r4
    2fa4:	220a      	movs	r2, #10
    2fa6:	f107 0108 	add.w	r1, r7, #8
    2faa:	4b2b      	ldr	r3, [pc, #172]	; (3058 <main+0x1d0>)
    2fac:	4798      	blx	r3
		strcpy(&data_packet[j], tmp);
    2fae:	f107 0108 	add.w	r1, r7, #8
    2fb2:	f107 001b 	add.w	r0, r7, #27
    2fb6:	47b0      	blx	r6
		data_packet[j] = 13; //carriage return
    2fb8:	230d      	movs	r3, #13
    2fba:	777b      	strb	r3, [r7, #29]
		data_packet[j] = 10; //line feed
    2fbc:	230a      	movs	r3, #10
    2fbe:	77bb      	strb	r3, [r7, #30]
		if (fl_fwrite(data_packet, 1, sizeof(data_packet), file) != sizeof(data_packet)){
    2fc0:	462b      	mov	r3, r5
    2fc2:	2207      	movs	r2, #7
    2fc4:	2101      	movs	r1, #1
    2fc6:	f107 0018 	add.w	r0, r7, #24
    2fca:	4c25      	ldr	r4, [pc, #148]	; (3060 <main+0x1d8>)
    2fcc:	47a0      	blx	r4
    2fce:	2807      	cmp	r0, #7
    2fd0:	d09e      	beq.n	2f10 <main+0x88>
			USART_printf("ERROR: Write file failed\n");
    2fd2:	4824      	ldr	r0, [pc, #144]	; (3064 <main+0x1dc>)
    2fd4:	4b08      	ldr	r3, [pc, #32]	; (2ff8 <main+0x170>)
    2fd6:	4798      	blx	r3
			USART_newline();
    2fd8:	4b05      	ldr	r3, [pc, #20]	; (2ff0 <main+0x168>)
    2fda:	4798      	blx	r3
    2fdc:	e798      	b.n	2f10 <main+0x88>
    2fde:	bf00      	nop
    2fe0:	00000d4d 	.word	0x00000d4d
    2fe4:	00003071 	.word	0x00003071
    2fe8:	00000c3d 	.word	0x00000c3d
    2fec:	000009fd 	.word	0x000009fd
    2ff0:	0000099d 	.word	0x0000099d
    2ff4:	00003f68 	.word	0x00003f68
    2ff8:	00000a65 	.word	0x00000a65
    2ffc:	20000010 	.word	0x20000010
    3000:	00000285 	.word	0x00000285
    3004:	000002f5 	.word	0x000002f5
    3008:	00000849 	.word	0x00000849
    300c:	000018b9 	.word	0x000018b9
    3010:	00002e5d 	.word	0x00002e5d
    3014:	00002e31 	.word	0x00002e31
    3018:	000018e9 	.word	0x000018e9
    301c:	00000c95 	.word	0x00000c95
    3020:	00003f84 	.word	0x00003f84
    3024:	00000b49 	.word	0x00000b49
    3028:	00003fb4 	.word	0x00003fb4
    302c:	00000c05 	.word	0x00000c05
    3030:	00001dc1 	.word	0x00001dc1
    3034:	00003fa4 	.word	0x00003fa4
    3038:	00001925 	.word	0x00001925
    303c:	00000c71 	.word	0x00000c71
    3040:	0000320d 	.word	0x0000320d
    3044:	000032bd 	.word	0x000032bd
    3048:	0000355d 	.word	0x0000355d
    304c:	00003215 	.word	0x00003215
    3050:	000030a9 	.word	0x000030a9
    3054:	00003fd0 	.word	0x00003fd0
    3058:	00003939 	.word	0x00003939
    305c:	00003b0d 	.word	0x00003b0d
    3060:	00001e41 	.word	0x00001e41
    3064:	00003fd8 	.word	0x00003fd8
    3068:	00003fa0 	.word	0x00003fa0
    306c:	447a0000 	.word	0x447a0000

00003070 <PM_init>:
    3070:	4b07      	ldr	r3, [pc, #28]	; (3090 <PM_init+0x20>)
    3072:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
    3076:	f042 0201 	orr.w	r2, r2, #1
    307a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    307e:	4a05      	ldr	r2, [pc, #20]	; (3094 <PM_init+0x24>)
    3080:	605a      	str	r2, [r3, #4]
    3082:	4b05      	ldr	r3, [pc, #20]	; (3098 <PM_init+0x28>)
    3084:	601a      	str	r2, [r3, #0]
    3086:	2000      	movs	r0, #0
    3088:	4b04      	ldr	r3, [pc, #16]	; (309c <PM_init+0x2c>)
    308a:	7018      	strb	r0, [r3, #0]
    308c:	4770      	bx	lr
    308e:	bf00      	nop
    3090:	20001174 	.word	0x20001174
    3094:	0001c138 	.word	0x0001c138
    3098:	2000116c 	.word	0x2000116c
    309c:	20001170 	.word	0x20001170

000030a0 <__aeabi_frsub>:
    30a0:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
    30a4:	e002      	b.n	30ac <__addsf3>
    30a6:	bf00      	nop

000030a8 <__aeabi_fsub>:
    30a8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

000030ac <__addsf3>:
    30ac:	0042      	lsls	r2, r0, #1
    30ae:	bf1f      	itttt	ne
    30b0:	ea5f 0341 	movsne.w	r3, r1, lsl #1
    30b4:	ea92 0f03 	teqne	r2, r3
    30b8:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
    30bc:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    30c0:	d06a      	beq.n	3198 <__addsf3+0xec>
    30c2:	ea4f 6212 	mov.w	r2, r2, lsr #24
    30c6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
    30ca:	bfc1      	itttt	gt
    30cc:	18d2      	addgt	r2, r2, r3
    30ce:	4041      	eorgt	r1, r0
    30d0:	4048      	eorgt	r0, r1
    30d2:	4041      	eorgt	r1, r0
    30d4:	bfb8      	it	lt
    30d6:	425b      	neglt	r3, r3
    30d8:	2b19      	cmp	r3, #25
    30da:	bf88      	it	hi
    30dc:	4770      	bxhi	lr
    30de:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    30e2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    30e6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    30ea:	bf18      	it	ne
    30ec:	4240      	negne	r0, r0
    30ee:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    30f2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
    30f6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    30fa:	bf18      	it	ne
    30fc:	4249      	negne	r1, r1
    30fe:	ea92 0f03 	teq	r2, r3
    3102:	d03f      	beq.n	3184 <__addsf3+0xd8>
    3104:	f1a2 0201 	sub.w	r2, r2, #1
    3108:	fa41 fc03 	asr.w	ip, r1, r3
    310c:	eb10 000c 	adds.w	r0, r0, ip
    3110:	f1c3 0320 	rsb	r3, r3, #32
    3114:	fa01 f103 	lsl.w	r1, r1, r3
    3118:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    311c:	d502      	bpl.n	3124 <__addsf3+0x78>
    311e:	4249      	negs	r1, r1
    3120:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
    3124:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    3128:	d313      	bcc.n	3152 <__addsf3+0xa6>
    312a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    312e:	d306      	bcc.n	313e <__addsf3+0x92>
    3130:	0840      	lsrs	r0, r0, #1
    3132:	ea4f 0131 	mov.w	r1, r1, rrx
    3136:	f102 0201 	add.w	r2, r2, #1
    313a:	2afe      	cmp	r2, #254	; 0xfe
    313c:	d251      	bcs.n	31e2 <__addsf3+0x136>
    313e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
    3142:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    3146:	bf08      	it	eq
    3148:	f020 0001 	biceq.w	r0, r0, #1
    314c:	ea40 0003 	orr.w	r0, r0, r3
    3150:	4770      	bx	lr
    3152:	0049      	lsls	r1, r1, #1
    3154:	eb40 0000 	adc.w	r0, r0, r0
    3158:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
    315c:	f1a2 0201 	sub.w	r2, r2, #1
    3160:	d1ed      	bne.n	313e <__addsf3+0x92>
    3162:	fab0 fc80 	clz	ip, r0
    3166:	f1ac 0c08 	sub.w	ip, ip, #8
    316a:	ebb2 020c 	subs.w	r2, r2, ip
    316e:	fa00 f00c 	lsl.w	r0, r0, ip
    3172:	bfaa      	itet	ge
    3174:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
    3178:	4252      	neglt	r2, r2
    317a:	4318      	orrge	r0, r3
    317c:	bfbc      	itt	lt
    317e:	40d0      	lsrlt	r0, r2
    3180:	4318      	orrlt	r0, r3
    3182:	4770      	bx	lr
    3184:	f092 0f00 	teq	r2, #0
    3188:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
    318c:	bf06      	itte	eq
    318e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
    3192:	3201      	addeq	r2, #1
    3194:	3b01      	subne	r3, #1
    3196:	e7b5      	b.n	3104 <__addsf3+0x58>
    3198:	ea4f 0341 	mov.w	r3, r1, lsl #1
    319c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    31a0:	bf18      	it	ne
    31a2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    31a6:	d021      	beq.n	31ec <__addsf3+0x140>
    31a8:	ea92 0f03 	teq	r2, r3
    31ac:	d004      	beq.n	31b8 <__addsf3+0x10c>
    31ae:	f092 0f00 	teq	r2, #0
    31b2:	bf08      	it	eq
    31b4:	4608      	moveq	r0, r1
    31b6:	4770      	bx	lr
    31b8:	ea90 0f01 	teq	r0, r1
    31bc:	bf1c      	itt	ne
    31be:	2000      	movne	r0, #0
    31c0:	4770      	bxne	lr
    31c2:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
    31c6:	d104      	bne.n	31d2 <__addsf3+0x126>
    31c8:	0040      	lsls	r0, r0, #1
    31ca:	bf28      	it	cs
    31cc:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
    31d0:	4770      	bx	lr
    31d2:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
    31d6:	bf3c      	itt	cc
    31d8:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
    31dc:	4770      	bxcc	lr
    31de:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    31e2:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
    31e6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    31ea:	4770      	bx	lr
    31ec:	ea7f 6222 	mvns.w	r2, r2, asr #24
    31f0:	bf16      	itet	ne
    31f2:	4608      	movne	r0, r1
    31f4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
    31f8:	4601      	movne	r1, r0
    31fa:	0242      	lsls	r2, r0, #9
    31fc:	bf06      	itte	eq
    31fe:	ea5f 2341 	movseq.w	r3, r1, lsl #9
    3202:	ea90 0f01 	teqeq	r0, r1
    3206:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
    320a:	4770      	bx	lr

0000320c <__aeabi_ui2f>:
    320c:	f04f 0300 	mov.w	r3, #0
    3210:	e004      	b.n	321c <__aeabi_i2f+0x8>
    3212:	bf00      	nop

00003214 <__aeabi_i2f>:
    3214:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
    3218:	bf48      	it	mi
    321a:	4240      	negmi	r0, r0
    321c:	ea5f 0c00 	movs.w	ip, r0
    3220:	bf08      	it	eq
    3222:	4770      	bxeq	lr
    3224:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
    3228:	4601      	mov	r1, r0
    322a:	f04f 0000 	mov.w	r0, #0
    322e:	e01c      	b.n	326a <__aeabi_l2f+0x2a>

00003230 <__aeabi_ul2f>:
    3230:	ea50 0201 	orrs.w	r2, r0, r1
    3234:	bf08      	it	eq
    3236:	4770      	bxeq	lr
    3238:	f04f 0300 	mov.w	r3, #0
    323c:	e00a      	b.n	3254 <__aeabi_l2f+0x14>
    323e:	bf00      	nop

00003240 <__aeabi_l2f>:
    3240:	ea50 0201 	orrs.w	r2, r0, r1
    3244:	bf08      	it	eq
    3246:	4770      	bxeq	lr
    3248:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
    324c:	d502      	bpl.n	3254 <__aeabi_l2f+0x14>
    324e:	4240      	negs	r0, r0
    3250:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    3254:	ea5f 0c01 	movs.w	ip, r1
    3258:	bf02      	ittt	eq
    325a:	4684      	moveq	ip, r0
    325c:	4601      	moveq	r1, r0
    325e:	2000      	moveq	r0, #0
    3260:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
    3264:	bf08      	it	eq
    3266:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
    326a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
    326e:	fabc f28c 	clz	r2, ip
    3272:	3a08      	subs	r2, #8
    3274:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
    3278:	db10      	blt.n	329c <__aeabi_l2f+0x5c>
    327a:	fa01 fc02 	lsl.w	ip, r1, r2
    327e:	4463      	add	r3, ip
    3280:	fa00 fc02 	lsl.w	ip, r0, r2
    3284:	f1c2 0220 	rsb	r2, r2, #32
    3288:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    328c:	fa20 f202 	lsr.w	r2, r0, r2
    3290:	eb43 0002 	adc.w	r0, r3, r2
    3294:	bf08      	it	eq
    3296:	f020 0001 	biceq.w	r0, r0, #1
    329a:	4770      	bx	lr
    329c:	f102 0220 	add.w	r2, r2, #32
    32a0:	fa01 fc02 	lsl.w	ip, r1, r2
    32a4:	f1c2 0220 	rsb	r2, r2, #32
    32a8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
    32ac:	fa21 f202 	lsr.w	r2, r1, r2
    32b0:	eb43 0002 	adc.w	r0, r3, r2
    32b4:	bf08      	it	eq
    32b6:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    32ba:	4770      	bx	lr

000032bc <__aeabi_fmul>:
    32bc:	f04f 0cff 	mov.w	ip, #255	; 0xff
    32c0:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    32c4:	bf1e      	ittt	ne
    32c6:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    32ca:	ea92 0f0c 	teqne	r2, ip
    32ce:	ea93 0f0c 	teqne	r3, ip
    32d2:	d06f      	beq.n	33b4 <__aeabi_fmul+0xf8>
    32d4:	441a      	add	r2, r3
    32d6:	ea80 0c01 	eor.w	ip, r0, r1
    32da:	0240      	lsls	r0, r0, #9
    32dc:	bf18      	it	ne
    32de:	ea5f 2141 	movsne.w	r1, r1, lsl #9
    32e2:	d01e      	beq.n	3322 <__aeabi_fmul+0x66>
    32e4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    32e8:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
    32ec:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
    32f0:	fba0 3101 	umull	r3, r1, r0, r1
    32f4:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    32f8:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    32fc:	bf3e      	ittt	cc
    32fe:	0049      	lslcc	r1, r1, #1
    3300:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
    3304:	005b      	lslcc	r3, r3, #1
    3306:	ea40 0001 	orr.w	r0, r0, r1
    330a:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
    330e:	2afd      	cmp	r2, #253	; 0xfd
    3310:	d81d      	bhi.n	334e <__aeabi_fmul+0x92>
    3312:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    3316:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    331a:	bf08      	it	eq
    331c:	f020 0001 	biceq.w	r0, r0, #1
    3320:	4770      	bx	lr
    3322:	f090 0f00 	teq	r0, #0
    3326:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    332a:	bf08      	it	eq
    332c:	0249      	lsleq	r1, r1, #9
    332e:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    3332:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
    3336:	3a7f      	subs	r2, #127	; 0x7f
    3338:	bfc2      	ittt	gt
    333a:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    333e:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    3342:	4770      	bxgt	lr
    3344:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    3348:	f04f 0300 	mov.w	r3, #0
    334c:	3a01      	subs	r2, #1
    334e:	dc5d      	bgt.n	340c <__aeabi_fmul+0x150>
    3350:	f112 0f19 	cmn.w	r2, #25
    3354:	bfdc      	itt	le
    3356:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
    335a:	4770      	bxle	lr
    335c:	f1c2 0200 	rsb	r2, r2, #0
    3360:	0041      	lsls	r1, r0, #1
    3362:	fa21 f102 	lsr.w	r1, r1, r2
    3366:	f1c2 0220 	rsb	r2, r2, #32
    336a:	fa00 fc02 	lsl.w	ip, r0, r2
    336e:	ea5f 0031 	movs.w	r0, r1, rrx
    3372:	f140 0000 	adc.w	r0, r0, #0
    3376:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
    337a:	bf08      	it	eq
    337c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    3380:	4770      	bx	lr
    3382:	f092 0f00 	teq	r2, #0
    3386:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    338a:	bf02      	ittt	eq
    338c:	0040      	lsleq	r0, r0, #1
    338e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    3392:	3a01      	subeq	r2, #1
    3394:	d0f9      	beq.n	338a <__aeabi_fmul+0xce>
    3396:	ea40 000c 	orr.w	r0, r0, ip
    339a:	f093 0f00 	teq	r3, #0
    339e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    33a2:	bf02      	ittt	eq
    33a4:	0049      	lsleq	r1, r1, #1
    33a6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    33aa:	3b01      	subeq	r3, #1
    33ac:	d0f9      	beq.n	33a2 <__aeabi_fmul+0xe6>
    33ae:	ea41 010c 	orr.w	r1, r1, ip
    33b2:	e78f      	b.n	32d4 <__aeabi_fmul+0x18>
    33b4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    33b8:	ea92 0f0c 	teq	r2, ip
    33bc:	bf18      	it	ne
    33be:	ea93 0f0c 	teqne	r3, ip
    33c2:	d00a      	beq.n	33da <__aeabi_fmul+0x11e>
    33c4:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    33c8:	bf18      	it	ne
    33ca:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    33ce:	d1d8      	bne.n	3382 <__aeabi_fmul+0xc6>
    33d0:	ea80 0001 	eor.w	r0, r0, r1
    33d4:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    33d8:	4770      	bx	lr
    33da:	f090 0f00 	teq	r0, #0
    33de:	bf17      	itett	ne
    33e0:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
    33e4:	4608      	moveq	r0, r1
    33e6:	f091 0f00 	teqne	r1, #0
    33ea:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
    33ee:	d014      	beq.n	341a <__aeabi_fmul+0x15e>
    33f0:	ea92 0f0c 	teq	r2, ip
    33f4:	d101      	bne.n	33fa <__aeabi_fmul+0x13e>
    33f6:	0242      	lsls	r2, r0, #9
    33f8:	d10f      	bne.n	341a <__aeabi_fmul+0x15e>
    33fa:	ea93 0f0c 	teq	r3, ip
    33fe:	d103      	bne.n	3408 <__aeabi_fmul+0x14c>
    3400:	024b      	lsls	r3, r1, #9
    3402:	bf18      	it	ne
    3404:	4608      	movne	r0, r1
    3406:	d108      	bne.n	341a <__aeabi_fmul+0x15e>
    3408:	ea80 0001 	eor.w	r0, r0, r1
    340c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    3410:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    3414:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    3418:	4770      	bx	lr
    341a:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    341e:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
    3422:	4770      	bx	lr

00003424 <__aeabi_fdiv>:
    3424:	f04f 0cff 	mov.w	ip, #255	; 0xff
    3428:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    342c:	bf1e      	ittt	ne
    342e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    3432:	ea92 0f0c 	teqne	r2, ip
    3436:	ea93 0f0c 	teqne	r3, ip
    343a:	d069      	beq.n	3510 <__aeabi_fdiv+0xec>
    343c:	eba2 0203 	sub.w	r2, r2, r3
    3440:	ea80 0c01 	eor.w	ip, r0, r1
    3444:	0249      	lsls	r1, r1, #9
    3446:	ea4f 2040 	mov.w	r0, r0, lsl #9
    344a:	d037      	beq.n	34bc <__aeabi_fdiv+0x98>
    344c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    3450:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
    3454:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
    3458:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    345c:	428b      	cmp	r3, r1
    345e:	bf38      	it	cc
    3460:	005b      	lslcc	r3, r3, #1
    3462:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
    3466:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
    346a:	428b      	cmp	r3, r1
    346c:	bf24      	itt	cs
    346e:	1a5b      	subcs	r3, r3, r1
    3470:	ea40 000c 	orrcs.w	r0, r0, ip
    3474:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
    3478:	bf24      	itt	cs
    347a:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
    347e:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    3482:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
    3486:	bf24      	itt	cs
    3488:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
    348c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    3490:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
    3494:	bf24      	itt	cs
    3496:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
    349a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    349e:	011b      	lsls	r3, r3, #4
    34a0:	bf18      	it	ne
    34a2:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
    34a6:	d1e0      	bne.n	346a <__aeabi_fdiv+0x46>
    34a8:	2afd      	cmp	r2, #253	; 0xfd
    34aa:	f63f af50 	bhi.w	334e <__aeabi_fmul+0x92>
    34ae:	428b      	cmp	r3, r1
    34b0:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    34b4:	bf08      	it	eq
    34b6:	f020 0001 	biceq.w	r0, r0, #1
    34ba:	4770      	bx	lr
    34bc:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    34c0:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    34c4:	327f      	adds	r2, #127	; 0x7f
    34c6:	bfc2      	ittt	gt
    34c8:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    34cc:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    34d0:	4770      	bxgt	lr
    34d2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    34d6:	f04f 0300 	mov.w	r3, #0
    34da:	3a01      	subs	r2, #1
    34dc:	e737      	b.n	334e <__aeabi_fmul+0x92>
    34de:	f092 0f00 	teq	r2, #0
    34e2:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    34e6:	bf02      	ittt	eq
    34e8:	0040      	lsleq	r0, r0, #1
    34ea:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    34ee:	3a01      	subeq	r2, #1
    34f0:	d0f9      	beq.n	34e6 <__aeabi_fdiv+0xc2>
    34f2:	ea40 000c 	orr.w	r0, r0, ip
    34f6:	f093 0f00 	teq	r3, #0
    34fa:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    34fe:	bf02      	ittt	eq
    3500:	0049      	lsleq	r1, r1, #1
    3502:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    3506:	3b01      	subeq	r3, #1
    3508:	d0f9      	beq.n	34fe <__aeabi_fdiv+0xda>
    350a:	ea41 010c 	orr.w	r1, r1, ip
    350e:	e795      	b.n	343c <__aeabi_fdiv+0x18>
    3510:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    3514:	ea92 0f0c 	teq	r2, ip
    3518:	d108      	bne.n	352c <__aeabi_fdiv+0x108>
    351a:	0242      	lsls	r2, r0, #9
    351c:	f47f af7d 	bne.w	341a <__aeabi_fmul+0x15e>
    3520:	ea93 0f0c 	teq	r3, ip
    3524:	f47f af70 	bne.w	3408 <__aeabi_fmul+0x14c>
    3528:	4608      	mov	r0, r1
    352a:	e776      	b.n	341a <__aeabi_fmul+0x15e>
    352c:	ea93 0f0c 	teq	r3, ip
    3530:	d104      	bne.n	353c <__aeabi_fdiv+0x118>
    3532:	024b      	lsls	r3, r1, #9
    3534:	f43f af4c 	beq.w	33d0 <__aeabi_fmul+0x114>
    3538:	4608      	mov	r0, r1
    353a:	e76e      	b.n	341a <__aeabi_fmul+0x15e>
    353c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    3540:	bf18      	it	ne
    3542:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    3546:	d1ca      	bne.n	34de <__aeabi_fdiv+0xba>
    3548:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
    354c:	f47f af5c 	bne.w	3408 <__aeabi_fmul+0x14c>
    3550:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
    3554:	f47f af3c 	bne.w	33d0 <__aeabi_fmul+0x114>
    3558:	e75f      	b.n	341a <__aeabi_fmul+0x15e>
    355a:	bf00      	nop

0000355c <__aeabi_f2iz>:
    355c:	ea4f 0240 	mov.w	r2, r0, lsl #1
    3560:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
    3564:	d30f      	bcc.n	3586 <__aeabi_f2iz+0x2a>
    3566:	f04f 039e 	mov.w	r3, #158	; 0x9e
    356a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
    356e:	d90d      	bls.n	358c <__aeabi_f2iz+0x30>
    3570:	ea4f 2300 	mov.w	r3, r0, lsl #8
    3574:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    3578:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    357c:	fa23 f002 	lsr.w	r0, r3, r2
    3580:	bf18      	it	ne
    3582:	4240      	negne	r0, r0
    3584:	4770      	bx	lr
    3586:	f04f 0000 	mov.w	r0, #0
    358a:	4770      	bx	lr
    358c:	f112 0f61 	cmn.w	r2, #97	; 0x61
    3590:	d101      	bne.n	3596 <__aeabi_f2iz+0x3a>
    3592:	0242      	lsls	r2, r0, #9
    3594:	d105      	bne.n	35a2 <__aeabi_f2iz+0x46>
    3596:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
    359a:	bf08      	it	eq
    359c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    35a0:	4770      	bx	lr
    35a2:	f04f 0000 	mov.w	r0, #0
    35a6:	4770      	bx	lr

000035a8 <__aeabi_uldivmod>:
    35a8:	b953      	cbnz	r3, 35c0 <__aeabi_uldivmod+0x18>
    35aa:	b94a      	cbnz	r2, 35c0 <__aeabi_uldivmod+0x18>
    35ac:	2900      	cmp	r1, #0
    35ae:	bf08      	it	eq
    35b0:	2800      	cmpeq	r0, #0
    35b2:	bf1c      	itt	ne
    35b4:	f04f 31ff 	movne.w	r1, #4294967295
    35b8:	f04f 30ff 	movne.w	r0, #4294967295
    35bc:	f000 b97a 	b.w	38b4 <__aeabi_idiv0>
    35c0:	f1ad 0c08 	sub.w	ip, sp, #8
    35c4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    35c8:	f000 f806 	bl	35d8 <__udivmoddi4>
    35cc:	f8dd e004 	ldr.w	lr, [sp, #4]
    35d0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    35d4:	b004      	add	sp, #16
    35d6:	4770      	bx	lr

000035d8 <__udivmoddi4>:
    35d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    35dc:	468c      	mov	ip, r1
    35de:	460d      	mov	r5, r1
    35e0:	4604      	mov	r4, r0
    35e2:	9e08      	ldr	r6, [sp, #32]
    35e4:	2b00      	cmp	r3, #0
    35e6:	d151      	bne.n	368c <__udivmoddi4+0xb4>
    35e8:	428a      	cmp	r2, r1
    35ea:	4617      	mov	r7, r2
    35ec:	d96d      	bls.n	36ca <__udivmoddi4+0xf2>
    35ee:	fab2 fe82 	clz	lr, r2
    35f2:	f1be 0f00 	cmp.w	lr, #0
    35f6:	d00b      	beq.n	3610 <__udivmoddi4+0x38>
    35f8:	f1ce 0c20 	rsb	ip, lr, #32
    35fc:	fa01 f50e 	lsl.w	r5, r1, lr
    3600:	fa20 fc0c 	lsr.w	ip, r0, ip
    3604:	fa02 f70e 	lsl.w	r7, r2, lr
    3608:	ea4c 0c05 	orr.w	ip, ip, r5
    360c:	fa00 f40e 	lsl.w	r4, r0, lr
    3610:	ea4f 4a17 	mov.w	sl, r7, lsr #16
    3614:	0c25      	lsrs	r5, r4, #16
    3616:	fbbc f8fa 	udiv	r8, ip, sl
    361a:	fa1f f987 	uxth.w	r9, r7
    361e:	fb0a cc18 	mls	ip, sl, r8, ip
    3622:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
    3626:	fb08 f309 	mul.w	r3, r8, r9
    362a:	42ab      	cmp	r3, r5
    362c:	d90a      	bls.n	3644 <__udivmoddi4+0x6c>
    362e:	19ed      	adds	r5, r5, r7
    3630:	f108 32ff 	add.w	r2, r8, #4294967295
    3634:	f080 8123 	bcs.w	387e <__udivmoddi4+0x2a6>
    3638:	42ab      	cmp	r3, r5
    363a:	f240 8120 	bls.w	387e <__udivmoddi4+0x2a6>
    363e:	f1a8 0802 	sub.w	r8, r8, #2
    3642:	443d      	add	r5, r7
    3644:	1aed      	subs	r5, r5, r3
    3646:	b2a4      	uxth	r4, r4
    3648:	fbb5 f0fa 	udiv	r0, r5, sl
    364c:	fb0a 5510 	mls	r5, sl, r0, r5
    3650:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    3654:	fb00 f909 	mul.w	r9, r0, r9
    3658:	45a1      	cmp	r9, r4
    365a:	d909      	bls.n	3670 <__udivmoddi4+0x98>
    365c:	19e4      	adds	r4, r4, r7
    365e:	f100 33ff 	add.w	r3, r0, #4294967295
    3662:	f080 810a 	bcs.w	387a <__udivmoddi4+0x2a2>
    3666:	45a1      	cmp	r9, r4
    3668:	f240 8107 	bls.w	387a <__udivmoddi4+0x2a2>
    366c:	3802      	subs	r0, #2
    366e:	443c      	add	r4, r7
    3670:	eba4 0409 	sub.w	r4, r4, r9
    3674:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    3678:	2100      	movs	r1, #0
    367a:	2e00      	cmp	r6, #0
    367c:	d061      	beq.n	3742 <__udivmoddi4+0x16a>
    367e:	fa24 f40e 	lsr.w	r4, r4, lr
    3682:	2300      	movs	r3, #0
    3684:	6034      	str	r4, [r6, #0]
    3686:	6073      	str	r3, [r6, #4]
    3688:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    368c:	428b      	cmp	r3, r1
    368e:	d907      	bls.n	36a0 <__udivmoddi4+0xc8>
    3690:	2e00      	cmp	r6, #0
    3692:	d054      	beq.n	373e <__udivmoddi4+0x166>
    3694:	2100      	movs	r1, #0
    3696:	e886 0021 	stmia.w	r6, {r0, r5}
    369a:	4608      	mov	r0, r1
    369c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    36a0:	fab3 f183 	clz	r1, r3
    36a4:	2900      	cmp	r1, #0
    36a6:	f040 808e 	bne.w	37c6 <__udivmoddi4+0x1ee>
    36aa:	42ab      	cmp	r3, r5
    36ac:	d302      	bcc.n	36b4 <__udivmoddi4+0xdc>
    36ae:	4282      	cmp	r2, r0
    36b0:	f200 80fa 	bhi.w	38a8 <__udivmoddi4+0x2d0>
    36b4:	1a84      	subs	r4, r0, r2
    36b6:	eb65 0503 	sbc.w	r5, r5, r3
    36ba:	2001      	movs	r0, #1
    36bc:	46ac      	mov	ip, r5
    36be:	2e00      	cmp	r6, #0
    36c0:	d03f      	beq.n	3742 <__udivmoddi4+0x16a>
    36c2:	e886 1010 	stmia.w	r6, {r4, ip}
    36c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    36ca:	b912      	cbnz	r2, 36d2 <__udivmoddi4+0xfa>
    36cc:	2701      	movs	r7, #1
    36ce:	fbb7 f7f2 	udiv	r7, r7, r2
    36d2:	fab7 fe87 	clz	lr, r7
    36d6:	f1be 0f00 	cmp.w	lr, #0
    36da:	d134      	bne.n	3746 <__udivmoddi4+0x16e>
    36dc:	1beb      	subs	r3, r5, r7
    36de:	0c3a      	lsrs	r2, r7, #16
    36e0:	fa1f fc87 	uxth.w	ip, r7
    36e4:	2101      	movs	r1, #1
    36e6:	fbb3 f8f2 	udiv	r8, r3, r2
    36ea:	0c25      	lsrs	r5, r4, #16
    36ec:	fb02 3318 	mls	r3, r2, r8, r3
    36f0:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    36f4:	fb0c f308 	mul.w	r3, ip, r8
    36f8:	42ab      	cmp	r3, r5
    36fa:	d907      	bls.n	370c <__udivmoddi4+0x134>
    36fc:	19ed      	adds	r5, r5, r7
    36fe:	f108 30ff 	add.w	r0, r8, #4294967295
    3702:	d202      	bcs.n	370a <__udivmoddi4+0x132>
    3704:	42ab      	cmp	r3, r5
    3706:	f200 80d1 	bhi.w	38ac <__udivmoddi4+0x2d4>
    370a:	4680      	mov	r8, r0
    370c:	1aed      	subs	r5, r5, r3
    370e:	b2a3      	uxth	r3, r4
    3710:	fbb5 f0f2 	udiv	r0, r5, r2
    3714:	fb02 5510 	mls	r5, r2, r0, r5
    3718:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
    371c:	fb0c fc00 	mul.w	ip, ip, r0
    3720:	45a4      	cmp	ip, r4
    3722:	d907      	bls.n	3734 <__udivmoddi4+0x15c>
    3724:	19e4      	adds	r4, r4, r7
    3726:	f100 33ff 	add.w	r3, r0, #4294967295
    372a:	d202      	bcs.n	3732 <__udivmoddi4+0x15a>
    372c:	45a4      	cmp	ip, r4
    372e:	f200 80b8 	bhi.w	38a2 <__udivmoddi4+0x2ca>
    3732:	4618      	mov	r0, r3
    3734:	eba4 040c 	sub.w	r4, r4, ip
    3738:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    373c:	e79d      	b.n	367a <__udivmoddi4+0xa2>
    373e:	4631      	mov	r1, r6
    3740:	4630      	mov	r0, r6
    3742:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3746:	f1ce 0420 	rsb	r4, lr, #32
    374a:	fa05 f30e 	lsl.w	r3, r5, lr
    374e:	fa07 f70e 	lsl.w	r7, r7, lr
    3752:	fa20 f804 	lsr.w	r8, r0, r4
    3756:	0c3a      	lsrs	r2, r7, #16
    3758:	fa25 f404 	lsr.w	r4, r5, r4
    375c:	ea48 0803 	orr.w	r8, r8, r3
    3760:	fbb4 f1f2 	udiv	r1, r4, r2
    3764:	ea4f 4518 	mov.w	r5, r8, lsr #16
    3768:	fb02 4411 	mls	r4, r2, r1, r4
    376c:	fa1f fc87 	uxth.w	ip, r7
    3770:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
    3774:	fb01 f30c 	mul.w	r3, r1, ip
    3778:	42ab      	cmp	r3, r5
    377a:	fa00 f40e 	lsl.w	r4, r0, lr
    377e:	d909      	bls.n	3794 <__udivmoddi4+0x1bc>
    3780:	19ed      	adds	r5, r5, r7
    3782:	f101 30ff 	add.w	r0, r1, #4294967295
    3786:	f080 808a 	bcs.w	389e <__udivmoddi4+0x2c6>
    378a:	42ab      	cmp	r3, r5
    378c:	f240 8087 	bls.w	389e <__udivmoddi4+0x2c6>
    3790:	3902      	subs	r1, #2
    3792:	443d      	add	r5, r7
    3794:	1aeb      	subs	r3, r5, r3
    3796:	fa1f f588 	uxth.w	r5, r8
    379a:	fbb3 f0f2 	udiv	r0, r3, r2
    379e:	fb02 3310 	mls	r3, r2, r0, r3
    37a2:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    37a6:	fb00 f30c 	mul.w	r3, r0, ip
    37aa:	42ab      	cmp	r3, r5
    37ac:	d907      	bls.n	37be <__udivmoddi4+0x1e6>
    37ae:	19ed      	adds	r5, r5, r7
    37b0:	f100 38ff 	add.w	r8, r0, #4294967295
    37b4:	d26f      	bcs.n	3896 <__udivmoddi4+0x2be>
    37b6:	42ab      	cmp	r3, r5
    37b8:	d96d      	bls.n	3896 <__udivmoddi4+0x2be>
    37ba:	3802      	subs	r0, #2
    37bc:	443d      	add	r5, r7
    37be:	1aeb      	subs	r3, r5, r3
    37c0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    37c4:	e78f      	b.n	36e6 <__udivmoddi4+0x10e>
    37c6:	f1c1 0720 	rsb	r7, r1, #32
    37ca:	fa22 f807 	lsr.w	r8, r2, r7
    37ce:	408b      	lsls	r3, r1
    37d0:	fa05 f401 	lsl.w	r4, r5, r1
    37d4:	ea48 0303 	orr.w	r3, r8, r3
    37d8:	fa20 fe07 	lsr.w	lr, r0, r7
    37dc:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    37e0:	40fd      	lsrs	r5, r7
    37e2:	ea4e 0e04 	orr.w	lr, lr, r4
    37e6:	fbb5 f9fc 	udiv	r9, r5, ip
    37ea:	ea4f 441e 	mov.w	r4, lr, lsr #16
    37ee:	fb0c 5519 	mls	r5, ip, r9, r5
    37f2:	fa1f f883 	uxth.w	r8, r3
    37f6:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
    37fa:	fb09 f408 	mul.w	r4, r9, r8
    37fe:	42ac      	cmp	r4, r5
    3800:	fa02 f201 	lsl.w	r2, r2, r1
    3804:	fa00 fa01 	lsl.w	sl, r0, r1
    3808:	d908      	bls.n	381c <__udivmoddi4+0x244>
    380a:	18ed      	adds	r5, r5, r3
    380c:	f109 30ff 	add.w	r0, r9, #4294967295
    3810:	d243      	bcs.n	389a <__udivmoddi4+0x2c2>
    3812:	42ac      	cmp	r4, r5
    3814:	d941      	bls.n	389a <__udivmoddi4+0x2c2>
    3816:	f1a9 0902 	sub.w	r9, r9, #2
    381a:	441d      	add	r5, r3
    381c:	1b2d      	subs	r5, r5, r4
    381e:	fa1f fe8e 	uxth.w	lr, lr
    3822:	fbb5 f0fc 	udiv	r0, r5, ip
    3826:	fb0c 5510 	mls	r5, ip, r0, r5
    382a:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
    382e:	fb00 f808 	mul.w	r8, r0, r8
    3832:	45a0      	cmp	r8, r4
    3834:	d907      	bls.n	3846 <__udivmoddi4+0x26e>
    3836:	18e4      	adds	r4, r4, r3
    3838:	f100 35ff 	add.w	r5, r0, #4294967295
    383c:	d229      	bcs.n	3892 <__udivmoddi4+0x2ba>
    383e:	45a0      	cmp	r8, r4
    3840:	d927      	bls.n	3892 <__udivmoddi4+0x2ba>
    3842:	3802      	subs	r0, #2
    3844:	441c      	add	r4, r3
    3846:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    384a:	eba4 0408 	sub.w	r4, r4, r8
    384e:	fba0 8902 	umull	r8, r9, r0, r2
    3852:	454c      	cmp	r4, r9
    3854:	46c6      	mov	lr, r8
    3856:	464d      	mov	r5, r9
    3858:	d315      	bcc.n	3886 <__udivmoddi4+0x2ae>
    385a:	d012      	beq.n	3882 <__udivmoddi4+0x2aa>
    385c:	b156      	cbz	r6, 3874 <__udivmoddi4+0x29c>
    385e:	ebba 030e 	subs.w	r3, sl, lr
    3862:	eb64 0405 	sbc.w	r4, r4, r5
    3866:	fa04 f707 	lsl.w	r7, r4, r7
    386a:	40cb      	lsrs	r3, r1
    386c:	431f      	orrs	r7, r3
    386e:	40cc      	lsrs	r4, r1
    3870:	6037      	str	r7, [r6, #0]
    3872:	6074      	str	r4, [r6, #4]
    3874:	2100      	movs	r1, #0
    3876:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    387a:	4618      	mov	r0, r3
    387c:	e6f8      	b.n	3670 <__udivmoddi4+0x98>
    387e:	4690      	mov	r8, r2
    3880:	e6e0      	b.n	3644 <__udivmoddi4+0x6c>
    3882:	45c2      	cmp	sl, r8
    3884:	d2ea      	bcs.n	385c <__udivmoddi4+0x284>
    3886:	ebb8 0e02 	subs.w	lr, r8, r2
    388a:	eb69 0503 	sbc.w	r5, r9, r3
    388e:	3801      	subs	r0, #1
    3890:	e7e4      	b.n	385c <__udivmoddi4+0x284>
    3892:	4628      	mov	r0, r5
    3894:	e7d7      	b.n	3846 <__udivmoddi4+0x26e>
    3896:	4640      	mov	r0, r8
    3898:	e791      	b.n	37be <__udivmoddi4+0x1e6>
    389a:	4681      	mov	r9, r0
    389c:	e7be      	b.n	381c <__udivmoddi4+0x244>
    389e:	4601      	mov	r1, r0
    38a0:	e778      	b.n	3794 <__udivmoddi4+0x1bc>
    38a2:	3802      	subs	r0, #2
    38a4:	443c      	add	r4, r7
    38a6:	e745      	b.n	3734 <__udivmoddi4+0x15c>
    38a8:	4608      	mov	r0, r1
    38aa:	e708      	b.n	36be <__udivmoddi4+0xe6>
    38ac:	f1a8 0802 	sub.w	r8, r8, #2
    38b0:	443d      	add	r5, r7
    38b2:	e72b      	b.n	370c <__udivmoddi4+0x134>

000038b4 <__aeabi_idiv0>:
    38b4:	4770      	bx	lr
    38b6:	bf00      	nop

000038b8 <__libc_init_array>:
    38b8:	b570      	push	{r4, r5, r6, lr}
    38ba:	4e0f      	ldr	r6, [pc, #60]	; (38f8 <__libc_init_array+0x40>)
    38bc:	4d0f      	ldr	r5, [pc, #60]	; (38fc <__libc_init_array+0x44>)
    38be:	1b76      	subs	r6, r6, r5
    38c0:	10b6      	asrs	r6, r6, #2
    38c2:	bf18      	it	ne
    38c4:	2400      	movne	r4, #0
    38c6:	d005      	beq.n	38d4 <__libc_init_array+0x1c>
    38c8:	3401      	adds	r4, #1
    38ca:	f855 3b04 	ldr.w	r3, [r5], #4
    38ce:	4798      	blx	r3
    38d0:	42a6      	cmp	r6, r4
    38d2:	d1f9      	bne.n	38c8 <__libc_init_array+0x10>
    38d4:	4e0a      	ldr	r6, [pc, #40]	; (3900 <__libc_init_array+0x48>)
    38d6:	4d0b      	ldr	r5, [pc, #44]	; (3904 <__libc_init_array+0x4c>)
    38d8:	1b76      	subs	r6, r6, r5
    38da:	f000 fba1 	bl	4020 <_init>
    38de:	10b6      	asrs	r6, r6, #2
    38e0:	bf18      	it	ne
    38e2:	2400      	movne	r4, #0
    38e4:	d006      	beq.n	38f4 <__libc_init_array+0x3c>
    38e6:	3401      	adds	r4, #1
    38e8:	f855 3b04 	ldr.w	r3, [r5], #4
    38ec:	4798      	blx	r3
    38ee:	42a6      	cmp	r6, r4
    38f0:	d1f9      	bne.n	38e6 <__libc_init_array+0x2e>
    38f2:	bd70      	pop	{r4, r5, r6, pc}
    38f4:	bd70      	pop	{r4, r5, r6, pc}
    38f6:	bf00      	nop
    38f8:	0000402c 	.word	0x0000402c
    38fc:	0000402c 	.word	0x0000402c
    3900:	00004034 	.word	0x00004034
    3904:	0000402c 	.word	0x0000402c

00003908 <__itoa>:
    3908:	1e93      	subs	r3, r2, #2
    390a:	2b22      	cmp	r3, #34	; 0x22
    390c:	d810      	bhi.n	3930 <__itoa+0x28>
    390e:	2a0a      	cmp	r2, #10
    3910:	b510      	push	{r4, lr}
    3912:	d006      	beq.n	3922 <__itoa+0x1a>
    3914:	2300      	movs	r3, #0
    3916:	460c      	mov	r4, r1
    3918:	4419      	add	r1, r3
    391a:	f000 fa31 	bl	3d80 <__utoa>
    391e:	4620      	mov	r0, r4
    3920:	bd10      	pop	{r4, pc}
    3922:	2800      	cmp	r0, #0
    3924:	daf6      	bge.n	3914 <__itoa+0xc>
    3926:	232d      	movs	r3, #45	; 0x2d
    3928:	700b      	strb	r3, [r1, #0]
    392a:	4240      	negs	r0, r0
    392c:	2301      	movs	r3, #1
    392e:	e7f2      	b.n	3916 <__itoa+0xe>
    3930:	2000      	movs	r0, #0
    3932:	7008      	strb	r0, [r1, #0]
    3934:	4770      	bx	lr
    3936:	bf00      	nop

00003938 <itoa>:
    3938:	f7ff bfe6 	b.w	3908 <__itoa>

0000393c <memcpy>:
    393c:	4684      	mov	ip, r0
    393e:	ea41 0300 	orr.w	r3, r1, r0
    3942:	f013 0303 	ands.w	r3, r3, #3
    3946:	d16d      	bne.n	3a24 <memcpy+0xe8>
    3948:	3a40      	subs	r2, #64	; 0x40
    394a:	d341      	bcc.n	39d0 <memcpy+0x94>
    394c:	f851 3b04 	ldr.w	r3, [r1], #4
    3950:	f840 3b04 	str.w	r3, [r0], #4
    3954:	f851 3b04 	ldr.w	r3, [r1], #4
    3958:	f840 3b04 	str.w	r3, [r0], #4
    395c:	f851 3b04 	ldr.w	r3, [r1], #4
    3960:	f840 3b04 	str.w	r3, [r0], #4
    3964:	f851 3b04 	ldr.w	r3, [r1], #4
    3968:	f840 3b04 	str.w	r3, [r0], #4
    396c:	f851 3b04 	ldr.w	r3, [r1], #4
    3970:	f840 3b04 	str.w	r3, [r0], #4
    3974:	f851 3b04 	ldr.w	r3, [r1], #4
    3978:	f840 3b04 	str.w	r3, [r0], #4
    397c:	f851 3b04 	ldr.w	r3, [r1], #4
    3980:	f840 3b04 	str.w	r3, [r0], #4
    3984:	f851 3b04 	ldr.w	r3, [r1], #4
    3988:	f840 3b04 	str.w	r3, [r0], #4
    398c:	f851 3b04 	ldr.w	r3, [r1], #4
    3990:	f840 3b04 	str.w	r3, [r0], #4
    3994:	f851 3b04 	ldr.w	r3, [r1], #4
    3998:	f840 3b04 	str.w	r3, [r0], #4
    399c:	f851 3b04 	ldr.w	r3, [r1], #4
    39a0:	f840 3b04 	str.w	r3, [r0], #4
    39a4:	f851 3b04 	ldr.w	r3, [r1], #4
    39a8:	f840 3b04 	str.w	r3, [r0], #4
    39ac:	f851 3b04 	ldr.w	r3, [r1], #4
    39b0:	f840 3b04 	str.w	r3, [r0], #4
    39b4:	f851 3b04 	ldr.w	r3, [r1], #4
    39b8:	f840 3b04 	str.w	r3, [r0], #4
    39bc:	f851 3b04 	ldr.w	r3, [r1], #4
    39c0:	f840 3b04 	str.w	r3, [r0], #4
    39c4:	f851 3b04 	ldr.w	r3, [r1], #4
    39c8:	f840 3b04 	str.w	r3, [r0], #4
    39cc:	3a40      	subs	r2, #64	; 0x40
    39ce:	d2bd      	bcs.n	394c <memcpy+0x10>
    39d0:	3230      	adds	r2, #48	; 0x30
    39d2:	d311      	bcc.n	39f8 <memcpy+0xbc>
    39d4:	f851 3b04 	ldr.w	r3, [r1], #4
    39d8:	f840 3b04 	str.w	r3, [r0], #4
    39dc:	f851 3b04 	ldr.w	r3, [r1], #4
    39e0:	f840 3b04 	str.w	r3, [r0], #4
    39e4:	f851 3b04 	ldr.w	r3, [r1], #4
    39e8:	f840 3b04 	str.w	r3, [r0], #4
    39ec:	f851 3b04 	ldr.w	r3, [r1], #4
    39f0:	f840 3b04 	str.w	r3, [r0], #4
    39f4:	3a10      	subs	r2, #16
    39f6:	d2ed      	bcs.n	39d4 <memcpy+0x98>
    39f8:	320c      	adds	r2, #12
    39fa:	d305      	bcc.n	3a08 <memcpy+0xcc>
    39fc:	f851 3b04 	ldr.w	r3, [r1], #4
    3a00:	f840 3b04 	str.w	r3, [r0], #4
    3a04:	3a04      	subs	r2, #4
    3a06:	d2f9      	bcs.n	39fc <memcpy+0xc0>
    3a08:	3204      	adds	r2, #4
    3a0a:	d008      	beq.n	3a1e <memcpy+0xe2>
    3a0c:	07d2      	lsls	r2, r2, #31
    3a0e:	bf1c      	itt	ne
    3a10:	f811 3b01 	ldrbne.w	r3, [r1], #1
    3a14:	f800 3b01 	strbne.w	r3, [r0], #1
    3a18:	d301      	bcc.n	3a1e <memcpy+0xe2>
    3a1a:	880b      	ldrh	r3, [r1, #0]
    3a1c:	8003      	strh	r3, [r0, #0]
    3a1e:	4660      	mov	r0, ip
    3a20:	4770      	bx	lr
    3a22:	bf00      	nop
    3a24:	2a08      	cmp	r2, #8
    3a26:	d313      	bcc.n	3a50 <memcpy+0x114>
    3a28:	078b      	lsls	r3, r1, #30
    3a2a:	d08d      	beq.n	3948 <memcpy+0xc>
    3a2c:	f010 0303 	ands.w	r3, r0, #3
    3a30:	d08a      	beq.n	3948 <memcpy+0xc>
    3a32:	f1c3 0304 	rsb	r3, r3, #4
    3a36:	1ad2      	subs	r2, r2, r3
    3a38:	07db      	lsls	r3, r3, #31
    3a3a:	bf1c      	itt	ne
    3a3c:	f811 3b01 	ldrbne.w	r3, [r1], #1
    3a40:	f800 3b01 	strbne.w	r3, [r0], #1
    3a44:	d380      	bcc.n	3948 <memcpy+0xc>
    3a46:	f831 3b02 	ldrh.w	r3, [r1], #2
    3a4a:	f820 3b02 	strh.w	r3, [r0], #2
    3a4e:	e77b      	b.n	3948 <memcpy+0xc>
    3a50:	3a04      	subs	r2, #4
    3a52:	d3d9      	bcc.n	3a08 <memcpy+0xcc>
    3a54:	3a01      	subs	r2, #1
    3a56:	f811 3b01 	ldrb.w	r3, [r1], #1
    3a5a:	f800 3b01 	strb.w	r3, [r0], #1
    3a5e:	d2f9      	bcs.n	3a54 <memcpy+0x118>
    3a60:	780b      	ldrb	r3, [r1, #0]
    3a62:	7003      	strb	r3, [r0, #0]
    3a64:	784b      	ldrb	r3, [r1, #1]
    3a66:	7043      	strb	r3, [r0, #1]
    3a68:	788b      	ldrb	r3, [r1, #2]
    3a6a:	7083      	strb	r3, [r0, #2]
    3a6c:	4660      	mov	r0, ip
    3a6e:	4770      	bx	lr

00003a70 <memset>:
    3a70:	b470      	push	{r4, r5, r6}
    3a72:	0786      	lsls	r6, r0, #30
    3a74:	d046      	beq.n	3b04 <memset+0x94>
    3a76:	1e54      	subs	r4, r2, #1
    3a78:	2a00      	cmp	r2, #0
    3a7a:	d041      	beq.n	3b00 <memset+0x90>
    3a7c:	b2ca      	uxtb	r2, r1
    3a7e:	4603      	mov	r3, r0
    3a80:	e002      	b.n	3a88 <memset+0x18>
    3a82:	f114 34ff 	adds.w	r4, r4, #4294967295
    3a86:	d33b      	bcc.n	3b00 <memset+0x90>
    3a88:	f803 2b01 	strb.w	r2, [r3], #1
    3a8c:	079d      	lsls	r5, r3, #30
    3a8e:	d1f8      	bne.n	3a82 <memset+0x12>
    3a90:	2c03      	cmp	r4, #3
    3a92:	d92e      	bls.n	3af2 <memset+0x82>
    3a94:	b2cd      	uxtb	r5, r1
    3a96:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    3a9a:	2c0f      	cmp	r4, #15
    3a9c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    3aa0:	d919      	bls.n	3ad6 <memset+0x66>
    3aa2:	f103 0210 	add.w	r2, r3, #16
    3aa6:	4626      	mov	r6, r4
    3aa8:	3e10      	subs	r6, #16
    3aaa:	2e0f      	cmp	r6, #15
    3aac:	f842 5c10 	str.w	r5, [r2, #-16]
    3ab0:	f842 5c0c 	str.w	r5, [r2, #-12]
    3ab4:	f842 5c08 	str.w	r5, [r2, #-8]
    3ab8:	f842 5c04 	str.w	r5, [r2, #-4]
    3abc:	f102 0210 	add.w	r2, r2, #16
    3ac0:	d8f2      	bhi.n	3aa8 <memset+0x38>
    3ac2:	f1a4 0210 	sub.w	r2, r4, #16
    3ac6:	f022 020f 	bic.w	r2, r2, #15
    3aca:	f004 040f 	and.w	r4, r4, #15
    3ace:	3210      	adds	r2, #16
    3ad0:	2c03      	cmp	r4, #3
    3ad2:	4413      	add	r3, r2
    3ad4:	d90d      	bls.n	3af2 <memset+0x82>
    3ad6:	461e      	mov	r6, r3
    3ad8:	4622      	mov	r2, r4
    3ada:	3a04      	subs	r2, #4
    3adc:	2a03      	cmp	r2, #3
    3ade:	f846 5b04 	str.w	r5, [r6], #4
    3ae2:	d8fa      	bhi.n	3ada <memset+0x6a>
    3ae4:	1f22      	subs	r2, r4, #4
    3ae6:	f022 0203 	bic.w	r2, r2, #3
    3aea:	3204      	adds	r2, #4
    3aec:	4413      	add	r3, r2
    3aee:	f004 0403 	and.w	r4, r4, #3
    3af2:	b12c      	cbz	r4, 3b00 <memset+0x90>
    3af4:	b2c9      	uxtb	r1, r1
    3af6:	441c      	add	r4, r3
    3af8:	f803 1b01 	strb.w	r1, [r3], #1
    3afc:	429c      	cmp	r4, r3
    3afe:	d1fb      	bne.n	3af8 <memset+0x88>
    3b00:	bc70      	pop	{r4, r5, r6}
    3b02:	4770      	bx	lr
    3b04:	4614      	mov	r4, r2
    3b06:	4603      	mov	r3, r0
    3b08:	e7c2      	b.n	3a90 <memset+0x20>
    3b0a:	bf00      	nop

00003b0c <strcpy>:
    3b0c:	ea80 0201 	eor.w	r2, r0, r1
    3b10:	4684      	mov	ip, r0
    3b12:	f012 0f03 	tst.w	r2, #3
    3b16:	d14f      	bne.n	3bb8 <strcpy+0xac>
    3b18:	f011 0f03 	tst.w	r1, #3
    3b1c:	d132      	bne.n	3b84 <strcpy+0x78>
    3b1e:	f84d 4d04 	str.w	r4, [sp, #-4]!
    3b22:	f011 0f04 	tst.w	r1, #4
    3b26:	f851 3b04 	ldr.w	r3, [r1], #4
    3b2a:	d00b      	beq.n	3b44 <strcpy+0x38>
    3b2c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    3b30:	439a      	bics	r2, r3
    3b32:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    3b36:	bf04      	itt	eq
    3b38:	f84c 3b04 	streq.w	r3, [ip], #4
    3b3c:	f851 3b04 	ldreq.w	r3, [r1], #4
    3b40:	d116      	bne.n	3b70 <strcpy+0x64>
    3b42:	bf00      	nop
    3b44:	f851 4b04 	ldr.w	r4, [r1], #4
    3b48:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    3b4c:	439a      	bics	r2, r3
    3b4e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    3b52:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    3b56:	d10b      	bne.n	3b70 <strcpy+0x64>
    3b58:	f84c 3b04 	str.w	r3, [ip], #4
    3b5c:	43a2      	bics	r2, r4
    3b5e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    3b62:	bf04      	itt	eq
    3b64:	f851 3b04 	ldreq.w	r3, [r1], #4
    3b68:	f84c 4b04 	streq.w	r4, [ip], #4
    3b6c:	d0ea      	beq.n	3b44 <strcpy+0x38>
    3b6e:	4623      	mov	r3, r4
    3b70:	f80c 3b01 	strb.w	r3, [ip], #1
    3b74:	f013 0fff 	tst.w	r3, #255	; 0xff
    3b78:	ea4f 2333 	mov.w	r3, r3, ror #8
    3b7c:	d1f8      	bne.n	3b70 <strcpy+0x64>
    3b7e:	f85d 4b04 	ldr.w	r4, [sp], #4
    3b82:	4770      	bx	lr
    3b84:	f011 0f01 	tst.w	r1, #1
    3b88:	d006      	beq.n	3b98 <strcpy+0x8c>
    3b8a:	f811 2b01 	ldrb.w	r2, [r1], #1
    3b8e:	f80c 2b01 	strb.w	r2, [ip], #1
    3b92:	2a00      	cmp	r2, #0
    3b94:	bf08      	it	eq
    3b96:	4770      	bxeq	lr
    3b98:	f011 0f02 	tst.w	r1, #2
    3b9c:	d0bf      	beq.n	3b1e <strcpy+0x12>
    3b9e:	f831 2b02 	ldrh.w	r2, [r1], #2
    3ba2:	f012 0fff 	tst.w	r2, #255	; 0xff
    3ba6:	bf16      	itet	ne
    3ba8:	f82c 2b02 	strhne.w	r2, [ip], #2
    3bac:	f88c 2000 	strbeq.w	r2, [ip]
    3bb0:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    3bb4:	d1b3      	bne.n	3b1e <strcpy+0x12>
    3bb6:	4770      	bx	lr
    3bb8:	f811 2b01 	ldrb.w	r2, [r1], #1
    3bbc:	f80c 2b01 	strb.w	r2, [ip], #1
    3bc0:	2a00      	cmp	r2, #0
    3bc2:	d1f9      	bne.n	3bb8 <strcpy+0xac>
    3bc4:	4770      	bx	lr
    3bc6:	bf00      	nop
	...

00003c00 <strlen>:
    3c00:	f890 f000 	pld	[r0]
    3c04:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    3c08:	f020 0107 	bic.w	r1, r0, #7
    3c0c:	f06f 0c00 	mvn.w	ip, #0
    3c10:	f010 0407 	ands.w	r4, r0, #7
    3c14:	f891 f020 	pld	[r1, #32]
    3c18:	f040 8049 	bne.w	3cae <strlen+0xae>
    3c1c:	f04f 0400 	mov.w	r4, #0
    3c20:	f06f 0007 	mvn.w	r0, #7
    3c24:	e9d1 2300 	ldrd	r2, r3, [r1]
    3c28:	f891 f040 	pld	[r1, #64]	; 0x40
    3c2c:	f100 0008 	add.w	r0, r0, #8
    3c30:	fa82 f24c 	uadd8	r2, r2, ip
    3c34:	faa4 f28c 	sel	r2, r4, ip
    3c38:	fa83 f34c 	uadd8	r3, r3, ip
    3c3c:	faa2 f38c 	sel	r3, r2, ip
    3c40:	bb4b      	cbnz	r3, 3c96 <strlen+0x96>
    3c42:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    3c46:	fa82 f24c 	uadd8	r2, r2, ip
    3c4a:	f100 0008 	add.w	r0, r0, #8
    3c4e:	faa4 f28c 	sel	r2, r4, ip
    3c52:	fa83 f34c 	uadd8	r3, r3, ip
    3c56:	faa2 f38c 	sel	r3, r2, ip
    3c5a:	b9e3      	cbnz	r3, 3c96 <strlen+0x96>
    3c5c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    3c60:	fa82 f24c 	uadd8	r2, r2, ip
    3c64:	f100 0008 	add.w	r0, r0, #8
    3c68:	faa4 f28c 	sel	r2, r4, ip
    3c6c:	fa83 f34c 	uadd8	r3, r3, ip
    3c70:	faa2 f38c 	sel	r3, r2, ip
    3c74:	b97b      	cbnz	r3, 3c96 <strlen+0x96>
    3c76:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    3c7a:	f101 0120 	add.w	r1, r1, #32
    3c7e:	fa82 f24c 	uadd8	r2, r2, ip
    3c82:	f100 0008 	add.w	r0, r0, #8
    3c86:	faa4 f28c 	sel	r2, r4, ip
    3c8a:	fa83 f34c 	uadd8	r3, r3, ip
    3c8e:	faa2 f38c 	sel	r3, r2, ip
    3c92:	2b00      	cmp	r3, #0
    3c94:	d0c6      	beq.n	3c24 <strlen+0x24>
    3c96:	2a00      	cmp	r2, #0
    3c98:	bf04      	itt	eq
    3c9a:	3004      	addeq	r0, #4
    3c9c:	461a      	moveq	r2, r3
    3c9e:	ba12      	rev	r2, r2
    3ca0:	fab2 f282 	clz	r2, r2
    3ca4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    3ca8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    3cac:	4770      	bx	lr
    3cae:	e9d1 2300 	ldrd	r2, r3, [r1]
    3cb2:	f004 0503 	and.w	r5, r4, #3
    3cb6:	f1c4 0000 	rsb	r0, r4, #0
    3cba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    3cbe:	f014 0f04 	tst.w	r4, #4
    3cc2:	f891 f040 	pld	[r1, #64]	; 0x40
    3cc6:	fa0c f505 	lsl.w	r5, ip, r5
    3cca:	ea62 0205 	orn	r2, r2, r5
    3cce:	bf1c      	itt	ne
    3cd0:	ea63 0305 	ornne	r3, r3, r5
    3cd4:	4662      	movne	r2, ip
    3cd6:	f04f 0400 	mov.w	r4, #0
    3cda:	e7a9      	b.n	3c30 <strlen+0x30>

00003cdc <strncmp>:
    3cdc:	2a00      	cmp	r2, #0
    3cde:	d041      	beq.n	3d64 <strncmp+0x88>
    3ce0:	ea40 0301 	orr.w	r3, r0, r1
    3ce4:	f013 0303 	ands.w	r3, r3, #3
    3ce8:	b4f0      	push	{r4, r5, r6, r7}
    3cea:	d125      	bne.n	3d38 <strncmp+0x5c>
    3cec:	2a03      	cmp	r2, #3
    3cee:	d923      	bls.n	3d38 <strncmp+0x5c>
    3cf0:	6804      	ldr	r4, [r0, #0]
    3cf2:	680d      	ldr	r5, [r1, #0]
    3cf4:	42ac      	cmp	r4, r5
    3cf6:	d11f      	bne.n	3d38 <strncmp+0x5c>
    3cf8:	3a04      	subs	r2, #4
    3cfa:	d038      	beq.n	3d6e <strncmp+0x92>
    3cfc:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
    3d00:	ea25 0404 	bic.w	r4, r5, r4
    3d04:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
    3d08:	d12e      	bne.n	3d68 <strncmp+0x8c>
    3d0a:	3004      	adds	r0, #4
    3d0c:	3104      	adds	r1, #4
    3d0e:	e00f      	b.n	3d30 <strncmp+0x54>
    3d10:	f850 3b04 	ldr.w	r3, [r0], #4
    3d14:	680e      	ldr	r6, [r1, #0]
    3d16:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
    3d1a:	42b3      	cmp	r3, r6
    3d1c:	ea24 0403 	bic.w	r4, r4, r3
    3d20:	f101 0104 	add.w	r1, r1, #4
    3d24:	d126      	bne.n	3d74 <strncmp+0x98>
    3d26:	3a04      	subs	r2, #4
    3d28:	d021      	beq.n	3d6e <strncmp+0x92>
    3d2a:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
    3d2e:	d11b      	bne.n	3d68 <strncmp+0x8c>
    3d30:	2a03      	cmp	r2, #3
    3d32:	4607      	mov	r7, r0
    3d34:	460d      	mov	r5, r1
    3d36:	d8eb      	bhi.n	3d10 <strncmp+0x34>
    3d38:	7805      	ldrb	r5, [r0, #0]
    3d3a:	780c      	ldrb	r4, [r1, #0]
    3d3c:	42ac      	cmp	r4, r5
    3d3e:	f102 33ff 	add.w	r3, r2, #4294967295
    3d42:	d11a      	bne.n	3d7a <strncmp+0x9e>
    3d44:	b183      	cbz	r3, 3d68 <strncmp+0x8c>
    3d46:	b914      	cbnz	r4, 3d4e <strncmp+0x72>
    3d48:	e00e      	b.n	3d68 <strncmp+0x8c>
    3d4a:	b16b      	cbz	r3, 3d68 <strncmp+0x8c>
    3d4c:	b17a      	cbz	r2, 3d6e <strncmp+0x92>
    3d4e:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    3d52:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    3d56:	42a2      	cmp	r2, r4
    3d58:	f103 33ff 	add.w	r3, r3, #4294967295
    3d5c:	d0f5      	beq.n	3d4a <strncmp+0x6e>
    3d5e:	1b10      	subs	r0, r2, r4
    3d60:	bcf0      	pop	{r4, r5, r6, r7}
    3d62:	4770      	bx	lr
    3d64:	4610      	mov	r0, r2
    3d66:	4770      	bx	lr
    3d68:	2000      	movs	r0, #0
    3d6a:	bcf0      	pop	{r4, r5, r6, r7}
    3d6c:	4770      	bx	lr
    3d6e:	4610      	mov	r0, r2
    3d70:	bcf0      	pop	{r4, r5, r6, r7}
    3d72:	4770      	bx	lr
    3d74:	4629      	mov	r1, r5
    3d76:	4638      	mov	r0, r7
    3d78:	e7de      	b.n	3d38 <strncmp+0x5c>
    3d7a:	462a      	mov	r2, r5
    3d7c:	e7ef      	b.n	3d5e <strncmp+0x82>
    3d7e:	bf00      	nop

00003d80 <__utoa>:
    3d80:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d82:	f8df e078 	ldr.w	lr, [pc, #120]	; 3dfc <__utoa+0x7c>
    3d86:	4616      	mov	r6, r2
    3d88:	4604      	mov	r4, r0
    3d8a:	460f      	mov	r7, r1
    3d8c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3d90:	b08b      	sub	sp, #44	; 0x2c
    3d92:	466d      	mov	r5, sp
    3d94:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    3d96:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3d9a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    3d9c:	e89e 0003 	ldmia.w	lr, {r0, r1}
    3da0:	1eb3      	subs	r3, r6, #2
    3da2:	f845 0b04 	str.w	r0, [r5], #4
    3da6:	2b22      	cmp	r3, #34	; 0x22
    3da8:	7029      	strb	r1, [r5, #0]
    3daa:	d822      	bhi.n	3df2 <__utoa+0x72>
    3dac:	1e7d      	subs	r5, r7, #1
    3dae:	4628      	mov	r0, r5
    3db0:	2200      	movs	r2, #0
    3db2:	e000      	b.n	3db6 <__utoa+0x36>
    3db4:	461a      	mov	r2, r3
    3db6:	fbb4 f1f6 	udiv	r1, r4, r6
    3dba:	ab0a      	add	r3, sp, #40	; 0x28
    3dbc:	fb06 4411 	mls	r4, r6, r1, r4
    3dc0:	4423      	add	r3, r4
    3dc2:	460c      	mov	r4, r1
    3dc4:	f813 3c28 	ldrb.w	r3, [r3, #-40]
    3dc8:	f800 3f01 	strb.w	r3, [r0, #1]!
    3dcc:	1c53      	adds	r3, r2, #1
    3dce:	2900      	cmp	r1, #0
    3dd0:	d1f0      	bne.n	3db4 <__utoa+0x34>
    3dd2:	54f9      	strb	r1, [r7, r3]
    3dd4:	18bb      	adds	r3, r7, r2
    3dd6:	b14a      	cbz	r2, 3dec <__utoa+0x6c>
    3dd8:	7819      	ldrb	r1, [r3, #0]
    3dda:	7868      	ldrb	r0, [r5, #1]
    3ddc:	f805 1f01 	strb.w	r1, [r5, #1]!
    3de0:	3401      	adds	r4, #1
    3de2:	1b11      	subs	r1, r2, r4
    3de4:	428c      	cmp	r4, r1
    3de6:	f803 0901 	strb.w	r0, [r3], #-1
    3dea:	dbf5      	blt.n	3dd8 <__utoa+0x58>
    3dec:	4638      	mov	r0, r7
    3dee:	b00b      	add	sp, #44	; 0x2c
    3df0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3df2:	2000      	movs	r0, #0
    3df4:	7038      	strb	r0, [r7, #0]
    3df6:	b00b      	add	sp, #44	; 0x2c
    3df8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3dfa:	bf00      	nop
    3dfc:	00003ff8 	.word	0x00003ff8

00003e00 <register_fini>:
    3e00:	4b02      	ldr	r3, [pc, #8]	; (3e0c <register_fini+0xc>)
    3e02:	b113      	cbz	r3, 3e0a <register_fini+0xa>
    3e04:	4802      	ldr	r0, [pc, #8]	; (3e10 <register_fini+0x10>)
    3e06:	f000 b805 	b.w	3e14 <atexit>
    3e0a:	4770      	bx	lr
    3e0c:	00000000 	.word	0x00000000
    3e10:	00003e21 	.word	0x00003e21

00003e14 <atexit>:
    3e14:	2300      	movs	r3, #0
    3e16:	4601      	mov	r1, r0
    3e18:	461a      	mov	r2, r3
    3e1a:	4618      	mov	r0, r3
    3e1c:	f000 b81e 	b.w	3e5c <__register_exitproc>

00003e20 <__libc_fini_array>:
    3e20:	b538      	push	{r3, r4, r5, lr}
    3e22:	4c0a      	ldr	r4, [pc, #40]	; (3e4c <__libc_fini_array+0x2c>)
    3e24:	4d0a      	ldr	r5, [pc, #40]	; (3e50 <__libc_fini_array+0x30>)
    3e26:	1b64      	subs	r4, r4, r5
    3e28:	10a4      	asrs	r4, r4, #2
    3e2a:	d00a      	beq.n	3e42 <__libc_fini_array+0x22>
    3e2c:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
    3e30:	3b01      	subs	r3, #1
    3e32:	eb05 0583 	add.w	r5, r5, r3, lsl #2
    3e36:	3c01      	subs	r4, #1
    3e38:	f855 3904 	ldr.w	r3, [r5], #-4
    3e3c:	4798      	blx	r3
    3e3e:	2c00      	cmp	r4, #0
    3e40:	d1f9      	bne.n	3e36 <__libc_fini_array+0x16>
    3e42:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    3e46:	f000 b8f5 	b.w	4034 <_fini>
    3e4a:	bf00      	nop
    3e4c:	00004044 	.word	0x00004044
    3e50:	00004040 	.word	0x00004040

00003e54 <__retarget_lock_acquire_recursive>:
    3e54:	4770      	bx	lr
    3e56:	bf00      	nop

00003e58 <__retarget_lock_release_recursive>:
    3e58:	4770      	bx	lr
    3e5a:	bf00      	nop

00003e5c <__register_exitproc>:
    3e5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3e60:	4d2c      	ldr	r5, [pc, #176]	; (3f14 <__register_exitproc+0xb8>)
    3e62:	4606      	mov	r6, r0
    3e64:	6828      	ldr	r0, [r5, #0]
    3e66:	4698      	mov	r8, r3
    3e68:	460f      	mov	r7, r1
    3e6a:	4691      	mov	r9, r2
    3e6c:	f7ff fff2 	bl	3e54 <__retarget_lock_acquire_recursive>
    3e70:	4b29      	ldr	r3, [pc, #164]	; (3f18 <__register_exitproc+0xbc>)
    3e72:	681c      	ldr	r4, [r3, #0]
    3e74:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    3e78:	2b00      	cmp	r3, #0
    3e7a:	d03e      	beq.n	3efa <__register_exitproc+0x9e>
    3e7c:	685a      	ldr	r2, [r3, #4]
    3e7e:	2a1f      	cmp	r2, #31
    3e80:	dc1c      	bgt.n	3ebc <__register_exitproc+0x60>
    3e82:	f102 0e01 	add.w	lr, r2, #1
    3e86:	b176      	cbz	r6, 3ea6 <__register_exitproc+0x4a>
    3e88:	eb03 0182 	add.w	r1, r3, r2, lsl #2
    3e8c:	2401      	movs	r4, #1
    3e8e:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
    3e92:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
    3e96:	4094      	lsls	r4, r2
    3e98:	4320      	orrs	r0, r4
    3e9a:	2e02      	cmp	r6, #2
    3e9c:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
    3ea0:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
    3ea4:	d023      	beq.n	3eee <__register_exitproc+0x92>
    3ea6:	3202      	adds	r2, #2
    3ea8:	f8c3 e004 	str.w	lr, [r3, #4]
    3eac:	6828      	ldr	r0, [r5, #0]
    3eae:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
    3eb2:	f7ff ffd1 	bl	3e58 <__retarget_lock_release_recursive>
    3eb6:	2000      	movs	r0, #0
    3eb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3ebc:	4b17      	ldr	r3, [pc, #92]	; (3f1c <__register_exitproc+0xc0>)
    3ebe:	b30b      	cbz	r3, 3f04 <__register_exitproc+0xa8>
    3ec0:	f44f 70c8 	mov.w	r0, #400	; 0x190
    3ec4:	f3af 8000 	nop.w
    3ec8:	4603      	mov	r3, r0
    3eca:	b1d8      	cbz	r0, 3f04 <__register_exitproc+0xa8>
    3ecc:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
    3ed0:	6002      	str	r2, [r0, #0]
    3ed2:	2100      	movs	r1, #0
    3ed4:	6041      	str	r1, [r0, #4]
    3ed6:	460a      	mov	r2, r1
    3ed8:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
    3edc:	f04f 0e01 	mov.w	lr, #1
    3ee0:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
    3ee4:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
    3ee8:	2e00      	cmp	r6, #0
    3eea:	d0dc      	beq.n	3ea6 <__register_exitproc+0x4a>
    3eec:	e7cc      	b.n	3e88 <__register_exitproc+0x2c>
    3eee:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
    3ef2:	430c      	orrs	r4, r1
    3ef4:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
    3ef8:	e7d5      	b.n	3ea6 <__register_exitproc+0x4a>
    3efa:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
    3efe:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    3f02:	e7bb      	b.n	3e7c <__register_exitproc+0x20>
    3f04:	6828      	ldr	r0, [r5, #0]
    3f06:	f7ff ffa7 	bl	3e58 <__retarget_lock_release_recursive>
    3f0a:	f04f 30ff 	mov.w	r0, #4294967295
    3f0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3f12:	bf00      	nop
    3f14:	20000448 	.word	0x20000448
    3f18:	00003ff4 	.word	0x00003ff4
    3f1c:	00000000 	.word	0x00000000
    3f20:	00000001 	.word	0x00000001
    3f24:	00000003 	.word	0x00000003
    3f28:	00000005 	.word	0x00000005
    3f2c:	00000007 	.word	0x00000007
    3f30:	00000009 	.word	0x00000009
    3f34:	0000000e 	.word	0x0000000e
    3f38:	00000010 	.word	0x00000010
    3f3c:	00000012 	.word	0x00000012
    3f40:	00000014 	.word	0x00000014
    3f44:	00000016 	.word	0x00000016
    3f48:	00000018 	.word	0x00000018
    3f4c:	0000001c 	.word	0x0000001c
    3f50:	0000001e 	.word	0x0000001e
    3f54:	33323130 	.word	0x33323130
    3f58:	37363534 	.word	0x37363534
    3f5c:	42413938 	.word	0x42413938
    3f60:	46454443 	.word	0x46454443
    3f64:	00000000 	.word	0x00000000
    3f68:	74737953 	.word	0x74737953
    3f6c:	69206d65 	.word	0x69206d65
    3f70:	6974696e 	.word	0x6974696e
    3f74:	7a696c61 	.word	0x7a696c61
    3f78:	6f697461 	.word	0x6f697461
    3f7c:	2e2e2e6e 	.word	0x2e2e2e6e
    3f80:	00000000 	.word	0x00000000
    3f84:	4f525245 	.word	0x4f525245
    3f88:	4d203a52 	.word	0x4d203a52
    3f8c:	61696465 	.word	0x61696465
    3f90:	74746120 	.word	0x74746120
    3f94:	20686361 	.word	0x20686361
    3f98:	6c696166 	.word	0x6c696166
    3f9c:	00006465 	.word	0x00006465
    3fa0:	00000061 	.word	0x00000061
    3fa4:	6d65742f 	.word	0x6d65742f
    3fa8:	6f6c5f70 	.word	0x6f6c5f70
    3fac:	73632e67 	.word	0x73632e67
    3fb0:	00000076 	.word	0x00000076
    3fb4:	4f525245 	.word	0x4f525245
    3fb8:	46203a52 	.word	0x46203a52
    3fbc:	656c6961 	.word	0x656c6961
    3fc0:	6f742064 	.word	0x6f742064
    3fc4:	65706f20 	.word	0x65706f20
    3fc8:	6966206e 	.word	0x6966206e
    3fcc:	0000656c 	.word	0x0000656c
    3fd0:	252e6425 	.word	0x252e6425
    3fd4:	00000064 	.word	0x00000064
    3fd8:	4f525245 	.word	0x4f525245
    3fdc:	57203a52 	.word	0x57203a52
    3fe0:	65746972 	.word	0x65746972
    3fe4:	6c696620 	.word	0x6c696620
    3fe8:	61662065 	.word	0x61662065
    3fec:	64656c69 	.word	0x64656c69
    3ff0:	0000000a 	.word	0x0000000a

00003ff4 <_global_impure_ptr>:
    3ff4:	20000020 33323130 37363534 62613938      .. 0123456789ab
    4004:	66656463 6a696867 6e6d6c6b 7271706f     cdefghijklmnopqr
    4014:	76757473 7a797877 00000000              stuvwxyz....

00004020 <_init>:
    4020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4022:	bf00      	nop
    4024:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4026:	bc08      	pop	{r3}
    4028:	469e      	mov	lr, r3
    402a:	4770      	bx	lr

0000402c <__init_array_start>:
    402c:	00003e01 	.word	0x00003e01

00004030 <__frame_dummy_init_array_entry>:
    4030:	000001a5                                ....

00004034 <_fini>:
    4034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4036:	bf00      	nop
    4038:	bcf8      	pop	{r3, r4, r5, r6, r7}
    403a:	bc08      	pop	{r3}
    403c:	469e      	mov	lr, r3
    403e:	4770      	bx	lr

00004040 <__fini_array_start>:
    4040:	00000181 	.word	0x00000181

Disassembly of section .relocate:

20000000 <delay_cycles>:
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <delay_cycles>
20000008:	4770      	bx	lr
	...

2000000c <SystemCoreClock>:
2000000c:	c138 0001                                   8...

20000010 <SDA>:
20000010:	4000 0000                                   .@..

20000014 <SCL>:
20000014:	8000 0000                                   ....

20000018 <I2C_Address>:
20000018:	004f 0000 0000 0000                         O.......

20000020 <impure_data>:
20000020:	0000 0000 030c 2000 0374 2000 03dc 2000     ....... t.. ... 
	...
200000c8:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200000d8:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000448 <__atexit_recursive_mutex>:
20000448:	11c4 2000                                   ... 
